" Vimball Archiver by Charles E. Campbell
UseVimball
finish
./.gitignore	[[[1
4
*.pyc
*~
*.swo
*.swp
./.travis.yml	[[[1
8
language: c
sudo: false

notifications:
  email: false

script:
  - ./tests.sh
./AUTHORS	[[[1
383
Authors
===============================================================================

Generated with "git log --oneline --pretty="%an" | sort | uniq > AUTHORS

Aaron Broder
Adnan Zafar
afolmert
aisensiy
Alexander Ross
Alexandre de Oliveira
Alexey Shevchenko
Alex Tan
Allen.M
Alvin Chan
ALX-Liu-Xiao
Andrea Giardini
Andreas Krennmair
Andreas Steinel
Andrei Cristian Petcu
Andrej Radovic
Andre Walker
Andrey Paskal
Andy Waite
Angel Alonso
Ángel Alonso
Anne Douwe Bouma
Anthony Wilson
Arvind
ashfinal
Audrius Kažukauskas
Austin Wood
Aydar Khabibullin
babybeasimple
Benjamin Nørgaard
Bernhard Graf
Bill Casarin
binaryplease
Björn
Björn-Egil Dahlberg
BlackEagle
Boone Severson
bounceme
Bradlee Speice
Brandon Dulaney
Brandon Hilkert
Brian Hogan
Brian van Burken
Bruno Sutic
Camilo Payan
carme
Cézar Antáres
Chad Paradis
Chen Zhongzheng
Ches Martin
ChickenNuggers
Chipairon
Chris Dueck
Chris Nicola
Chris Sims
Christian
Christian Höltje
Christian Neumüller
Christopher Joslyn
chrisyue
Ciro Santilli
Ciro Santilli 六四事件 法轮功
Claudio Maradonna
Connor Atherton
Cooper LeBrun
Corentin Peuvrel
Craig Paterson
Craig P Jolicoeur
crazymaster
daa84
Daeyun Shin
Dale Roberts
Daniel Hahler
Dan Loewenherz
Danny Navarro
daoo
Darrell Hamilton
David Arvelo
David Barnett
David C. Bishop
David Deryl Downey - AKA Deryl R. Doucette
David Rodríguez de Dios
David Sanson
dengyaolong
Derek Morey
dhilipsiva
djdt
Dmitry Dementev
Donny Yang
DSIW
dzikie drożdże
Eduardo Gurgel
Eli Gundry
emzap79
Enric Lluelles
Enrico Maria De Angelis
Erich Heine
Erik Westrup
Ernest
Eugene Kalinin
Eustaquio Rangel
Eustáquio Rangel
Fatih Arslan
Felix Jung
Filipe Giusti
Florent Lévigne
Florian Sattler
frans
Fuad Saud
Gabriel Chavez
Gaël Chamoulaud
Gea-Suan Lin
George Guimarães
George Lee
Georgios Samaras
Gert
gfixler
Gilad Peleg
gk
goonnow
Gueunet Charles
Gui Lin
guneysus
Gustavo Chain
Gustavo Ferreira
Hans-Guenter
Harald Wartig
Henrik Kjelsberg
HIRAKI Satoru
Holger Rapp
Honza
Honza Pokorny
hulufei
Igor Goldvekht
Ilker Cetinkaya
indi
Indra Susila
Ionică Bizău
Iuri Fernandes
Jack Stalnaker
Jacobo de Vera
Jacques Kvam
jake romer
Jakub Stasiak
James Turley
Jan Mollowitz
Jason S. Jones
Jean Jordaan
Jeffrey Tratner
Jens Hoepken
jiangyc0
Jim Deville
Jinzhu
Joey Curtin
Johannes Wienke
jonasac
Jonas Bygdén
Jonathan Martin
Jorge García
Jorge López Pérez
Joseph Lin
Josh Bode
Josh Davis
Josh Matthews
Josh Vandergrift
Josh Wainwright
JuanPablo
Julian Bennecker
Julien Deniau
Julien Pivard
Julien Stechele
Julien STECHELE
Kalinin Eugene
kenshin54
Kentaro Imai
Kevin Koltz
Kevin Lui
Kevin Mees
Kevin Murray
Kevin Schaul
Konstantin
Konstantin Gorodinskiy
Laas Toom
Laurent Georget
laxtiz
Leandro Moreira
Leonardo B
Leonidez Acosta
linduxed
Li Xin
Louis
Louis Pilfold
Lucas Hoffmann
Luis Carlos Cruz
Luis Carlos Cruz Carballo
Luiz Gonzaga dos Santos Filho
majjoha
mangege
Marc Camuzat
Marcelo D Montu
Marcelo Jacobus
Marcin Kulik
Marcus Kammer
Marc Weber
Mario de Frutos
Markus Benning
marocchino
Martin Atukunda
Martin Heuschober
Martxel Lasa
Matěj Cepl
Mathew Attlee
Mathieu Comandon
Matthew Barry
Matthias Viehweger
Mattia Tezzele
Matt Rasband
Matt Stevens
Mauro Porras P
Maximiliano Robaina
Mayeu (Cast)
Meng Zhuo
Michael Gehring
Michael Hinrichs
Michael Rutter
Michael Thessel
Michi Huber
Mickey
midchildan
Mike Foley
Mike Smullin
Miki Tebeka
Minjong Chung
M. Maxwell Watson
mMontu
mockturtl
m-pilia
Muhammad Hallaj Subery
mwcz
Namit
Nan Cloudio Jiang
Nan Zheng
Nate Mara
netei
Ngo The Trung
Nguyen Le
Nick Janetakis
Nicklasos
Nick Papanastasiou
Nicolas G. Querol
Nico Suhl
No Ducks
Norman Messtorff
obaoba
oddlydrawn
Oleg Voronkovich
Ole Hansen
Oliver Andrich
Ondrej Slinták
onemanstartup
opennota
Paco Esteban
Panagiotis Mavrogiorgos
Paolo Cretaro
Pascal
Paulo Romeira
Pawel Jankowski
phcerdan
Philippe Mongeau
Philipp Jovanovic
Piotr Jawniak
Piotr Yordanov
Pirogov Evgenij
Pompeu
Povilas Balzaravicius Pawka
Procras
protream
pydave
r4d2
Radosław Szymczyszyn
Ralph-Wang
Raül Torralba
raydeal
rcolombo
Rekky
René
Rene Vergara
Renzo Poddighe
Reyes Yang
ricardogcolombo
Ricardo Jesus
Rich Layte
Roberto Miranda
robin
Robin Grindrod
Rok Garbas
Roland Sommer
Rory McNamara
rsw0x
rtorralba
Ruben Vereecken
Ryan Bright
Ryan Pineo
Ryan Wang
Sam Shepherd
Santiago Gallego
sasidhar-d
Sathors
Sebastian Röder
Sebastian Wiesner
Sergey Lebedev
Sergey Zasenko
Serhiy Oplakanets
SevereOverfl0w
Simeon F. Willbanks
Simeon Willbanks
Simon Désaulniers
sirex
skv
Sokovikov
Srijan Choudhary
Steeve
stefan
Stephen Tudor
Stephen Woods
Steve Brown
Steven Humphrey
Steven Oliver
Stuart Grimshaw
Sudar
¨switch87¨
Tevin Zhang
theocrite
Thiago de Arruda
Thomas Duerr
Thomas Szymanski
tinyladi
Tobias Witt
Tobie Warburton
Tomasz Wisniewski
Tom Vincent
Tony
Tony Narlock
toogley
Torbjørn Vatn
tormaroe
ToruIwashita
Travis Holton
Trevor Sullivan
troydm
tUrG0n
twabiko
Tyler Ball
tyronepost
Tyrone Post
Vadim Khohlov
Vincent Hsu
Vladimir Rybas
Vladislav Khvostov
Vorzard
Vzaa
Waldecir Santos
Wildsky Fann
William Ma
William Travis Holton
X4fyr
xz.zhang
Yamamoto Yuji
Yannick Brehon
yerv000
Yike Lu
yuhuanbo
Yu Huanbo
Yves Lange
yvhn
zauguin
Zaven Muradyan
ZPH
./LICENSE	[[[1
20
Copyright (c) 2011 see AUTHORS

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

./README.md	[[[1
261
snipMate & UltiSnip Snippets
============================

[![Build Status](https://travis-ci.org/honza/vim-snippets.svg)](https://travis-ci.org/honza/vim-snippets)

This repository contains snippets files for various programming languages.

It is community-maintained and many people have contributed snippet files and
other improvements already.

Contents
--------

- `snippets/*`: snippets using snipMate format
- `UltiSnips/*`: snippets using UltiSnips format

Snippet engines supporting vim-snippets
----------------------------------------

There are different forks of snippet engines which allow the user to insert
snippets by typing the name of a snippet hitting the expansion mapping.

- [github.com/SirVer/ultisnips][7]:
  python, supports all snippets in this repo.
- [github.com/garbas/vim-snipmate](https://github.com/garbas/vim-snipmate):
  VimL, snipmate-snippets, engine sometimes behaves strange. Supports
  snippets/*
- [github.com/Shougo/neosnippet](https://github.com/Shougo/neosnippet.vim):
  VimL, supports snippets/* with some configuration.
- [github.com/dcampos/nvim-snippy](https://github.com/dcampos/nvim-snippy):
  Lua, supports snippets/* with some configuration.
- [github.com/L3MON4D3/LuaSnip](https://github.com/L3MON4D3/LuaSnip):
  Lua, supports snippets/* with some configuration.
  Also supports redefining snippets without changing the priority, unlike
  nvim-snippy.
- [github.com/drmingdrmer/xptemplate](https://github.com/drmingdrmer/xptemplate):
  Totally different syntax, does not read snippets contained in this file, but
  it is also very powerful. It does not support vim-snippets (just listing it
  here for completeness)

There tries to be a more comprehensive list (which still is incomplete) here:
http://vim-wiki.mawercer.de/wiki/topic/text-snippets-skeletons-templates.html

UltiSnips has additional features such as high speed, nesting snippets,
expanding snippets in snippets and offers powerful transformations on text in
snippets (like visual selections or placeholder texts).

Which one to use? If you have python give [SirVer/ultisnips][7] a try because
its fast and has the most features.

If you have VimL only (vim without python support) your best option is using
[garbas/vim-snipmate](https://github.com/garbas/vim-snipmate) and cope with the
minor bugs found in the engine.

If you use Neovim and prefer Lua plugins,
[L3MON4D3/LuaSnip](https://github.com/L3MON4D3/LuaSnip) is the best option.

**Q**: Should snipMate be deprecated in favour of UltiSnips?

**A**: No, because snipMate is VimL, and UltiSnips requires Python.
Some people want to use snippets without having to install Vim with Python
support. Yes - this sucks.

One solution would be: Use snippets if they are good enough, but allow overriding them
in UltiSnips. This would avoid most duplication while still serving most users.
AFAIK there is a nested-placeholder branch for snipMate too. snipMate is still
improved by Adnan Zafar. So maybe time is not ready to make a final decision yet.

[github issue/discussion](https://github.com/honza/vim-snippets/issues/363)

Vendor Snippets
---------------

Additional library and framework snippets are available for UltiSnips users in
the `UltiSnips/` directory. These files are removed from the default language
namespaces to prevent them from all being loaded automatically. If there is a
separate library, framework, or package you would like to support open a pull
request!

Additional snippets can be added to the current buffer with the
`:UltiSnipsAddFiletypes` command followed by the snippet name without the
"snippets" ending. For example, to add the JavaScript Jasmine snippets, run:
`:UltiSnipsAddFiletypes javascript-jasmine`. To have this snippet loaded
everytime a JavaScript file is opened or created you can add the command to your
 -`.vim/ftplugin/javascript.vim` file. Another way is to add
 `autocmd FileType js UltiSnipsAddFiletypes javascript-jasmine` in your `.vimrc`.


For more see the UltiSnips docs (`:help UltiSnips`).

Installation
------------

First be aware that there are many options, see "Snippet engines" above.  Second
be aware than there are [tons of plugin managers][8] which is why Marc Weber
thinks that it doesn't make sense to repeat the same repetitive information
everywhere.

The recommended way to install these snippets is by using
[vim-addon-manager][9].  Marc Weber wrote it for exactly this reason, it
supports simple dependency management. E.g. all you need is this line in your
`.vimrc`:

```vim
" assuming you want to use snipmate snippet engine
ActivateAddons vim-snippets snipmate
```

[vim-pi](https://bitbucket.org/vimcommunity/vim-pi/issue/90/we-really-need-a-web-interface)
Is the place to discuss plugin managers and repository resources.

For snipMate installation instructions, please see [snipmate@garbas][1].

Pull requests adding installation instructions for Pathogen, Bundle, git clone,
etc. are welcome and much appreciated.

Getting help
------------

If you still have trouble getting this to work, please create a GitHub issue.

Things to consider when contributing
------------------------------------

Some snippets are useful for almost all languages, so let's try to have the same
triggers for them:

```
if : if without else
ife: if $1 else $2
eif : else if ($1) { .. }
el  : else ..
wh  : while (cond) ...
```

Don't add useless placeholder default texts like:

```
if (${1:condition}){
  ${0:some code here}
}
```
instead use:

```
if (${1}){
  ${0:${VISUAL}}
}
```

Exception: Functions which are used less often, such as Vim's `matchall()`, `matchstr()`
functions which case hints may be helpful to remember order. In the VimL case
get vim-dev plugin which has function completion

Thus for conditions (while, if ..) and block bodies just use ${N} - Thanks

When the snippet can be used to wrap existing code leverage `${VISUAL}`

Open questions:
What about one line if ee then .. else .. vs if \n .. then \n ... \n else \n .. ?
Which additional policies to add?
Discuss at: https://github.com/honza/vim-snippets/issues/230

*folding markers*:
Until further work is done on `vim-snipmate`, please don't add folding markers
into snippets. `vim-snipmate` has some comments about how to patch all snippets
on the fly adding those.

Currently all snippets from UltiSnips have been put into `/UltiSnips` - some work
on merging should be done (dropping duplicates etc). Also see engines section above.

Related repositories
--------------------

We also encourage people to maintain sets of snippets for particular use cases
so that all users can benefit from them.  People can list their snippet repositories here:

* https://github.com/rbonvall/snipmate-snippets-bib (snippets for BibTeX files)
* https://github.com/sudar/vim-arduino-snippets (snippets for Arduino files)
* https://github.com/zedr/zope-snipmate-bundle.git (snippets for Python, TAL and ZCML)
* https://github.com/bonsaiben/bootstrap-snippets (snippets for Twitter Bootstrap markup, in HTML and Haml)
* https://github.com/sniphpets (advanced snippets for PHP, Symfony 2/3, Doctrine and etc.)

Installation using VAM: https://github.com/MarcWeber/vim-addon-manager

Future ideas and examples
-------------------------

[overview snippet engines](http://vim-wiki.mawercer.de/wiki/topic/text-snippets-skeletons-templates.html)
If you have ideas you can add them to that list of "snippet engine features by example".

Historical notes
----------------

[vim-snipmate][1] was originally started by [Michael Sanders][2] who has now
unfortunately abandoned the project. [Rok Garbas][3] is now maintaining a
[fork][4] of the project in hopes of improving the existing code base.

Versions / dialects / ..
========================

There are some issues, such as newer language versions may require other
snippets than older. If this exists we currently recommend doing this:

* add snippets/ruby.snippets (common snippets)
* add snippets/ruby-1.8.snippets (1.8 only)
* add snippets/ruby-1.9.snippets (1.9 only)

then configure https://github.com/garbas/vim-snipmate this way:

```vim
let g:snipMate = {}
let g:snipMate.scope_aliases = {}
let g:snipMate.scope_aliases['ruby'] = 'ruby,ruby-rails,ruby-1.9'
```

If it happens that you work on a project requiring ruby-1.8 snippets instead,
consider using `vim-addon-local-vimrc` and override the filetypes.

Well - of course it may not make sense to create a new file for each
ruby-library-version triplet. Sometimes postfixing a name such as

```
migrate_lib_20_down
migrate_lib_20_up
```

will do it then if syntax has changed.

Language maintainers
--------------------

No one can really be proficient in all programming languages. If you would like
to maintain snippets for a language, please get in touch.

Notes: People are interested in snippets - and their interest may wane again.
This list is kept up-to-date on a best effort basis.

* Elixir - [lpil](https://github.com/lpil), [iurifq](https://github.com/iurifq)
* Falcon - [steveno](https://github.com/steveno)
* HTML Django - [honza](http://github.com/honza)
* Javascript - [honza](http://github.com/honza)
* Markdown - [honza](http://github.com/honza)
* PHP - [chrisyue](http://github.com/chrisyue)
* Python - [honza](http://github.com/honza)
* Ruby - [taq](http://github.com/taq)
* Scala - [gorodinskiy](https://github.com/gorodinskiy)

License
-------

Just as the original snipMate plugin, all the snippets are licensed under the
terms of the MIT license.

[1]: http://github.com/garbas/vim-snipmate
[2]: http://github.com/msanders
[3]: http://github.com/garbas
[4]: http://github.com/garbas/vim-snipmate
[7]: http://github.com/SirVer/ultisnips
[8]: http://vim-wiki.mawercer.de/wiki/topic/vim%20plugin%20managment.html
[9]: https://github.com/MarcWeber/vim-addon-manager
./UltiSnips/README	[[[1
17
This directory contains the snippets for UltiSnips.
https://github.com/sirver/ultisnips

Standing On The Shoulders of Giants
===================================

The snippets have been collected from various other project which I want to
express my gratitude for. My main source for inspiration where the following
two projects:

   TextMate: http://svn.textmate.org/trunk/Bundles/
   SnipMate: http://code.google.com/p/snipmate/

UltiSnips has seen contributions by many individuals. Those contributions have
been merged into this collection seamlessly and without further comments.

-- vim:ft=rst:nospell:
./UltiSnips/ada.snippets	[[[1
282
priority -50

global !p

def ada_case(word):
	out = word[0].upper()
	for i in range(1, len(word)):
		if word[i] == '-':
			out = out + '.'
		elif word[i - 1] == '_' or word[i - 1] == '-':
			out = out + word[i].upper()
		else:
			out = out + word[i]
	return out

endglobal

snippet wi "with"
with $1;$0
endsnippet

snippet pac "package"
package ${1:`!p snip.rv = ada_case(snip.basename)`} is
	$0
end $1;
endsnippet

snippet pacb "package body"
package body ${1:`!p snip.rv = ada_case(snip.basename)`} is
	$0
end $1;
endsnippet

snippet ent "entry ... when"
entry $1($2) when $3 is
begin
	$0
end $1;
endsnippet

snippet task "task"
task $1 is
	entry $0
end $1;
endsnippet

snippet taskb "task body"
task body $1 is
	$2
begin
	$0
end $1;
endsnippet

snippet acc "accept"
accept $1($2) do
	$0
end $1;
endsnippet

snippet prot "protected type"
protected type $1($2) is
	$0
end $1;
endsnippet

snippet prob "protected body"
protected body $1 is
	$2
begin
	$0
end $1;
endsnippet

snippet gen "generic type"
generic
	type $1 is $2;$0
endsnippet

snippet ty "type"
type $1 is $2;$0
endsnippet

snippet tyd "type with default value"
type $1 is $2
	with Default_Value => $3;$0
endsnippet

snippet subty "subtype"
subtype $1 is $2;$0
endsnippet

snippet dec "declare block"
declare
	$1
begin
	$0
end;
endsnippet

snippet decn "declare named block"
$1:
declare
	$2
begin
	$0
end $1;
endsnippet

snippet ifex "if expression"
if $1 then $2 else $0
endsnippet

snippet casex "case expression"
case $1 is
	when $2 => $3,$0
endsnippet

snippet fora "for all"
for all $1 ${2:in} $3 => $0
endsnippet

snippet fors "for some"
for some $1 ${2:in} $3 => $0
endsnippet

snippet if "if"
if $1 then
	$0
end if;
endsnippet

snippet ife "if ... else"
if $1 then
	$2
else
	$0
end if;
endsnippet

snippet el "else"
else
	$0
endsnippet

snippet eif "elsif"
elsif $1 then
	$0
endsnippet

snippet wh "while"
while $1 loop
	$0
end loop;
endsnippet

snippet nwh "named while"
$1:
while $2 loop
	$0
end loop $1;
endsnippet

snippet for "for"
for ${1:I} in $2 loop
	$0
end loop;
endsnippet

snippet fore "for each"
for $1 of $2 loop
	$0
end loop;
endsnippet

snippet nfor "named for"
$1:
for ${2:I} in $3 loop
	$0
end loop $1;
endsnippet

snippet nfore "named for each"
$1:
for $2 of $3 loop
	$0
end loop $1;
endsnippet

snippet proc "procedure"
procedure $1($2) is
	$3
begin
	$0
end $1;
endsnippet

snippet procd "procedure declaration"
procedure $1;$0
endsnippet

snippet fun "function"
function $1($2) return $3 is
	$4
begin
	$0
end $1;
endsnippet

snippet fune "expression function"
function $1 return $2 is
	($3);$0
endsnippet

snippet fund "function declaration"
function $1 return $2;$0
endsnippet

snippet ret "extended return"
return $1 do
	$0
end return;
endsnippet

snippet rec "record"
record
	$0
end record;
endsnippet

snippet case "case"
case $1 is
	when $2 => $3;$0
end case;
endsnippet

snippet whe "when"
when $1 => $2;$0
endsnippet

snippet wheo "when others"
when others => $1;$0
endsnippet

snippet lo "loop"
loop
	$0
end loop;
endsnippet

snippet nlo "named loop"
$1:
loop
	$0
end loop $1;
endsnippet

snippet ex "exit when"
exit when $1;$0
endsnippet

snippet put "Ada.Text_IO.Put"
Ada.Text_IO.Put($1);$0
endsnippet

snippet putl "Ada.Text_IO.Put_Line"
Ada.Text_IO.Put_Line($1);$0
endsnippet

snippet get "Ada.Text_IO.Get"
Ada.Text_IO.Get($1);$0
endsnippet

snippet getl "Ada.Text_IO.Get_Line"
Ada.Text_IO.Get_Line($1);$0
endsnippet

snippet newline "Ada.Text_IO.New_Line"
Ada.Text_IO.New_Line(${1:1});$0
endsnippet

# vim:ft=snippets:
./UltiSnips/all.snippets	[[[1
113
# This file contains snippets that are always defined. I personally
# have snippets for signatures and often needed texts

# sligthly lower priority than everything else since specialized versions
# should overwrite. The user needs to adjust her priority in her snippets to
# ~-55 so that other filetypes will still overwrite.
priority -60

##############
# NICE BOXES #
##############
global !p
from vimsnippets import foldmarker, make_box, get_comment_format
LOREM = """
Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod \
tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At \
vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, \
no sea takimata sanctus est Lorem ipsum dolor sit amet.
"""
endglobal

snippet box "A nice box with the current comment symbol" b
`!p
box = make_box(len(t[1]))
snip.rv = box[0]
snip += box[1]
`${1:${VISUAL:content}}`!p
box = make_box(len(t[1]))
snip.rv = box[2]
snip += box[3]`
$0
endsnippet

snippet bbox "A nice box over the full width" b
`!p
if not snip.c:
	width = int(vim.eval("&textwidth - (virtcol('.') == 1 ? 0 : virtcol('.'))")) or 71
box = make_box(len(t[1]), width)
snip.rv = box[0]
snip += box[1]
`${1:${VISUAL:content}}`!p
box = make_box(len(t[1]), width)
snip.rv = box[2]
snip += box[3]`
$0
endsnippet

snippet fold "Insert a vim fold marker" b
`!p snip.rv = get_comment_format()[0]` ${1:Fold description} `!p snip.rv = foldmarker()[0]`${2:1} `!p snip.rv = get_comment_format()[2]`
endsnippet

snippet foldc "Insert a vim fold close marker" b
`!p snip.rv = get_comment_format()[0]` ${2:1}`!p snip.rv = foldmarker()[1]` `!p snip.rv = get_comment_format()[2]`
endsnippet

snippet foldp "Insert a vim fold marker pair" b
`!p snip.rv = get_comment_format()[0]` ${1:Fold description} `!p snip.rv = foldmarker()[0]` `!p snip.rv = get_comment_format()[2]`
${2:${VISUAL:Content}}
`!p snip.rv = get_comment_format()[0]` `!p snip.rv = foldmarker()[1]` $1 `!p snip.rv = get_comment_format()[2]`
endsnippet

##########################
# LOREM IPSUM GENERATORS #
##########################
snippet "lorem(([1-4])?[0-9])?" "Lorem Ipsum" r
`!p snip.rv = " ".join(LOREM.split()[:int(match.group(1))]) if match.group(1) else LOREM`
endsnippet

##########################
# VIM MODELINE GENERATOR #
##########################
# See advice on `:help 'tabstop'` for why these values are set. Uses second
# modeline form ('set') to work in languages with comment terminators
# (/* like C */).
snippet modeline "Vim modeline"
vim`!v ':set '. (&expandtab ? printf('et sw=%i ts=%i', &sw, &ts) : printf('noet sts=%i sw=%i ts=%i', &sts, &sw, &ts)) . (&tw ? ' tw='. &tw : '') . ':'`
endsnippet

#########
# DATES #
#########
snippet date "YYYY-MM-DD" w
`!v strftime("%Y-%m-%d")`
endsnippet

snippet ddate "Month DD, YYYY" w
`!v strftime("%b %d, %Y")`
endsnippet

snippet diso "ISO format datetime" w
`!v strftime("%Y-%m-%d %H:%M:%S%z")`
endsnippet

snippet time "hh:mm" w
`!v strftime("%H:%M")`
endsnippet

snippet datetime "YYYY-MM-DD hh:mm" w
`!v strftime("%Y-%m-%d %H:%M")`
endsnippet

snippet todo "TODO comment" bw
`!p snip.rv=get_comment_format()[0]` ${2:TODO}: $0${3: <${4:`!v strftime('%d-%m-%y')`}${5:, `!v g:snips_author`}>} `!p snip.rv=get_comment_format()[2]`
endsnippet

##########
#  Misc  #
##########
snippet uuid "Random UUID" w
`!p if not snip.c: import uuid; snip.rv = str(uuid.uuid4())`
endsnippet

# vim:ft=snippets:
./UltiSnips/bib.snippets	[[[1
52
priority -50

snippet online "Online resource" b
@online{${1:name},
	author={${2:author}},
	title={${3:title}},
	date={${4:date}},
	url={${5:url}}
}
$0
endsnippet

snippet article "Article reference" b
@article{${1:name},
	author={${2:author}},
	title={${3:title}},
	journaltitle={${4:journal}},
	volume={${5:NN}},
	number={${6:NN}},
	year={${7:YYYY}},
	pages={${8:NN}--${9:NN}}
}
$0
endsnippet

snippet book "Book reference" b
@book{${1:name},
	author={${2:author}},
	title={${3:title}},
	subtitle={${4:subtitle}},
	year={${5:YYYY}},
	location={${6:somewhere}},
	publisher={${7:publisher}},
	pages={${8:NN}--${9:NN}}
}
$0
endsnippet

snippet inb "In Book reference" b
@inbook{${1:name},
	author={${2:author}},
	title={${3:title}},
	subtitle={${4:subtitle}},
	booktitle={${5:book}},
	editor={${6:editor}},
	year={${7:YYYY}},
	location={${8:somewhere}},
	publisher={${9:publisher}},
	pages={${10:NN}--${11:NN}}
}
$0
endsnippet
./UltiSnips/bindzone.snippets	[[[1
29
priority -50

global !p
def newsoa():
	import datetime
	now = datetime.datetime.now()
	# return standard SOA formatted serial for today
	return now.strftime("%Y%m%d00")
endglobal

snippet zone "Bootstrap a new Bind zonefile" b
$TTL 86400
@	  IN SOA   ${1:example.net}.	 ${2:hostmaster.$1}.(
						`!p snip.rv = newsoa()`;	 serial
						21600;			refresh every 6 hours
						3600;			retry after one hour
						604800;			expire after a week
						86400 );		minimum TTL of 1 day

				IN		NS				ns01.$1.
				IN		MX		10		mail.$1.

ns01.$1			IN		A
mail.$1			IN		A
endsnippet

snippet A "Insert A Record" b
${1:hostname}	IN		A	${2:ip}
endsnippet
./UltiSnips/blade.snippets	[[[1
139
priority -50

extends html

# We want to overwrite everything in parent ft.
priority -49

snippet break "@break"
@break
endsnippet

snippet component "@component directive"
@component('$1')
	${2:${VISUAL}}
@endcomponent
endsnippet

snippet each "@each directive"
@each('$1', $$2, '$3')
endsnippet

snippet else "@else directive"
@else
endsnippet

snippet eif "@else if directive"
@else if ($1)
	${2:${VISUAL}}
endsnippet

snippet for "@for directive"
@for ($1)
	${2:${VISUAL}}
@endfor
endsnippet

snippet foreach "@foreach directive"
@foreach ($$1 as $$2)
	${3:${VISUAL}}
@endforeach
endsnippet

snippet extends "@extends directive"
@extends('$1')
endsnippet

snippet if "@if directive"
@if ($1)
	${2:${VISUAL}}
@endif
endsnippet

snippet ife "@if @else structure"
@if ($1)
	${2:${VISUAL}}
@else
	${3:${VISUAL}}
@endif
endsnippet

snippet include "@include directive"
@include('$1')
endsnippet

snippet includeIf "@includeIf directive"
@includeIf('$1')
endsnippet

snippet isset "@isset directive"
@isset
	${1:${VISUAL}}
@endisset
endsnippet

snippet inject "@inject directive"
@inject('$1', '$2')
endsnippet

snippet lang "@lang directive" i
@lang('$1')
endsnippet

snippet php "@php directive"
@php
	${1:${VISUAL}}
@endphp
endsnippet

snippet push "@push directive"
@push('$1')
	${2:${VISUAL}}
@endpush
endsnippet

snippet section "@section directive"
@section('$1')
endsnippet

snippet show "@show directive"
@show
endsnippet

snippet slot "@slot directive"
@slot('$1')
	${2:${VISUAL}}
@endslot
endsnippet

snippet unless "@unless directive"
@unless
	${1:${VISUAL}}
@endunless
endsnippet

snippet verbatim "@verbatim directive"
@verbatim
	${0:$VISUAL}
@endverbatim
endsnippet

snippet wh "@while directive"
@while ($1)
	${2:${VISUAL}}
@endwhile
endsnippet

snippet yield "@yield directive"
@yield('$1')
endsnippet

snippet { "{{ }} statement." i
{{ $1 }}
endsnippet

snippet {! "{!! !!} statement" i
{!! $1 !!}
endsnippet

# vim:ft=snippets:
./UltiSnips/c.snippets	[[[1
186
###########################################################################
#                            TextMate Snippets                            #
###########################################################################
# --------------
# Functions
# --------------
global !p
def printf_expand_args(snip):
	"""
	This will look how many placeholders printf has and adds the separated commas
	at the end.
	"""
	
	# now add so many "," as much as the amount of placeholders
	amount_placeholders = snip.tabstops[1].current_text.count("%")

	output = ""

	# Add the amount of tabstops
	for placeholder_index in range(3, amount_placeholders + 3):
		output += f", ${placeholder_index}"
	
	# convert them into tabstops
	snip.expand_anon(output)

endglobal

# ==============
# Snippets 
# ==============
priority -50

snippet def "#define ..."
#define $1
endsnippet

snippet #ifndef "#ifndef ... #define ... #endif"
#ifndef ${1/([A-Za-z0-9_]+).*/$1/}
#define ${1:SYMBOL} ${2:value}
#endif /* ifndef $1 */
endsnippet

snippet #if "#if #endif" b
#if ${1:0}
${VISUAL}$0
#endif
endsnippet

snippet mark "#pragma mark (mark)"
#if 0
${1:#pragma mark -
}#pragma mark $2
#endif

$0
endsnippet

snippet main "main() (main)"
int main(int argc, char *argv[])
{
	${VISUAL}$0
	return 0;
}
endsnippet

snippet for "for loop (for)"
for (${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
	${VISUAL}$0
}
endsnippet

snippet fori "for int loop (fori)"
for (${4:int} ${2:i} = 0; $2 < ${1:count}; ${3:++$2}) {
	${VISUAL}$0
}
endsnippet

snippet fora "for-loop" b
for (${1:var}; ${2:condition}; `!p
if len(t[1]) > 0:
	snip.rv = t[1].split('=')[0].split()[-1]
`++) {
	
	$0
} /* for ($1; $2; `!p if len(t[1]) > 0: snip.rv = t[1].split('=')[0].split()[-1]`++) */
endsnippet

snippet once "Include header once only guard"
#ifndef ${1:`!p
if not snip.c:
	import random, string
	name = re.sub(r'[^A-Za-z0-9]+','_', snip.fn).upper()
	rand = ''.join(random.sample(string.ascii_letters+string.digits, 8))
	snip.rv = ('%s_%s' % (name,rand)).upper()
else:
	snip.rv = snip.c`}
#define $1

${VISUAL}$0

#endif /* end of include guard: $1 */
endsnippet

snippet fprintf "fprintf ..."
fprintf(${1:stderr}, "${2:%s}\n"${2/([^%]|%%)*(%.)?.*/(?2:, :\);)/}$3${2/([^%]|%%)*(%.)?.*/(?2:\);)/}
endsnippet

snippet eli "else if .. (eli)"
else if (${1:/* condition */}) {
	${VISUAL}$0
}
endsnippet

post_jump "printf_expand_args(snip)"
snippet "printf" "printf with auto-expand args" wr
printf("$1\n"$2);
endsnippet

snippet st "struct"
struct ${1:`!p snip.rv = (snip.basename or "name") + "_t"`} {
	${0:/* data */}
};
endsnippet

snippet fun "function" b
${1:void} ${2:function_name}($3)
{
	${VISUAL}$0
}
endsnippet

snippet fund "function declaration" b
${1:void} ${2:function_name}($3);
endsnippet

global !p
def split_line(text):
	import textwrap
	lines = textwrap.wrap(text, 78 - 19)
	output = list()
	for line in lines:
		output.append('*' + ' '*19 + line)
	snip_line = snip.tabstops[4].end[0]
	snip.buffer.append(output, snip_line + 1)
	del snip.buffer[snip_line]

def get_args(arglist):
	args = [arg.strip() for arg in arglist.split(',') if arg]
	return args
endglobal

post_jump "if snip.tabstop == 0 : split_line(snip.tabstops[4].current_text)"
snippet head "File Header" b
/******************************************************************************
* File:             `!p snip.rv = fn`
*
* Author:           ${2}  
* Created:          `date +%m/%d/%y` 
* Description:      ${4:${VISUAL}}
*****************************************************************************/
${0}
endsnippet

post_jump "if snip.tabstop == 0 : split_line(snip.tabstops[4].current_text)"
snippet func "Function Header" 
/******************************************************************************
* Function:         $1
* Description:      ${4:${VISUAL}}
* Where:`!p 
snip.rv = ""
snip >> 2

args = get_args(t[2])
if args:
	for arg in args:
		snip.rv += '\n' + '*' + ' '*19 + arg + ' - TODO'
snip << 2
`
* Return:           $5
* Error:            $6
*****************************************************************************/
${1}($2){
	${0}
}
endsnippet
# vim:ft=snippets:
./UltiSnips/coffee-jasmine.snippets	[[[1
166
#
# CoffeeScript versions -- adapted from the JS TextMate bundle + additions
# for some jasmine-jquery matchers
#
priority -50

extends coffee

priority -49

snippet des "Describe (coffee)" b
describe '${1:description}', ->
	$0
endsnippet

snippet it "it (coffee)" b
it '${1:description}', ->
	$0
endsnippet

snippet bef "before each (coffee)" b
beforeEach ->
	$0
endsnippet

snippet aft "after each (coffee)" b
afterEach ->
	$0
endsnippet

snippet any "any (coffee)" b
jasmine.any($1)
endsnippet

snippet ru "runs (coffee)" b
runs ->
	$0
endsnippet

snippet wa "waits (coffee)" b
waits($1)
endsnippet

snippet ex "expect (coffee)" b
expect(${1:target})$0
endsnippet

snippet ee "expect to equal (coffee)" b
expect(${1:target}).toEqual(${2:value})
endsnippet

snippet em "expect to match (coffee)" b
expect(${1:target}).toMatch(${2:pattern})
endsnippet

snippet eha "expect to have attribute (coffee)" b
expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'})
endsnippet

snippet et "expect to be truthy (coffee)" b
expect(${1:target}).toBeTruthy()
endsnippet

snippet ef "expect to be falsy (coffee)" b
expect(${1:target}).toBeFalsy()
endsnippet

snippet ed "expect to be defined (coffee)" b
expect(${1:target}).toBeDefined()
endsnippet

snippet en "expect to be null (coffee)" b
expect(${1:target}).toBeNull()
endsnippet

snippet ec "expect to contain (coffee)" b
expect(${1:target}).toContain(${2:value})
endsnippet

snippet ev "expect to be visible (coffee)" b
expect(${1:target}).toBeVisible()
endsnippet

snippet eh "expect to be hidden (coffee)" b
expect(${1:target}).toBeHidden()
endsnippet

snippet notx "expect not (coffee)" b
expect(${1:target}).not$0
endsnippet

snippet note "expect not to equal (coffee)" b
expect(${1:target}).not.toEqual(${2:value})
endsnippet

snippet notm "expect not to match (coffee)" b
expect(${1:target}).not.toMatch(${2:pattern})
endsnippet

snippet notha "expect to not have attribute (coffee)" b
expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'})
endsnippet

snippet nott "expect not to be truthy (coffee)" b
expect(${1:target}).not.toBeTruthy()
endsnippet

snippet notf "expect not to be falsy (coffee)" b
expect(${1:target}).not.toBeFalsy()
endsnippet

snippet notd "expect not to be defined (coffee)" b
expect(${1:target}).not.toBeDefined()
endsnippet

snippet notn "expect not to be null (coffee)" b
expect(${1:target}).not.toBeNull()
endsnippet

snippet notc "expect not to contain (coffee)" b
expect(${1:target}).not.toContain(${2:value})
endsnippet

snippet notv "expect not to be visible (coffee)" b
expect(${1:target}).not.toBeVisible()
endsnippet

snippet noth "expect not to be hidden (coffee)" b
expect(${1:target}).not.toBeHidden()
endsnippet

snippet s "spy on (coffee)" b
spyOn(${1:object}, "${2:method}")$0
endsnippet

snippet sr "spy on and return (coffee)" b
spyOn(${1:object}, "${2:method}").andReturn(${3:arguments})
endsnippet

snippet st "spy on and throw (coffee)" b
spyOn(${1:object}, "${2:method}").andThrow(${3:exception})
endsnippet

snippet sct "spy on and call through (coffee)" b
spyOn(${1:object}, "${2:method}").andCallThrough()
endsnippet

snippet scf "spy on and call fake (coffee)" b
spyOn(${1:object}, "${2:method}").andCallFake(${3:function})
endsnippet

snippet esc "expect was called (coffee)" b
expect(${1:target}).wasCalled()
endsnippet

snippet escw "expect was called with (coffee)" b
expect(${1:target}).wasCalledWith(${2:arguments})
endsnippet

snippet notsc "expect was not called (coffee)" b
expect(${1:target}).wasNotCalled()
endsnippet

snippet noscw "expect was not called with (coffee)" b
expect(${1:target}).wasNotCalledWith(${2:arguments})
endsnippet
./UltiSnips/coffee-react.snippets	[[[1
80
#
# CoffeeScript versions -- adapted from coffee-jasmine
# for some ReactJS matchers.
#
priority -50

extends coffee

priority -49

snippet createClass "React define Class" b
${1:classname}Class = React.createClass
	displayName: "$1"
	render: ->
		$2
$1 = React.createFactory($1)
endsnippet

snippet PropTypes "React define propTypes" b
propTypes: ->
	${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}
endsnippet

snippet propType "React propType (key/value)" b
${1:myVar}: React.PropTypes.${2:type}${3:.isRequired}
$4
endsnippet

snippet setState "React setState" b
@setState
	${1:myvar}: ${2:myvalue}
	$3
endsnippet

snippet getInitialState "React define getInitialState" b
getInitialState: ->
	${1:myvar}: ${2:myvalue}
	$3
endsnippet

snippet getDefaultProps "React define getDefaultProps" b
getDefaultProps: ->
	${1:myvar}: ${2:myvalue}
	$3
endsnippet

snippet componentWillMount "React define componentWillMount" b
componentWillMount: ->
	$1
endsnippet

snippet componentDidMount "React define componentDidMount" b
componentDidMount: ->
	$1
endsnippet

snippet componentWillReceiveProps "React define componentWillReceiveProps" b
componentWillReceiveProps: (nextProps) ->
	$1
endsnippet

snippet shouldComponentUpdate "React define shouldComponentUpdate" b
shouldComponentUpdate: (nextProps, nextState) ->
	$1
endsnippet

snippet componentWillUpdate "React define componentWillUpdate" b
componentWillUpdate: (nextProps, nextState) ->
	$1
endsnippet

snippet componentDidUpdate "React define componentDidUpdate" b
componentDidUpdate: (prevProps, prevState) ->
	$1
endsnippet

snippet componentWillUnmount "React define componentWillUnmount" b
componentWillUnmount: ->
	$1
endsnippet
./UltiSnips/coffee.snippets	[[[1
100
priority -50

snippet fun "Function" b
${1:name} = `!p snip.rv = "(" if t[2] else ""`${2:args}`!p snip.rv = ") " if t[2] else ""`->
	${0:# body...}
endsnippet

snippet bfun "Function (bound)" i
`!p snip.rv = "(" if t[1] else ""`${1:args}`!p snip.rv = ") " if t[1] else ""`=>`!p snip.rv = " " if t[2] and not t[2].startswith("\n") else ""`${2:expr}
endsnippet

snippet if "If" b
if ${1:condition}
	${0:# body...}
endsnippet

snippet ife "If .. Else" b
if ${1:condition}
	${2:# body...}
else
	${3:# body...}
endsnippet

snippet elif "Else if" b
else if ${1:condition}
	${0:# body...}
endsnippet

snippet ifte "Ternary if" b
if ${1:condition} then ${2:value} else ${3:other}
endsnippet

snippet unl "Unless" b
${1:action} unless ${2:condition}
endsnippet

snippet fora "Array Comprehension" b
for ${1:name} in ${2:array}
	${0:# body...}
endsnippet

snippet foro "Object Comprehension" b
for ${1:key}, ${2:value} of ${3:Object}
	${0:# body...}
endsnippet

snippet forr "Range Comprehension (inclusive)" b
for ${1:name} in [${2:start}..${3:finish}]`!p snip.rv = " by " if t[4] else ""`${4:step}
	${0:# body...}
endsnippet

snippet forrex "Range Comprehension (exclusive)" b
for ${1:name} in [${2:start}...${3:finish}]`!p snip.rv = " by " if t[4] else ""`${4:step}
	${0:# body...}
endsnippet

snippet swi "Switch" b
switch ${1:object}
	when ${2:value}
		${3:# body...}
	else
		$0
endsnippet

snippet swit "Switch when .. then" b
switch ${1:object}
	when ${2:condition}`!p snip.rv = " then " if t[3] else ""`${3:value}
	else`!p snip.rv = " " if t[4] and not t[4].startswith("\n") else ""`${4:value}
endsnippet

snippet cla "Class" b
class ${1:ClassName}`!p snip.rv = " extends " if t[2] else ""`${2:Ancestor}

	${3:constructor:`!p snip.rv = " (" if t[4] else ""`${4:args}`!p snip.rv = ")" if t[4] else ""` ->
		${5:# body...}}
	$0
endsnippet

snippet try "Try .. Catch" b
try
	$1
catch ${2:error}
	$3
endsnippet

snippet req "Require" b
${1/^'?(\w+)'?$/\L$1\E/} = require(${1:'${2:sys}'})
endsnippet

snippet # "Interpolated Code" i
#{$1}$0
endsnippet

snippet log "Log" b
console.log ${1:"${2:msg}"}
endsnippet

snippet kv "Key:value for object" b
${1:key}:${2:value}
endsnippet
./UltiSnips/cpp.snippets	[[[1
200
priority -50

extends c

# We want to overwrite everything in parent ft.
priority -49
###########################################################################
#			    Global functions 						  #
###########################################################################

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet ponce "#pragma once include guard"
#pragma once

endsnippet

snippet main
int main(int argc, char *argv[])
{
	${0}
	return 0;
}
endsnippet

snippet forc "general for loop (for)"
for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
	${VISUAL}$0
}
endsnippet

snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/} (${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet nsa "namespace alias"
namespace ${1:alias} = ${2:namespace};
endsnippet

snippet using "using directive/using declaration/type alias"
using ${1:namespace}`!p snip.rv = ' ' if t[1] == 'namespace' else ' = ' if t[1] != '' else ''`${2:name};
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r"))
{
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cla "An entire .h generator" b
#ifndef ${2:`!v substitute(vim_snippets#Filename('$1_H','ClassName'),'.*','\U&\E','')`}
#define $2

class ${1:`!v substitute(substitute(vim_snippets#Filename('$1','ClassName'),'^.','\u&',''), '_\(\w\)', '\u\1', 'g')`}
{
private:
	$3

public:
	$1();
	virtual ~$1();
};

#endif /* $2 */
endsnippet


snippet fnc "Basic c++ doxygen function template" b
/**
* @brief: ${4:brief}
*
* @param: `!p write_docstring_args(t[3],snip)`
*
* @return: `!p snip.rv = t[1]`
*/
${1:ReturnType} ${2:FunctionName}(${3:param})
{
	${0:FunctionBody}
}
endsnippet

snippet boost_test "Boost test module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_CASE(${2:TestCaseName})
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite "Boost test suite module" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

BOOST_AUTO_TEST_SUITE(${2:SuiteName})

BOOST_AUTO_TEST_CASE(${3:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet
snippet boost_test_fixture "Boost test module with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_CASE(${3:SuiteName}, $2)
{
	${0:TestDefinition}
}

endsnippet

snippet boost_suite_fixture "Boost test suite with fixture" b
#define BOOST_TEST_MODULE ${1:TestModuleName}
#include <boost/test/included/unit_test.hpp>

struct ${2:FixtureName} {
	$2() {}
	virtual ~$2() {}
	/* define members here */
};

BOOST_FIXTURE_TEST_SUITE(${3:SuiteName}, $2)

BOOST_AUTO_TEST_CASE(${4:TestCaseName})
{
	${0:TestDefinition}
}

BOOST_AUTO_TEST_SUITE_END()

endsnippet
# vim:ft=snippets:
./UltiSnips/crystal.snippets	[[[1
13
priority -50

snippet "\b(de)?f" "def <name>..." r
def ${1:method_name}${2:(${3:*args})}
	$0
end
endsnippet

snippet "\b(pde)?f" "private def <name>..." r
private def ${1:method_name}${2:(${3:*args})}
	$0
end
endsnippet
./UltiSnips/cs.snippets	[[[1
385
#######################################################################
#                      C# Snippets for UltiSnips                      #
#######################################################################

priority -50

#########################
#  classes and structs  #
#########################

snippet namespace "namespace" b
namespace ${1:MyNamespace}
{
	${VISUAL}$0
}
endsnippet

snippet class "class" w
${1:public} class ${2:`!p snip.rv = snip.basename`}
{
	$0
}
endsnippet

snippet struct "struct" w
struct ${1:`!p snip.rv = snip.basename`}
{
	$0
}
endsnippet

snippet interface "interface" w
interface I${1:`!p snip.rv = snip.basename`}
{
	$0
}
endsnippet

snippet enum "enumeration" b
enum ${1:MyEnum} { ${2:Item} };
endsnippet


############
#  Main()  #
############

snippet sim "static int main" b
static int Main(string[] args)
{
	$0
}
endsnippet

snippet svm "static void main" b
static void Main(string[] args)
{
	$0
}
endsnippet


################
#  properties  #
################

snippet prop "Simple property declaration" b
public ${1:int} ${2:MyProperty} { get; set; }
endsnippet

snippet propfull "Full property declaration" b
private ${1:int} ${2:_myProperty};

public $1 ${3:MyProperty}
{
	get { return $2; }
	set { $2 = value; }
}
endsnippet

snippet propg "Property with a private setter" b
public ${1:int} ${2:MyProperty} { get; private set; }
endsnippet


############
#  blocks  #
############

snippet #if "#if #endif" b
#if ${1:DEBUG}
${VISUAL}$0
#endif
endsnippet

snippet #region "#region #endregion" b
#region ${1:Region}
${VISUAL}$0
#endregion
endsnippet


###########
#  loops  #
###########

snippet for "for loop" b
for (int ${1:i} = 0; $1 < ${2:10}; $1++)
{
	${VISUAL}$0
}
endsnippet

snippet forr "for loop (reverse)" b
for (int ${1:i} = ${2:10}; $1 >= 0; $1--)
{
	${VISUAL}$0
}
endsnippet

snippet foreach "foreach loop" b
foreach (${3:var} ${2:item} in ${1:items})
{
	${VISUAL}$0
}
endsnippet

snippet while "while loop" b
while (${1:true})
{
	${VISUAL}$0
}
endsnippet

snippet do "do loop" b
do
{
	${VISUAL}$0
} while (${1:true});
endsnippet


###############
#  branching  #
###############

snippet if "if statement" b
if ($1)
{
	${VISUAL}$0
}
endsnippet

snippet ife "if else statement" b
if ($1)
{
	${VISUAL}$0
}
else
{
}
endsnippet

snippet elif "else if" b
else if ($1)
{
	$0
}
endsnippet

snippet elseif "else if" b
else if ($1)
{
	$0
}
endsnippet

snippet ifnn "if not null" b
if ($1 != null)
{
	${VISUAL}$0
}
endsnippet

snippet switch "switch statement" b
switch (${1:statement})
{
	case ${2:value}:
		break;

	default:
		$0break;
}
endsnippet

snippet case "case" b
case ${1:value}:
	$2
	break;
endsnippet


##############
#  wrappers  #
##############

snippet using "using statement" b
using (${1:resource})
{
	${VISUAL}$0
}
endsnippet

snippet unchecked "unchecked block" b
unchecked
{
	${VISUAL}$0
}
endsnippet

snippet checked "checked block" b
checked
{
	${VISUAL}$0
}
endsnippet

snippet unsafe "unsafe" b
unsafe
{
	${VISUAL}$0
}
endsnippet


########################
#  exception handling  #
########################

snippet try "try catch block" b
try
{
	${VISUAL}$0
}
catch (${1:Exception} ${2:e})
{
	throw;
}
endsnippet

snippet tryf "try finally block" b
try
{
	${VISUAL}$0
}
finally
{
}
endsnippet

snippet throw "throw"
throw new $1Exception("$2");
endsnippet


##########
#  LINQ  #
##########

snippet from "LINQ syntax" b
var ${1:seq} =
	from ${2:item1} in ${3:items1}
	join ${4:item2} in ${5:items2} on $2.${6:prop1} equals $4.${7:prop2}
	select ${8:$2.prop3}
	where ${9:clause}
endsnippet


############################
#  feedback and debugging  #
############################

snippet da "Debug.Assert" b
Debug.Assert(${1:true});
endsnippet

snippet cw "Console.WriteLine" b
Console.WriteLine("$1");
endsnippet

snippet cr "Console.ReadLine" b
Console.ReadLine();
endsnippet

# as you first type comma-separated parameters on the right, {n} values appear in the format string
snippet cwp "Console.WriteLine with parameters" b
Console.WriteLine("${2:`!p
snip.rv = ' '.join(['{' + str(i) + '}' for i in range(t[1].count(','))])
`}"${1:, something});
endsnippet

snippet mbox "Message box" b
MessageBox.Show("${1:message}");
endsnippet


#############
#  methods  #
#############

snippet equals "Equality for a type" b
public override bool Equals(object obj) => Equals(obj as ${1:TYPE});

public bool Equals($1 other)  // IEquatable<$1>
{
	if (object.ReferenceEquals(other, null))
		return false;
	if (object.ReferenceEquals(this, other))
		return true;
	if (this.GetType() != other.GetType())
		return false;
	$0
	return base.Equals(other);
}

public override int GetHashCode() => base.GetHashCode();

public static bool operator ==($1 x, $1 y) =>
	(object.ReferenceEquals(x, null) && object.ReferenceEquals(y, null))
	|| (!object.ReferenceEquals(x, null) && x.Equals(y));

public static bool operator !=($1 x, $1 y) => !(x == y);

endsnippet

snippet mth "Method" b
${1:public} ${2:void} ${3:MyMethod}(${4})
{
	$0
}
endsnippet

snippet mths "Static method" b
${1:public} static ${2:void} ${3:MyMethod}(${4})
{
	$0
}
endsnippet

###############
# constructor #
###############

snippet ctor "Constructor" b
${1:public} ${2:`!p snip.rv = snip.basename or "untitled"`}(${3})
{
	$0
}
endsnippet

##############
#  comments  #
##############

snippet /// "XML summary comment" b
/// <summary>
/// $0
/// </summary>
endsnippet

snippet <p "XML pramameter comment" w
<param name="${1}">${2}</param>
endsnippet

snippet <ex "XML exception comment" w
<exception cref="${1:System.Exception}">${2}</exception>
endsnippet

snippet <r "XML returns comment" w
<returns>$0</returns>
endsnippet

snippet <c "XML code comment" w
<code>$0</code>
endsnippet
./UltiSnips/css.snippets	[[[1
493
priority -50

snippet p "padding"
padding: ${1:0};$0
endsnippet

snippet m "margin"
margin: ${1:0};$0
endsnippet

snippet bd "border"
border: ${1:0};$0
endsnippet

snippet d "display"
display: ${1:none};$0
endsnippet

snippet bg "background"
background: ${1:none};$0
endsnippet

snippet ff "font-family"
font-family: ${1:"Helvetica Neue", Helvetica, Arial, sans-serif};$0
endsnippet

snippet h "height"
height: ${1:auto};$0
endsnippet

snippet w "width"
width: ${1:auto};$0
endsnippet

snippet pos "position"
position: ${1:relative};$0
endsnippet

snippet tt "text-transform"
text-transform: ${1:none};$0
endsnippet

snippet ! "!important CSS (!)"
!important
endsnippet

snippet tsh "text-shadow: color-hex x y blur (text)"
text-shadow: ${1:${2:offset-x} ${3:offset-y} ${4:blur} ${5:color}};$0
endsnippet

snippet bxsh "box-shadow: color-hex x y blur (text)"
box-shadow: ${1:${2:offset-x} ${3:offset-y} ${4:blur} ${5:spread} ${6:color} ${7:inset}};$0
endsnippet

#
# Colors
#

snippet rgb "color rgb"
rgb(${1:255}, ${2:255}, ${3:255})$0
endsnippet

snippet rgba "color rgba"
rgba(${1:255}, ${2:255}, ${3:255}, ${4:0.5})$0
endsnippet

snippet hsl "color hsl"
hsl(${1:360}, ${2:100}%, ${3:100}%)$0
endsnippet

snippet hsla "color hsla"
hsla(${1:360}, ${2:100}%, ${3:100}%, ${4:0.5})$0
endsnippet

#
# Selectors
#

snippet :fc
:first-child
endsnippet

snippet :lc
:last-child
endsnippet

snippet :nc
:nth-child($0)
endsnippet

snippet :nlc
:nth-last-child($0)
endsnippet

snippet :oc
:only-child
endsnippet

#
# Pseudo-elements
#

snippet :a
:after
endsnippet

snippet :b
:before
endsnippet

snippet ::a
::after
endsnippet

snippet ::b
::before
endsnippet

###########################################################################
#                    Most of these came from TextMate                     #
###########################################################################

snippet background "background-attachment: scroll:fixed (background)"
background-attachment: ${1:scroll/fixed};$0
endsnippet

snippet background "background-color:  color-hex (background)"
background-color: #${1:DDD};$0
endsnippet

snippet background "background-color:  color-name (background)"
background-color: ${1:red};$0
endsnippet

snippet background "background-color:  color-rgb (background)"
background-color: rgb(${1:255},${2:255},${3:255});$0
endsnippet

snippet background "background-color:  transparent (background)"
background-color: transparent;$0
endsnippet

snippet background "background-image:  none (background)"
background-image: none;$0
endsnippet

snippet background "background-image:  url (background)"
background-image: url($1);$0
endsnippet

snippet background "background-position:  position (background)"
background-position: ${1:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0
endsnippet

snippet background "background-repeat:  r:r-x:r-y:n-r (background)"
background-repeat: ${1:repeat/repeat-x/repeat-y/no-repeat};$0
endsnippet

snippet background "background:  color image repeat attachment position (background)"
background:${6: #${1:DDD}} url($2) ${3:repeat/repeat-x/repeat-y/no-repeat} ${4:scroll/fixed} ${5:top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right/x-% y-%/x-pos y-pos};$0
endsnippet

snippet border "border-bottom-color: size style color (border)"
border-bottom-color: #${1:999};$0
endsnippet

snippet border "border-bottom-style: size style color (border)"
border-bottom-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0
endsnippet

snippet border "border-bottom-width: size style color (border)"
border-bottom-width: ${1:1}px ${2:solid} #${3:999};$0
endsnippet

snippet border "border-bottom: size style color (border)"
border-bottom: ${1:1}px ${2:solid} #${3:999};$0
endsnippet

snippet border "border-color: color (border)"
border-color: ${1:999};$0
endsnippet

snippet border "border-left-color: color (border)"
border-right-color: #${1:999};$0
endsnippet

snippet border "border-left-style: style (border)"
border-left-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0
endsnippet

snippet border "border-left-width: size (border)"
border-left-width: ${1:1}px
endsnippet

snippet border "border-left: size style color (border)"
border-left: ${1:1}px ${2:solid} #${3:999};$0
endsnippet

snippet border "border-right-color: color (border)"
border-right-color: #${1:999};$0
endsnippet

snippet border "border-right-style: style (border)"
border-right-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0
endsnippet

snippet border "border-right-width: size (border)"
border-right-width: ${1:1}px
endsnippet

snippet border "border-right: size style color (border)"
border-right: ${1:1}px ${2:solid} #${3:999};$0
endsnippet

snippet border "border-style: style (border)"
border-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0
endsnippet

snippet border "border-top-color: color (border)"
border-top-color: #${1:999};$0
endsnippet

snippet border "border-top-style: style (border)"
border-top-style: ${1:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset};$0
endsnippet

snippet border "border-top-width: size (border)"
border-top-width: ${1:1}px
endsnippet

snippet border "border-top: size style color (border)"
border-top: ${1:1}px ${2:solid} #${3:999};$0
endsnippet

snippet border "border-width: width (border)"
border-width: ${1:1px};$0
endsnippet

snippet border "border:   size style color (border)"
border: ${1:1px} ${2:solid} #${3:999};$0
endsnippet

snippet clear "clear: value (clear)"
clear: ${1:left/right/both/none};$0
endsnippet

snippet color "color:  color-hex (color)"
color: #${1:DDD};$0
endsnippet

snippet color "color:  color-name (color)"
color: ${1:red};$0
endsnippet

snippet color "color:  color-rgb (color)"
color: rgb(${1:255},${2:255},${3:255});$0
endsnippet

snippet cursor "cursor: type (cursor)"
cursor: ${1:default/auto/crosshair/pointer/move/*-resize/text/wait/help};$0
endsnippet

snippet cursor "cursor: url (cursor)"
cursor: url($1);$0
endsnippet

snippet direction "direction: ltr|rtl (direction)"
direction: ${1:ltr|rtl};$0
endsnippet

snippet display "display: block (display)"
display: block;$0
endsnippet

snippet display "display: common-types (display)"
display: ${1:none/inline/block/list-item/run-in/compact/marker};$0
endsnippet

snippet display "display: inline (display)"
display: inline;$0
endsnippet

snippet display "display: table-types (display)"
display: ${1:table/inline-table/table-row-group/table-header-group/table-footer-group/table-row/table-column-group/table-column/table-cell/table-caption};$0
endsnippet

snippet float "float: left:right:none (float)"
float: ${1:left/right/none};$0
endsnippet

snippet font "font-family:   family (font)"
font-family: ${1:Arial, "MS Trebuchet"}, ${2:sans-}serif;$0
endsnippet

snippet font "font-size: size (font)"
font-size: ${1:100%};$0
endsnippet

snippet font "font-style:   normal:italic:oblique (font)"
font-style: ${1:normal/italic/oblique};$0
endsnippet

snippet font "font-variant:   normal:small-caps (font)"
font-variant: ${1:normal/small-caps};$0
endsnippet

snippet font "font-weight: weight (font)"
font-weight: ${1:normal/bold};$0
endsnippet

snippet font "font:   style variant weight size:line-height font -family (font)"
font: ${1:normal/italic/oblique} ${2:normal/small-caps} ${3:normal/bold} ${4:1em/1.5em} ${5:Arial}, ${6:sans-}serif;$0
endsnippet

snippet font "font: size font (font)"
font: ${1:75%} ${2:"Lucida Grande", "Trebuchet MS", Verdana,} ${3:sans-}serif;$0
endsnippet

snippet letter "letter-spacing:   length-em (letter)"
letter-spacing: $1em;$0
endsnippet

snippet letter "letter-spacing:   length-px (letter)"
letter-spacing: $1px;$0
endsnippet

snippet list "list-style-image: url (list)"
list-style-image: url($1);$0
endsnippet

snippet list "list-style-position: pos (list)"
list-style-position: ${1:inside/outside};$0
endsnippet

snippet list "list-style-type: asian (list)"
list-style-type: ${1:cjk-ideographic/hiragana/katakana/hiragana-iroha/katakana-iroha};$0
endsnippet

snippet list "list-style-type: marker(list)"
list-style-type: ${1:none/disc/circle/square};$0
endsnippet

snippet list "list-style-type: numeric (list)"
list-style-type: ${1:decimal/decimal-leading-zero/zero};$0
endsnippet

snippet list "list-style-type: other (list)"
list-style-type: ${1:hebrew/armenian/georgian};$0
endsnippet

snippet list "list-style-type: roman-alpha-greek (list)"
list-style-type: ${1:lower-roman/upper-roman/lower-alpha/upper-alpha/lower-greek/lower-latin/upper-latin};$0
endsnippet

snippet list "list-style: type position image (list)"
list-style: ${1:none/disc/circle/square/decimal/zero} ${2:inside/outside} url($3);$0
endsnippet

snippet margin "margin-bottom: length (margin)"
margin-bottom: ${1:20px};$0
endsnippet

snippet margin "margin-left: length (margin)"
margin-left: ${1:20px};$0
endsnippet

snippet margin "margin-right: length (margin)"
margin-right: ${1:20px};$0
endsnippet

snippet margin "margin-top: length (margin)"
margin-top: ${1:20px};$0
endsnippet

snippet margin "margin:   all (margin)"
margin: ${1:20px};$0
endsnippet

snippet margin "margin: T R B L (margin)"
margin: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0
endsnippet

snippet margin "margin: V H (margin)"
margin: ${1:20px} ${2:0px};$0
endsnippet

snippet marker "marker-offset: auto (marker)"
marker-offset: auto;$0
endsnippet

snippet marker "marker-offset: length (marker)"
marker-offset: ${1:10px};$0
endsnippet

snippet overflow "overflow: type (overflow)"
overflow: ${1:visible/hidden/scroll/auto};$0
endsnippet

snippet padding "padding-bottom: length (margin)"
padding-bottom: ${1:20px};$0
endsnippet

snippet padding "padding-left: length (margin)"
padding-left: ${1:20px};$0
endsnippet

snippet padding "padding-right: length (margin)"
padding-right: ${1:20px};$0
endsnippet

snippet padding "padding-top: length (margin)"
padding-top: ${1:20px};$0
endsnippet

snippet padding "padding:   T R B L (padding)"
padding: ${1:20px} ${2:0px} ${3:40px} ${4:0px};$0
endsnippet

snippet padding "padding:   V H (padding)"
padding: ${1:20px} ${2:0px};$0
endsnippet

snippet padding "padding:   all (padding)"
padding: ${1:20px};$0
endsnippet

snippet position "position: type (position)"
position: ${1:static/relative/absolute/fixed};$0
endsnippet

snippet { "properties { } ( } )"
{
	/* $1 */
	$0

endsnippet

snippet scrollbar "scrollbar"
scrollbar-base-color:       ${1:#CCCCCC};${2:
scrollbar-arrow-color:      ${3:#000000};
scrollbar-track-color:      ${4:#999999};
scrollbar-3dlight-color:    ${5:#EEEEEE};
scrollbar-highlight-color:  ${6:#FFFFFF};
scrollbar-face-color:       ${7:#CCCCCC};
scrollbar-shadow-color:     ${9:#999999};
scrollbar-darkshadow-color: ${8:#666666};}
endsnippet

snippet selection "selection"
$1::-moz-selection,
$1::selection {
	color: ${2:inherit};
	background: ${3:inherit};
}
endsnippet

snippet text "text-align: left:center:right (txt)"
text-align: ${1:left/right/center/justify};$0
endsnippet

snippet text "text-decoration: none:underline:overline:line-through:blink (text)"
text-decoration: ${1:none/underline/overline/line-through/blink};$0
endsnippet

snippet text "text-indent: length (text)"
text-indent: ${1:10}px;$0
endsnippet

snippet text "text-transform: capitalize:upper:lower (text)"
text-transform: ${1:capitalize/uppercase/lowercase};$0
endsnippet

snippet vertical "vertical-align: type (vertical)"
vertical-align: ${1:baseline/sub/super/top/text-top/middle/bottom/text-bottom/length/%};$0
endsnippet

snippet visibility "visibility: type (visibility)"
visibility: ${1:visible/hidden/collapse};$0
endsnippet

snippet white "white-space:  normal:pre:nowrap (white)"
white-space: ${1:normal/pre/nowrap};$0
endsnippet

snippet word "word-spacing:  length (word)"
word-spacing: ${1:10px};$0
endsnippet

snippet z "z-index: index (z)"
z-index: $1;$0
endsnippet

# vim:ft=snippets:
./UltiSnips/cuda.snippets	[[[1
5
priority -50

extends cpp

# vim:ft=snippets:
./UltiSnips/d.snippets	[[[1
584
# Simple shortcuts

priority -50

snippet imp "import (imp)" b
import ${1:std.stdio};
endsnippet

snippet pimp "public import (pimp)" b
public import ${1:/*module*/};
endsnippet

snippet over "override (over)" b
override ${1:/*function*/}
endsnippet

snippet al "alias (al)"
alias ${1:/*orig*/} ${2:/*alias*/};
endsnippet

snippet mixin "mixin (mixin)" b
mixin ${1:/*mixed_in*/} ${2:/*name*/};
endsnippet

snippet new "new (new)"
new $1($2);
endsnippet

snippet scpn "@safe const pure nothrow (scpn)"
@safe const pure nothrow
endsnippet

snippet spn "@safe pure nothrow (spn)"
@safe pure nothrow
endsnippet

snippet cont "continue (cont)"
continue;
endsnippet

snippet dis "@disable (dis)" b
@disable ${1:/*method*/};
endsnippet

snippet pub "public (pub)" b
public:
	${1:/*members*/}
endsnippet

snippet priv "private (priv)" b
private:
	${1:/*members*/}
endsnippet

snippet prot "protected (prot)" b
protected:
	${1:/*members*/}
endsnippet

snippet pack "package (pack)" b
package:
	${1:/*members*/}
endsnippet

snippet ret "return (ret)"
return ${1:/*value to return*/};
endsnippet

snippet auto "auto (auto)" b
auto ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet con "const (con)" b
const ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet siz "size_t (siz)" b
size_t ${1:/*variable*/} = ${2:/*value*/};
endsnippet

snippet sup "super (sup)" b
super(${1:/*args*/});
endsnippet

# Phobos

snippet tup "tuple (tup)"
tuple(${1:/*args*/})
endsnippet

snippet wr "writeln (wr)"
writeln(${1:/*args*/});
endsnippet

snippet to "to (to)"
to!(${1:/*type*/})(${2:/*arg*/})
endsnippet

snippet enf "enforce (enf)" b
enforce(${1:/*condition*/},
	new $2Exception(${3:/*args*/}));
endsnippet

# Branches

snippet if "if .. (if)"
if(${1:/*condition*/})
{
	${VISUAL}$0
}
endsnippet

snippet ife "if .. else (ife)" b
if(${1:/*condition*/})
{
	$2
}
else
{
	${3:/*else*/}
}
endsnippet

snippet el "else (el)" b
else
{
	${VISUAL}$1
}
endsnippet

snippet elif "else if (elif)" b
else if(${1:/*condition*/})
{
	${VISUAL}$0
}
endsnippet

snippet sw "switch (sw)"
switch(${1:/*var*/})
{
	case ${2:/*value*/}:
		$3
		break;
	case ${4:/*value*/}:
		$5
		break;
	${7:/*more cases*/}
	default:
		${6:assert(false);}
}
endsnippet

snippet fsw "final switch (fsw)"
final switch(${1:/*var*/})
{
	case ${2:/*value*/}:
		$3
		break;
	case ${4:/*value*/}:
		$5
		break;
	${7:/*more cases*/}
}
endsnippet

snippet case "case (case)" b
case ${1:/*value*/}:
	$2
	break;
endsnippet

snippet ?: "ternary operator (?:)"
${1:/*condition*/} ? ${2:/*then*/} : ${3:/*else*/}$4
endsnippet

# Loops

snippet do "do while (do)" b
do
{
	${VISUAL}$2
} while(${1:/*condition*/});
endsnippet

snippet wh "while (wh)" b
while(${1:/*condition*/})
{
	${VISUAL}$2
}
endsnippet

snippet for "for (for)" b
for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2})
{
	${VISUAL}$0
}
endsnippet

snippet forever "forever (forever)" b
for(;;)
{
	${VISUAL}$0
}
endsnippet

snippet fore "foreach (fore)"
foreach(${1:/*elem*/}; ${2:/*range*/})
{
	${VISUAL}$3
}
endsnippet

snippet forif "foreach if (forif)" b
foreach(${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/})
{
	${VISUAL}$4
}
endsnippet

# Contracts
snippet in "in contract (in)" b
in
{
	assert(${1:/*condition*/}, "${2:error message}");
	$3
}
body
endsnippet

snippet out "out contract (out)" b
out${1:(result)}
{
	assert(${2:/*condition*/}, "${3:error message}");
	$4
}
body
endsnippet

snippet inv "invariant (inv)" b
invariant()
{
	assert(${1:/*condition*/}, "${2:error message}");
	$3
}
endsnippet

# Functions (generic)

snippet fun "function definition (fun)"
${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow}
{
	${VISUAL}$5
}
endsnippet

snippet void "void function definition (void)"
void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow}
{
	${VISUAL}$4
}
endsnippet

snippet this "ctor (this)" w
this(${1:/*args*/})
{
	${VISUAL}$2
}
endsnippet

snippet get "getter property (get)"
@property ${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:$2_};}
endsnippet

snippet set "setter property (set)"
@property void ${1:/*member_name*/}(${2:/*type*/} rhs) pure nothrow {${3:$1_} = rhs;}
endsnippet

# Functions (concrete)

snippet main "Main" b
void main(string[] args)
{
	${VISUAL}${0: /*code*/}
}
endsnippet

# Mixins

snippet signal "signal (signal)" b
mixin Signal!(${1:/*args*/}) ${2:/*name*/};
endsnippet

# Scope

snippet scope "scope (scope)" b
scope(${1:exit})
{
	${VISUAL}$2
}
endsnippet

# With

snippet with "with (with)"
with($1)
{
	${VISUAL}$2
}
endsnippet

# Exception handling

snippet try "try/catch (try)" b
try
{
	${VISUAL}${1:/*code to try*/}
}
catch($2Exception e)
{
	${3:/*handle exception*/}
}
endsnippet

snippet tryf "try/catch/finally (tryf)" b
try
{
	${VISUAL}${1:/*code to try*/}
}
catch($2Exception e)
{
	${3:/*handle exception*/}
}
finally
{
	${4:/*cleanup*/}
}
endsnippet

snippet catch "catch (catch)" b
catch($1Exception e)
{
	${2:/*handle exception*/}
}
endsnippet

snippet thr "throw (thr)"
throw new $1Exception("$2");
endsnippet


# Type declarations

snippet struct "struct (struct)"
struct ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet union "union (union)"
union ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet class "class (class)"
class ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet inter "interface (inter)"
interface ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet

snippet enum "enum (enum)"
enum ${1:`!p snip.rv = (snip.basename or "name")`}
{
	$2
}
endsnippet


# Exception declarations

snippet exc "exception declaration (exc)" b
/// ${3:/*documentation*/}
class $1Exception : $2Exception
{
	public this(string msg, string file = __FILE__, int line = __LINE__)
	{
		super(msg, file, line);
	}
}
endsnippet


# Conditional compilation

snippet version "version (version)" b
version(${1:/*version name*/})
{
	${VISUAL}$2
}
endsnippet

snippet debug "debug" b
debug
{
	${VISUAL}$1
}
endsnippet


# Templates

snippet temp "template (temp)" b
template ${2:/*name*/}(${1:/*args*/})
{
	$3
}
endsnippet


# Asserts

snippet ass "assert (ass)" b
assert(${1:false}, "${2:TODO}");

endsnippet


# Unittests

snippet unittest "unittest (unittest)" b
unittest
{
	$1
}
endsnippet


# Common member functions

snippet opDis "opDispatch (opDis)" b
${1:/*return type*/} opDispatch(string s)()
{
	$2;
}
endsnippet

snippet op= "opAssign (op=)" b
void opAssign($1 rhs) ${2:@safe pure nothrow}
{
	$2
}
endsnippet

snippet opCmp "opCmp (opCmp)" b
int opCmp($1 rhs) @safe const pure nothrow
{
	$2
}
endsnippet

snippet opApply "opApply (opApply)" b
int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg)
{
	int result = 0;
	${2:/*loop*/}
	{
		result = dg(${3:/*arg/s*/});
		if(result){break;}
	}
	return result;
}
endsnippet

snippet toString "toString (toString)" b
string toString() @safe const pure nothrow
{
	$1
}
endsnippet


# Comments


snippet todo "TODO (todo)"
// TODO: $1
endsnippet


# DDoc

snippet doc "generic ddoc block (doc)" b
/// ${1:description}
///
/// ${2:details}
endsnippet

snippet fdoc "function ddoc block (fdoc)" b
/// ${1:description}
///
/// ${2:Params:  ${3:param} = ${4:param description}
///			 $5}
///
/// ${6:Returns: ${7:return value}}
///
/// ${8:Throws:  $9Exception $10}
endsnippet

snippet Par "Params (Par)"
Params:  ${1:param} = ${2:param description}
///			$3
endsnippet

snippet Ret "Returns (Ret)"
Returns:  ${1:return value/s}
endsnippet

snippet Thr "Throws (Thr)"
Throws:  $1Exception $2
endsnippet

snippet Example "Examples (Example)"
Examples:
/// --------------------
/// ${1:example code}
/// --------------------
endsnippet


# License blocks

snippet gpl "GPL (gpl)" b
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//
// Copyright (C) ${1:Author}, `!v strftime("%Y")`

$2
endsnippet

snippet boost "Boost (boost)" b
//          Copyright ${1:Author} `!v strftime("%Y")`.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

$2
endsnippet


# New module

snippet module "New module (module)" b
//          Copyright ${1:Author} `!v strftime("%Y")`.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

module $2.`!v vim_snippets#Filename('$1', 'name')`;


$3
endsnippet
./UltiSnips/django.snippets	[[[1
360
priority -50

# This files will define django snippets from sublime text djaneiro
# FORMS SNIPPETS

snippet form "Form" b
class ${1:FORMNAME}(forms.Form):

	${2:# TODO: Define form fields here}
endsnippet

snippet modelform "ModelForm" b
class ${1:MODELNAME}Form(forms.ModelForm):

	class Meta:
		model = $1
endsnippet

snippet fbool "BooleanField" b
${1:FIELDNAME} = forms.BooleanField($2)
endsnippet

snippet fchar "CharField" b
${1:FIELDNAME} = forms.CharField($2)
endsnippet

snippet fchoice "ChoiceField" b
${1:FIELDNAME} = forms.ChoiceField($2)
endsnippet

snippet fcombo "ComboField" b
${1:FIELDNAME} = forms.ComboField($2)
endsnippet

snippet fdate "DateField" b
${1:FIELDNAME} = forms.DateField($2)
endsnippet

snippet fdatetime "DateTimeField" b
${1:FIELDNAME} = forms.DateTimeField($2)
endsnippet

snippet fdecimal "DecimalField" b
${1:FIELDNAME} = forms.DecimalField($2)
endsnippet

snippet fmail "EmailField" b
${1:FIELDNAME} = forms.EmailField($2)
endsnippet

snippet ffile "FileField" b
${1:FIELDNAME} = forms.FileField($2)
endsnippet

snippet ffilepath "FilePathField" b
${1:FIELDNAME} = forms.FilePathField($2)
endsnippet

snippet ffloat "FloatField" b
${1:FIELDNAME} = forms.FloatField($2)
endsnippet

snippet fip "IPAddressField" b
${1:FIELDNAME} = forms.IPAddressField($2)
endsnippet

snippet fimg "ImageField" b
${1:FIELDNAME} = forms.ImageField($2)
endsnippet

snippet fint "IntegerField" b
${1:FIELDNAME} = forms.IntegerField($2)
endsnippet

snippet fmochoice "ModelChoiceField" b
${1:FIELDNAME} = forms.ModelChoiceField($2)
endsnippet

snippet fmomuchoice "ModelMultipleChoiceField" b
${1:FIELDNAME} = forms.ModelMultipleChoiceField($2)
endsnippet

snippet fmuval "MultiValueField" b
${1:FIELDNAME} = forms.MultiValueField($2)
endsnippet

snippet fmuchoice "MultipleChoiceField" b
${1:FIELDNAME} = forms.MultipleChoiceField($2)
endsnippet

snippet fnullbool "NullBooleanField" b
${1:FIELDNAME} = forms.NullBooleanField($2)
endsnippet

snippet freg "RegexField" b
${1:FIELDNAME} = forms.RegexField($2)
endsnippet

snippet fslug "SlugField" b
${1:FIELDNAME} = forms.SlugField($2)
endsnippet

snippet fsdatetime "SplitDateTimeField" b
${1:FIELDNAME} = forms.SplitDateTimeField($2)
endsnippet

snippet ftime "TimeField" b
${1:FIELDNAME} = forms.TimeField($2)
endsnippet

snippet ftchoice "TypedChoiceField" b
${1:FIELDNAME} = forms.TypedChoiceField($2)
endsnippet

snippet ftmuchoice "TypedMultipleChoiceField" b
${1:FIELDNAME} = forms.TypedMultipleChoiceField($2)
endsnippet

snippet furl "URLField" b
${1:FIELDNAME} = forms.URLField($2)
endsnippet

# MODELS SNIPPETS

snippet model "Model" b
class ${1:MODELNAME}(models.Model):
	$0
	class Meta:
		verbose_name = "$1"
		verbose_name_plural = "$1s"

	def __str__(self):
		return super($1, self).__str__()

endsnippet

snippet modelfull "Model" b
class ${1:MODELNAME}(models.Model):
	${2:# TODO: Define fields here}

	class Meta:
		verbose_name = "$1"
		verbose_name_plural = "$1s"

	def __str__(self):
		return super($1, self).__str__()

	def save(self):
		return super($1, self).save()

	def get_absolute_url(self):
		return ('')

	${3:# TODO: Define custom methods here}

endsnippet

snippet mauto "AutoField" b
${1:FIELDNAME} = models.AutoField($2)
endsnippet

snippet mbigint "BigIntegerField" b
${1:FIELDNAME} = models.BigIntegerField($2)
endsnippet

snippet mbool "BooleanField" b
${1:FIELDNAME} = models.BooleanField($2)
endsnippet

snippet mchar "CharField" b
${1:FIELDNAME} = models.CharField($2, max_length=${3:50})
endsnippet

snippet mcoseint "CommaSeparatedIntegerField" b
${1:FIELDNAME} = models.CommaSeparatedIntegerField($2)
endsnippet

snippet mdate "DateField" b
${1:FIELDNAME} = models.DateField($2)
endsnippet

snippet mdatetime "DateTimeField" b
${1:FIELDNAME} = models.DateTimeField($2)
endsnippet

snippet mdecimal "DecimalField" b
${1:FIELDNAME} = models.DecimalField(max_digits=${2:10}, decimal_places=${3:2})
endsnippet

snippet memail "EmailField" b
${1:FIELDNAME} = models.EmailField($2)
endsnippet

snippet mfile "FileField" b
${1:FIELDNAME} = models.FileField($2)
endsnippet

snippet mfilepath "FilePathField" b
${1:FIELDNAME} = models.FilePathField($2)
endsnippet

snippet mfloat "FloatField" b
${1:FIELDNAME} = models.FloatField($2)
endsnippet

snippet fk "ForeignKey" b
${1:FIELDNAME} = models.ForeignKey($2)
endsnippet

snippet mip "IPAddressField" b
${1:FIELDNAME} = models.IPAddressField($2)
endsnippet

snippet mimg "ImageField" b
${1:FIELDNAME} = models.ImageField($2)
endsnippet

snippet mint "IntegerField" b
${1:FIELDNAME} = models.IntegerField($2)
endsnippet

snippet m2m "ManyToManyField" b
${1:FIELDNAME} = models.ManyToManyField($2)
endsnippet

snippet mnullbool "NullBooleanField" b
${1:FIELDNAME} = models.NullBooleanField($2)
endsnippet

snippet o2o "OneToOneField" b
${1:FIELDNAME} = models.OneToOneField($2)
endsnippet

snippet mphone "PhoneNumberField" b
${1:FIELDNAME} = models.PhoneNumberField($2)
endsnippet

snippet mposint "PositiveIntegerField" b
${1:FIELDNAME} = models.PositiveIntegerField($2)
endsnippet

snippet mpossmallint "PositiveSmallIntegerField" b
${1:FIELDNAME} = models.PositiveSmallIntegerField($2)
endsnippet

snippet mslug "SlugField" b
${1:FIELDNAME} = models.SlugField($2)
endsnippet

snippet msmallint "SmallIntegerField" b
${1:FIELDNAME} = models.SmallIntegerField($2)
endsnippet

snippet mtext "TextField" b
${1:FIELDNAME} = models.TextField($2)
endsnippet

snippet mtime "TimeField" b
${1:FIELDNAME} = models.TimeField($2)
endsnippet

snippet murl "URLField" b
${1:FIELDNAME} = models.URLField($2)
endsnippet

snippet musstate "USStateField" b
${1:FIELDNAME} = models.USStateField($2)
endsnippet

snippet mxml "XMLField" b
${1:FIELDNAME} = models.XMLField($2)
endsnippet

# VIEWS SNIPPETS

snippet adminview "Model Admin View" b
class $1Admin(admin.ModelAdmin):
	'''
		Admin View for $1
	'''
	list_display = ('$2',)
	list_filter = ('$3',)
	inlines = [
		$4Inline,
	]
	raw_id_fields = ('$5',)
	readonly_fields = ('$6',)
	search_fields = ['$7']
admin.site.register($1, $1Admin)
endsnippet

snippet createview "Generic Create View" b
class ${1:MODEL_NAME}CreateView(CreateView):
	model = $1
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet deleteview "Generic Delete View" b
class ${1:MODEL_NAME}DeleteView(DeleteView):
	model = $1
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet detailview "Generic Detail View" b
class ${1:MODEL_NAME}DetailView(DetailView):
	model = $1
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet listview "Generic List View" b
class ${1:MODEL_NAME}ListView(ListView):
	model = $1
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet stackedinline "Stacked Inline" b
class $1Inline(admin.StackedInline):
	'''
	Stacked Inline View for $1
	'''
	model = ${2:$1}
	min_num = ${3:3}
	max_num = ${4:20}
	extra = ${5:1}
	raw_id_fields = ($6,)
endsnippet

snippet tabularinline "Tabular Inline" b
class $1Inline(admin.TabularInline):
	'''
	Tabular Inline View for $1
	'''
	model = ${2:$1}
	min_num = ${3:3}
	max_num = ${4:20}
	extra = ${5:1}
	raw_id_fields = ($6,)
endsnippet

snippet templateview "Generic Template View" b
class ${1:CLASS_NAME}(TemplateView):
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet updateview "Generic Update View" b
class ${1:MODEL_NAME}UpdateView(UpdateView):
	model = $1
	template_name = "${2:TEMPLATE_NAME}"
endsnippet

snippet dispatch "Dispatch View method" b
def dispatch(self, request, *args, **kwargs):
	return super(${1:CLASS_NAME}, self).dispatch(request, *args, **kwargs)
endsnippet

snippet context "get_context_data view method" b
def get_context_data(self, **kwargs):
	kwargs['extra_context'] = ${1:'New Value'}
	return super(${2:CLASS_NAME}, self).get_context_data(**kwargs)
endsnippet
./UltiSnips/eelixir.snippets	[[[1
43
priority -50

extends html

snippet % "<% %>" w
<% $0 %>
endsnippet

snippet = "<%= %>" w
<%= $0 %>
endsnippet

snippet end "<% end %>" w
<% end %>
endsnippet

snippet for
<%= for ${1:item} <- ${2:$1s} ${3:@conn} do %>
	$0
<% end %>
endsnippet

snippet ft "form_tag" w
<%= form_tag(${1:"${2:/users}"}, method: ${3::post}) %>
	$0
</form>
endsnippet

snippet lin "link" w
<%= link ${1:"${2:Submit}"}, to: ${3:"${4:/users}"}, method: ${5::delete} %>
endsnippet

snippet ff "form_for" w
<%= form_for @changeset, ${1:"${2:/users}"}, fn f -> %>
		$0

	<%= submit "Submit" %>
<% end %>
endsnippet

snippet gt "gettext" w
<%= gettext("${0:${VISUAL}}") %>
endsnippet
./UltiSnips/ejs.snippets	[[[1
10
snippet for "ejs for loop" b
<% for (let ${1:i = 0}; ${2:i<arr.length}; ${3:i++}) { %>
	${0:body}
<% } %>
endsnippet
snippet forE "ejs for Each loop" b
<% ${1:array}.forEach((${2:single var}) => { %>
	${0:body}
<% }) %>
endsnippet
./UltiSnips/elm.snippets	[[[1
9
priority -50

snippet impa "Qualified import"
import ${1:Json.Encode} as ${0:`!p snip.rv = t[1].split(".")[-1]`}
endsnippet

snippet impae "Qualified import with exposing"
import ${1:Json.Encode} as ${2:`!p snip.rv = t[1].split(".")[-1]`} exposing (${0:Value})
endsnippet
./UltiSnips/erlang.snippets	[[[1
24
###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

priority -50

snippet pat "Case:Receive:Try Clause"
${1:pattern}${2: when ${3:guard}} ->
	${4:body}
endsnippet

snippet mod "Module Directive" b
-module(${1:`!p snip.rv = snip.basename or "module"`}).
endsnippet

snippet || "List Comprehension"
[${1:X} || ${2:X} <- ${3:List}${4:, gen}]
endsnippet

snippet gen "Generator Expression"
${1:X} <- ${2:List}${3:, gen}
endsnippet

# vim:ft=snippets:
./UltiSnips/eruby.snippets	[[[1
237
extends html

priority -50

# TextMate added these variables to cope with changes in ERB handling
# in different versions of Rails -- for instance, Rails 3 automatically
# strips whitespace so that it's no longer necessary to use a form like
# <% end -%>, but if you're still maintaining Rails 2 projects, you
# can't omit the minus sign and get the same behavior.
#
# The following regex replace substitutes the function below for the
# TextMate variable references after the snippets are converted:
#
#   /\v\$\{(TM_RAILS_TEMPLATE_([^_]+)_RUBY_([^_\s]+))\}/`!p textmate_var('\1', snip)`/g
#
global !p
def textmate_var(var, snip):
	lookup = dict(
		TM_RAILS_TEMPLATE_START_RUBY_EXPR = snip.opt('g:tm_rails_template_start_ruby_expr', '<%= '),
		TM_RAILS_TEMPLATE_END_RUBY_EXPR = snip.opt('g:tm_rails_template_end_ruby_expr', ' %>'),
		TM_RAILS_TEMPLATE_START_RUBY_INLINE = snip.opt('g:tm_rails_template_start_ruby_inline', '<% '),
		TM_RAILS_TEMPLATE_END_RUBY_INLINE = snip.opt('g:tm_rails_template_end_ruby_inline', ' %>'),
		TM_RAILS_TEMPLATE_END_RUBY_BLOCK = '<% end %>'
	)
	snip.rv = lookup[var]
	return
endglobal


snippet % "<% $0 %>" i
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_INLINE', snip)`$0`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_INLINE', snip)`
endsnippet

snippet = "<%= $0 %>" i
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`$0`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

###########################################################################
#            GENERATED FROM get_tm_snippets.py + REGEX REPLACE            #
###########################################################################

snippet fi "<%= Fixtures.identify(:symbol) %>"
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`Fixtures.identify(:${1:name})`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`$0
endsnippet

snippet ft "form_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_INLINE', snip)`form_tag(${1:action: '${2:update}'}${3:, ${4:${5:class}: '${6:form}'\}}}) do`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
	$0
`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_BLOCK', snip)`
endsnippet

snippet ffs "form_for submit 2" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`${1:f}.submit '${2:Submit}'${3:, disable_with: '${4:$2ing...}'}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f_fields_for (nff)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_INLINE', snip)`f.fields_for :${1:attribute} do |${2:f}|`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_INLINE', snip)`
	$0
`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_BLOCK', snip)`
endsnippet

snippet f. "f.checkbox" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.check_box :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.file_field" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.file_field :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.hidden_field" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.hidden_field :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.label" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.label :${1:attribute}${2:, "${3:${1/[[:alpha:]]+|(_)/(?1: :\u$0)/g}}"}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.password_field" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.password_field :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.radio_button" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.radio_button :${1:attribute}, :${2:tag_value}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.submit" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.submit "${1:Submit}"${2:, disable_with: '${3:$1ing...}'}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.text_area" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.text_area :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet f. "f.text_field" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`f.text_field :${1:attribute}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet ffe "form_for with errors" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`error_messages_for :${1:model}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`

`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`form_for @${2:$1} do |f|`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
	$0
`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_BLOCK', snip)`
endsnippet

snippet ff "form_for" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`form_for @${1:model} do |f|`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
	$0
`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_BLOCK', snip)`
endsnippet

snippet ist "image_submit_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`image_submit_tag("${1:agree.png}"${2:${3:, id: "${4:${1/^(\w+)(\.\w*)?$/$1/}}"}${5:, name: "${6:${1/^(\w+)(\.\w*)?$/$1/}}"}${7:, class: "${8:${1/^(\w+)(\.\w*)?$/$1/}-button}"}${9:, disabled: ${10:false}}})`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet it "image_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`image_tag "$1${2:.png}"${3:${4:, title: "${5:title}"}${6:, class: "${7:class}"}}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet layout "layout"
layout "${1:template_name}"${2:${3:, only: ${4:[:${5:action}, :${6:action}]}}${7:, except: ${8:[:${9:action}, :${10:action}]}}}
endsnippet

snippet jit "javascript_include_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`javascript_include_tag ${1::all}${2:, cache: ${3:true}}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lt "link_to (name, dest)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", ${2:dest}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lia "link_to (action)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", action: "${2:index}"`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet liai "link_to (action, id)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", action: "${2:edit}", id: ${3:@item}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lic "link_to (controller)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", controller: "${2:items}"`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lica "link_to (controller, action)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", controller: "${2:items}", action: "${3:index}"`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet licai "link_to (controller, action, id)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to "${1:link text...}", controller: "${2:items}", action: "${3:edit}", id: ${4:@item}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet linpp "link_to (nested path plural)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to ${1:"${2:link text...}"}, ${3:${10:parent}_${11:child}_path(${12:@}${13:$10})}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet linp "link_to (nested path)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to ${1:"${2:link text...}"}, ${3:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lipp "link_to (path plural)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to ${1:"${2:link text...}"}, ${3:${4:model}s_path}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lip "link_to (path)" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to ${1:"${2:link text...}"}, ${3:${12:model}_path(${13:@}${14:$12})}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet lim "link_to model" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to ${1:model}.${2:name}, ${3:${4:$1}_path(${14:$1})}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet hide "page.hide (*ids)"
page.hide ${1:"${2:id(s)}"}
endsnippet

snippet ins "page.insert_html (position, id, partial)"
page.insert_html :${1:top}, ${2:"${3:id}"}, ${4:partial: "${5:template}"}
endsnippet

snippet rep "page.replace (id, partial)"
page.replace ${1:"${2:id}"}, ${3:partial: "${4:template}"}
endsnippet

snippet reph "page.replace_html (id, partial)"
page.replace_html ${1:"${2:id}"}, ${3:partial: "${4:template}"}
endsnippet

snippet show "page.show (*ids)"
page.show ${1:"${2:id(s)}"}
endsnippet

snippet tog "page.toggle (*ids)"
page.toggle ${1:"${2:id(s)}"}
endsnippet

snippet vis "page.visual_effect (effect, id)"
page.visual_effect :${1:toggle_slide}, ${2:"${3:DOM ID}"}
endsnippet

snippet rp "render (partial) (rp)"
render partial: "${1:item}"
endsnippet

snippet rpc "render (partial,collection) (rpc)"
render partial: "${1:item}", collection: ${2:@$1s}
endsnippet

snippet rpl "render (partial,locals) (rpl)"
render partial: "${1:item}", locals: { ${2:$1}: ${3:@$1}$0 }
endsnippet

snippet rpo "render (partial,object) (rpo)"
render partial: "${1:item}", object: ${2:@$1}
endsnippet

snippet rps "render (partial,status) (rps)"
render partial: "${1:item}", status: ${2:500}
endsnippet

snippet slt "stylesheet_link_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`stylesheet_link_tag ${1::all}${2:, cache: ${3:true}}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet st "submit_tag" w
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`submit_tag "${1:Save changes}"${2:, id: "${3:submit}"}${4:, name: "${5:$3}"}${6:, class: "${7:form_$3}"}${8:, disabled: ${9:false}}${10:, disable_with: "${11:Please wait...}"}`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

snippet else "else (ERB)"
<% else %>
	$0
endsnippet

snippet lf "link_to_function"
`!p textmate_var('TM_RAILS_TEMPLATE_START_RUBY_EXPR', snip)`link_to_function ${1:"${2:Greeting}"}, "${3:alert('Hello world!')}"$4`!p textmate_var('TM_RAILS_TEMPLATE_END_RUBY_EXPR', snip)`
endsnippet

# vim:ft=snippets:
./UltiSnips/gitcommit.snippets	[[[1
130
global !p
def complete(t, opts):
	if t:
		opts = [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts) == 1:
		return opts[0]
	return '(' + '|'.join(opts) + ')'
endglobal

snippet status "Status" bA
status $1`!p snip.rv = complete(t[1], ['build', 'ci', 'test', 'refactor', 'perf', 'improvement', 'docs', 'chore', 'feat', 'fix'])`
endsnippet

snippet fix "fix conventional commit"
fix(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet feat "feat conventional commit"
feat(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet chore "chore conventional commit"
chore(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet docs "docs conventional commit"
docs(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet improvement "improvement conventional commit"
improvement(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet perf "perf conventional commit"
perf(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet refactor "refactor conventional commit"
refactor(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet test "test conventional commit"
test(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet ci "ci conventional commit"
ci(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet build "build conventional commit"
build(${1:scope}): ${2:title}

${0:${VISUAL}}
endsnippet

snippet sign "Signature"
-------------------------------------------------------------------------------
${1:Company Name}

${2:Author Name}

${3:Streetname 21}
${4:City and Area}

${5:Tel: 						+44 (0)987 / 888 8888}
${6:Fax: 						+44 (0)987 / 888 8882}
${7:Mail: 					Email}
${8:Web: 						https://}
-------------------------------------------------------------------------------
$0
endsnippet

snippet t "Todo"
TODO: ${1:What is it} (`date "+%b %d %Y %a (%H:%M:%S)"`, `echo $USER`)
$0
endsnippet

snippet cmt "Commit Structure" bA
${1:Summarize changes in around 50 characters or less}

${2:More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.}

${3:Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequences of this
change? Here's the place to explain them.}

${4:Further paragraphs come after blank lines.

 - Bullet points are okay, too

 - Typically a hyphen or asterisk is used for the bullet, preceded
   by a single space, with blank lines in between, but conventions
   vary here}

${5:Status}

${6:If you use an issue tracker, put references to them at the bottom,
like this.}

${7:Any todos}

${8:Resolves: #123
See also: #456, #789}

${9:Signature}
endsnippet
./UltiSnips/go.snippets	[[[1
115
# Snippets for Go

priority -50

# when to abbriviate and when not?
# b doesn't work here, because it ignores whitespace
# optional local name?
snippet /^import/ "Import declaration" r
import (
	"${1:package}"
)
endsnippet

snippet /^package/ "Package declaration" r
// Package $1 provides ...
package ${1:main}
endsnippet

# Mostly converted from: https://github.com/AlanQuatermain/go-tmbundle
snippet /^cons/ "Constants declaration" r
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet /^con/ "Constant declaration" r
const ${1:name}${2/(.+)/ /}${2:type} = ${0:value}
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

snippet struct "Struct declaration" b
type ${1:Struct} struct {
	${0:${VISUAL}}
}
endsnippet

snippet interface "Interface declaration" b
type ${1:Interface} interface {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case$0
}
endsnippet

# functions
snippet /^main/ "Main function" r
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet /^meth/ "Method" r
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	${0:${VISUAL}}
}
endsnippet

snippet func "Function" b
func ${1:name}(${2:params})${3/(.+)/ /}${3:type} {
	${0:${VISUAL}}
}
endsnippet

snippet funch "HTTP handler" b
func ${1:handler}(${2:w} http.ResponseWriter, ${3:r} *http.Request) {
	${0:${VISUAL}}
}
endsnippet

# types and variables
snippet map "Map type" b
map[${1:keytype}]${2:valtype}
endsnippet

snippet : "Variable declaration :=" b
${1:name} := ${0:value}
endsnippet

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

snippet json "JSON field"
\`json:"${1:displayName}"\`
endsnippet

# vim:ft=snippets:

# error handling
snippet err "Basic error handling" b
if err != nil {
	log.${1:Fatal}(err)
}
endsnippet
./UltiSnips/haskell.snippets	[[[1
13
priority -50

snippet imp "Simple import"
import ${1:${2:Data}.${0:Text}}
endsnippet

snippet imp2 "Selective import" b
import ${1:${2:Data}.${3:Text}} (${4})${0}
endsnippet

snippet impq "Qualified import"
import qualified ${1:${2:Data}.${3:Text}} as ${0:`!p snip.rv = t[1].split(".")[-1]`}
endsnippet
./UltiSnips/help.snippets	[[[1
37
# Snippets for VIM Help Files

priority -50

global !p
def sec_title(snip, t):
	file_start = snip.fn.split('.')[0]
	sec_name = t[1].strip("1234567890. ").lower().replace(' ', '-')
	return ("*%s-%s*" % (file_start, sec_name)).rjust(78-len(t[1]))
endglobal

snippet sec "Section marker" b
==============================================================================
${1:SECTION}`!p snip.rv = sec_title(snip, t)`

$0
endsnippet

snippet ssec "Sub section marker" b
${1:Subsection}`!p snip.rv = sec_title(snip, t)
snip += "-"*len(t[1])`

$0
endsnippet

snippet sssec "Subsub Section marker" b
${1:SubSubsection}:`!p snip.rv = sec_title(snip, t)`

$0
endsnippet

# For vim help, follow the same settings as the official docs.
snippet modeline "Vim help modeline"
 `!v 'vim'`:tw=78:ts=8:ft=help:norl:
endsnippet

# vim:ft=snippets:
./UltiSnips/html.snippets	[[[1
534
priority -50

###########################################################################
#                            TextMate Snippets                            #
###########################################################################

global !p
def x(snip):
	if snip.ft.startswith("x"):
		snip.rv = '/'
	else:
		snip.rv = ""
endglobal

snippet doctype "HTML - 5.0 (doctype)" b
<!DOCTYPE html>

endsnippet

#############
# Shortcuts #
#############
snippet down "Down (down)"
&#x2193;
endsnippet

snippet enter "Enter (enter)"
&#x2305;
endsnippet

snippet escape "Escape (escape)"
&#x238B;
endsnippet

snippet left "Left (left)"
&#x2190;
endsnippet

snippet return "Return (return)"
&#x21A9;
endsnippet

snippet right "Right (right)"
&#x2192;
endsnippet

snippet shift "Shift (shift)"
&#x21E7;
endsnippet

snippet tab "Tab (tab)"
&#x21E5;
endsnippet

snippet up "Up (up)"
&#x2191;
endsnippet

#############
# HTML TAGS #
#############
snippet a "Link" w
<a href="${1:http://www.${2:url.com}}"${3: target="_blank"}>${4:Anchor Text}</a>
endsnippet

snippet abbr "<abbr>" w
<abbr title="$2">$1</abbr>
endsnippet

snippet access "accesskey global attribute"
accesskey="$1"
endsnippet

snippet address "<address>" w
<address>$1</address>
endsnippet

snippet article "<article>"
<article>
	${1:article content}
</article>
endsnippet

snippet aside "<aside>"
<aside>
	${1:aside content}
</aside>
endsnippet

snippet b "<b>" w
<b>$1</b>
endsnippet

snippet base "HTML <base>" w
<base href="$1"${2: target="$3"}`!p x(snip)`>
endsnippet

snippet blockquote "<blockquote>"
<blockquote>$1</blockquote>
endsnippet

snippet body "<body>"
<body>
	${0:${VISUAL}}
</body>
endsnippet

snippet br "<br>" w
<br>$1</br>
endsnippet

snippet button "<button>"
<button>$1</button>
endsnippet

snippet caption "<caption>"
<caption>$1</caption>
endsnippet

snippet cite "<cite>" w
<cite>$1</cite>
endsnippet

snippet class "class global attribute"
class="$1"
endsnippet

snippet code "<code>" w
<code>$1</code>
endsnippet

snippet data "<data>"
<data value="$2">$1</data>
endsnippet

snippet datalist "<datalist>"
<datalist id="$1" name="$2">
	opt$3
</datalist>
endsnippet

snippet dd "<dd>"
<dd>$1</dd>
endsnippet

snippet del "<del>" w
<del cite="$2" datetime="${3:`date '+%Y-%m-%dT%H:%M:%S%:z'`}">$1</del>
endsnippet

snippet dfn "<dfn>" w
<dfn>$1</dfn>
endsnippet

snippet div "<div>" w
<div>
	${0:${VISUAL}}
</div>
endsnippet

snippet div# "<div> with ID & class" w
<div`!p snip.rv=' id="' if t[1] else ""`${1:name}`!p snip.rv = '"' if t[1] else ""``!p snip.rv=' class="' if t[2] else ""`${2:name}`!p snip.rv = '"' if t[2] else ""`>
	${0:${VISUAL}}
</div>
endsnippet

snippet div. "<div> with class" w
<div`!p snip.rv=' class="' if t[1] else ""`${1:name}`!p snip.rv = '"' if t[1] else ""`>
	${0:${VISUAL}}
</div>
endsnippet

snippet dl "<dl>"
<dl>
	${1:Definition list}
</dl>
endsnippet

snippet dt "<dt>"
<dt>$1</dt>
endsnippet

snippet em "<em>" w
<em>$1</em>
endsnippet

snippet fieldset "Fieldset" w
<fieldset id="${1/[\w\d]+|( )/(?1:_:\L$0\E)/g}" ${2:class="${3:}"}>
	<legend>$1</legend>
	${0:${VISUAL}}
</fieldset>
endsnippet

snippet fig "<figure>"
<figure>
$1
<figcaption>$2</figcaption>
</figure>
endsnippet

snippet figcaption "<figcaption>"
<figcaption>$1</figcaption>
endsnippet

snippet footer "<footer>"
<footer>
	${1:footer content}
</footer>
endsnippet

snippet form "HTML <form>" w
<form action="${1:`!p
snip.rv = (snip.basename or 'unnamed') + '_submit'
`}" method="${2:get}" accept-charset="utf-8">
	${0:${VISUAL}}
</form>
endsnippet

snippet h1 "HTML <h1>" w
<h1>${0:${VISUAL}}</h1>
endsnippet

snippet h2 "HTML <h2>" w
<h2>${0:${VISUAL}}</h2>
endsnippet

snippet h3 "HTML <h3>" w
<h3>${0:${VISUAL}}</h3>
endsnippet

snippet h4 "HTML <h4>" w
<h4>${0:${VISUAL}}</h4>
endsnippet

snippet h5 "HTML <h5>" w
<h5>${0:${VISUAL}}</h5>
endsnippet

snippet h6 "HTML <h6>" w
<h6>${0:${VISUAL}}</h6>
endsnippet

snippet head "HTML <head>"
<head>
	<meta charset="utf-8">
	<title>${1:`!p snip.rv = snip.basename or "Page Title"`}</title>
	${0:${VISUAL}}
</head>
endsnippet

snippet header "<header>"
<header>
	${1:header content}
</header>
endsnippet

snippet hr "<hr>"
<hr>
endsnippet

snippet html "HTML basic structure" b
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<title>${1:`!p snip.rv = snip.basename.replace('-', ' ').capitalize()`}</title>
	</head>
	<body>
		${0:body}
	</body>
</html>
endsnippet

snippet htmll "HTML basic structure with the lang attribute" b
<!DOCTYPE html>
<html lang="${1:es}">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>${2:`!p snip.rv = snip.basename.replace('-', ' ').capitalize()`}</title>
	</head>
	<body>
		${0:body}
	</body>
</html>
endsnippet

snippet i "<i>" w
<i>$1</i>
endsnippet

snippet id "id global attribute"
id="$1"
endsnippet

snippet img "<img>"
<img src="$1" alt="$2">
endsnippet

snippet input "Input with Label" w
<label for="${2:${1/[[:alpha:]]+|( )/(?1:_:\L$0)/g}}">$1</label><input type="${3:text/submit/hidden/button}" name="${4:$2}" value="$5"${6: id="${7:$2}"}`!p x(snip)`>
endsnippet

snippet input "HTML <input>" w
<input type="${1:text/submit/hidden/button}" name="${2:some_name}" value="$3"${4: id="${5:$2}"}`!p x(snip)`>
endsnippet

snippet ins "<ins>" w
<ins cite="$2" datetime="${3:`date '+%Y-%m-%dT%H:%M:%S%:z'`}">$1</ins>
endsnippet

snippet kbd "<kbd>" w
<kbd>$1</kbd>
endsnippet

snippet label "<label>"
<label>$1</label>
endsnippet

snippet legend "<legend>"
<legend>$1</legend>
endsnippet

snippet li "list item" w
<li>${0:${VISUAL}}</li>
endsnippet

snippet link "HTML <link>" w
<link rel="${1:stylesheet}" href="${2:/css/master.css}" type="text/css" media="${3:screen}" title="${4:no title}" charset="${5:utf-8}"`!p x(snip)`>
endsnippet

snippet mailto "HTML <a mailto: >" w
<a href="mailto:${1:joe@example.com}?subject=${2:feedback}">${3:email me}</a>
endsnippet

snippet tel "HTML <a tel: >" w
<a href="tel:+${1:XX1234567890}">${2:call me}</a>
endsnippet

snippet main "<main>"
<main>
	${1:main content}
</main>
endsnippet

snippet mark "<mark>"
<mark>$1</mark>
endsnippet

snippet meta "HTML <meta>" w
<meta name="${1:name}" content="${2:content}"`!p x(snip)`>
endsnippet

snippet meter "<meter>"
<meter>$1</meter>
endsnippet

snippet nav "<nav>"
<nav>
	${1:navigation links}
</nav>
endsnippet

snippet noscript "<noscript>"
<noscript>$1</noscript>
endsnippet

snippet ol "<ol>"
<ol>
	<li>$1</li>
</ol>
endsnippet

snippet optgroup "<optgroup>"
<optgroup label="$1">
	opt$2
</optgroup>
endsnippet

snippet output "<output>"
<output for="$1" name="$2">$3</output>
endsnippet

snippet option "Option" w
<option${1: value="${2:option}"}>${3:$2}</option>
endsnippet

snippet p "paragraph" w
<p>${0:${VISUAL}}</p>
endsnippet

snippet picture "<picture>"
<picture>
	${1:image sources}
</picture>
endsnippet

snippet pre "<pre>"
<pre>$1</pre>
endsnippet

snippet progress "<progress>"
<progress>$1</progress>
endsnippet

snippet q "<q>" w
<q>$1</q>
endsnippet

snippet s "<s>" w
<s>$1</s>
endsnippet

snippet samp "<samp>" w
<samp>$1</samp>
endsnippet

snippet script "HTML <script>" w
<script charset="utf-8">
	${0:${VISUAL}}
</script>
endsnippet

snippet scriptsrc "HTML <script src...>" w
<script src="$1" charset="${3:utf-8}"></script>
endsnippet

snippet select "Select Box" w
<select name="${1:some_name}" id="${2:$1}"${3:${4: multiple}${5: size="${6:1}"}}>
	${0:${VISUAL}}
</select>
endsnippet

snippet small "<small>" w
<small>$1</small>
endsnippet

snippet span "<span>" w
<span>${0:${VISUAL}}</span>
endsnippet

snippet span# "<span> with ID & class" w
<span`!p snip.rv=' id="' if t[1] else ""`${1:name}`!p snip.rv = '"' if t[1] else ""``!p snip.rv=' class="' if t[2] else ""`${2:name}`!p snip.rv = '"' if t[2] else ""`>${0:${VISUAL}}</span>
endsnippet

snippet span. "<span> with class" w
<span`!p snip.rv=' class="' if t[1] else ""`${1:name}`!p snip.rv = '"' if t[1] else ""`>${0:${VISUAL}}</span>
endsnippet

snippet strong "<strong>" w
<strong>$1</strong>
endsnippet

snippet style "HTML <style>" w
<style type="text/css" media="screen">
	${0:${VISUAL}}
</style>
endsnippet

snippet sub "<sub>" w
<sub>$1</sub>
endsnippet

snippet sup "<sup>" w
<sup>$1</sup>
endsnippet

snippet table "HTML <table>" w
<table>
	${0:${VISUAL}}
</table>
endsnippet

snippet tbody "<tbody>"
<tbody>$1</tbody>
endsnippet

snippet td "table cell" w
<td>${0:${VISUAL}}</td>
endsnippet

snippet template "<template>"
<template id="$1">
$2
</template>
endsnippet

snippet textarea "HTML <textarea>" w
<textarea name="${1:Name}" rows="${2:8}" cols="${3:40}">$0</textarea>
endsnippet

snippet tfoot "<tfoot>"
<tfoot>$1</tfoot>
endsnippet

snippet th "table header" w
<th>${0:${VISUAL}}</th>
endsnippet

snippet thead "<thead>"
<thead>$1</thead>
endsnippet

snippet time "<time>" w
<time datetime="$2">$1</time>
endsnippet

snippet title "HTML <title>" w
<title>${1:`!p snip.rv = snip.basename or "Page Title"`}</title>
endsnippet

snippet tr "table row" w
<tr>${0:${VISUAL}}</tr>
endsnippet

snippet ul "unordered list" w
<ul>
	${0:${VISUAL}}
</ul>
endsnippet

snippet var "<var>" w
<var>$1</var>
endsnippet

snippet viewport "Responsive viewport meta" w
<meta name="viewport" content="width=device-width, initial-scale=1">
endsnippet

snippet wbr "<wbr>" w
<wbr>$1</wbr>
endsnippet

# vim:ft=snippets:
./UltiSnips/html_minimal.snippets	[[[1
33
# more can be found in snippets/html_minimal.snippets
# these UltiSnips override snippets because nested placeholders are being used

priority -49

snippet id
id="$1"$2
endsnippet

snippet idn
id="$1" name="${2:$1}"
endsnippet

snippet label_and_input
<label for="${2:$1}">$1</label>
<input type="${3:text}" name="${4:$2}"${5: id="${6:$2}"} value="$7" />$8
endsnippet

snippet input
<input type="${1:text}" value="$2" name="$3"${4: id="${5:$3}"}/>$7
endsnippet

snippet submit
<input type="submit" value="$2" $3/>$7
endsnippet

snippet textarea
<textarea name="$2"${3: id="$4"}>$5</textarea>
endsnippet

snippet img
<img src="$1"${2: alt="$3"}/>
endsnippet
./UltiSnips/htmldjango.snippets	[[[1
299
priority -50

extends html

# Generic Tags
snippet % "" bi
{% $1 %}$2
endsnippet

snippet %% "" bi
{% ${1:tag_name} %}
	$2
{% end$1 %}
endsnippet

snippet { "" bi
{{ $1 }}$2
endsnippet

# Template Tags

snippet autoescape "" bi
{% autoescape ${1:off} %}
	$2
{% endautoescape %}
endsnippet

snippet block "" bi
{% block $1 %}
	$2
{% endblock $1 %}
endsnippet

snippet # "" bi
{# ${1:comment} #}
endsnippet

snippet comment "" bi
{% comment %}
	$1
{% endcomment %}
endsnippet

snippet cycle "" bi
{% cycle ${1:val1} ${2:val2} ${3:as $4} %}
endsnippet

snippet debug "" bi
{% debug %}
endsnippet

snippet extends "" bi
{% extends "${1:base.html}" %}
endsnippet

snippet filter "" bi
{% filter $1 %}
	$2
{% endfilter %}
endsnippet

snippet firstof "" bi
{% firstof $1 %}
endsnippet

snippet for "" bi
{% for $1 in $2 %}
	$3
{% endfor %}
endsnippet

snippet empty "" bi
{% empty %}
	$1
endsnippet

snippet if "" bi
{% if $1 %}
	$2
{% endif %}
endsnippet

snippet iif "" bi
{% if $1 %}$2{% endif %}
endsnippet

snippet ielse "" bi
{% else %}$1
endsnippet

snippet else "" bi
{% else %}
	$1
endsnippet

snippet ielif "" bi
{% elif %}$1
endsnippet

snippet elif "" bi
{% elif %}
	$1
endsnippet

snippet ifchanged "" bi
{% ifchanged %}$1{% endifchanged %}
endsnippet

snippet ifequal "" bi
{% ifequal $1 $2 %}
	$3
{% endifequal %}
endsnippet

snippet ifnotequal "" bi
{% ifnotequal $1 $2 %}
	$3
{% endifnotequal %}
endsnippet

snippet include "" bi
{% include "$1" %}
endsnippet

snippet load "" bi
{% load $1 %}
endsnippet

snippet now "" bi
{% now "${1:jS F Y H:i}" %}
endsnippet

snippet regroup "" bi
{% regroup $1 by $2 as $3 %}
endsnippet

snippet spaceless "" bi
{% spaceless %}$1{% endspaceless %}
endsnippet

snippet ssi "" bi
{% ssi $1 %}
endsnippet

snippet trans "" bi
{% trans "${1:string}" %}
endsnippet

snippet url "" bi
{% url $1 as $2 %}
endsnippet

snippet widthratio "" bi
{% widthratio ${1:this_value} ${2:max_value} ${3:100} %}
endsnippet

snippet with "" bi
{% with $1 as $2 %}
	${VISUAL}
{% endwith %}
endsnippet

snippet verbatim "" bi
{% verbatim %}
	${VISUAL}
{% endverbatim %}
endsnippet

snippet super "" bi
{{ block.super }}
endsnippet

snippet staticu "" bi
{{ STATIC_URL }}
endsnippet

snippet static "" bi
{% static "${VISUAL}" %}
endsnippet

snippet mediau "" bi
{{ MEDIA_URL }}
endsnippet

snippet iblock "" bi
{% block ${1:blockname} %}${VISUAL}{% endblock $1 %}
endsnippet

snippet csrf "" bi
{% csrf_token %}
endsnippet

snippet blocktrans "" bi
{% blocktrans %}
    ${VISUAL}
{% endblocktrans %}
endsnippet

snippet lorem "" bi
{% lorem $1 %}
endsnippet

# Template Filters

# Note: Since SnipMate can't determine which template filter you are
# expanding without the "|" character, these do not add the "|"
# character.  These save a few keystrokes still.

# Note: Template tags that take no arguments are not implemented.

snippet add "" bi
add:"$1"
endsnippet

snippet center "" bi
center:"$1"
endsnippet

snippet cut "" bi
cut:"$1"
endsnippet

snippet date "" bi
date:"$1"
endsnippet

snippet default "" bi
default:"$1"
endsnippet

snippet defaultifnone "" bi
default_if_none:"$1"
endsnippet

snippet dictsort "" bi
dictsort:"$1"
endsnippet

snippet dictsortrev "" bi
dictsortreversed:"$1"
endsnippet

snippet divisibleby "" bi
divisibleby:"$1"
endsnippet

snippet floatformat "" bi
floatformat:"$1"
endsnippet

snippet getdigit "" bi
get_digit:"$1"
endsnippet

snippet join "" bi
join:"$1"
endsnippet

snippet lengthis "" bi
length_is:"$1"
endsnippet

snippet pluralize "" bi
pluralize:"$1"
endsnippet

snippet removetags "" bi
removetags:"$1"
endsnippet

snippet slice "" bi
slice:"$1"
endsnippet

snippet stringformat "" bi
stringformat:"$1"
endsnippet

snippet time "" bi
time:"$1"
endsnippet

snippet truncatewords "" bi
truncatewords:$1
endsnippet

snippet truncatewordshtml "" bi
truncatewords_html:$1
endsnippet

snippet urlizetrunc "" bi
urlizetrunc:$1
endsnippet

snippet wordwrap "" bi
wordwrap:$1
endsnippet

# vim:ft=snippets:
./UltiSnips/htmljinja.snippets	[[[1
3
priority -50

extends html, jinja2
./UltiSnips/java.snippets	[[[1
435
priority -50

# Many of the snippets here use a global option called
# "g:ultisnips_java_brace_style" which, if set to "nl" will put a newline
# before '{' braces.
# Setting "g:ultisnips_java_junit" will change how the test method snippet
# looks, it is defaulted to junit4, setting this option to 3 will remove the
# @Test annotation from the method

global !p
def junit(snip):
	if snip.opt("g:ultisnips_java_junit", "") == "3":
		snip += ""
	else:
		snip.rv += "@Test\n\t"

def nl(snip):
	if snip.opt("g:ultisnips_java_brace_style", "") == "nl":
		snip += ""
	else:
		snip.rv += " "
def getArgs(group):
	import re
	word = re.compile('[a-zA-Z0-9><.]+ \w+')
	return [i.split(" ") for i in word.findall(group) ]

def camel(word):
	if not word: return ''
	return word[0].upper() + word[1:]

def mixedCase(word):
	if not word: return ''
	return word[0].lower() + word[1:]

endglobal

snippet sleep "try sleep catch" b
try {
	Thread.sleep(${1:1000});
} catch (InterruptedException e){
	e.printStackTrace();
}
endsnippet

snippet /i|n/ "new primitive or int" br
${1:int} ${2:i} = ${3:1};
$0
endsnippet

snippet /o|v/ "new Object or variable" br
${1:Object} ${2:var} = new $1($3);
endsnippet

snippet f "field" b
${1:private} ${2:String} ${3:`!p snip.rv = t[2].lower()`};
endsnippet

snippet ab "abstract" b
abstract $0
endsnippet

snippet as "assert" b
assert ${1:test}${2/(.+)/(?1: \: ")/}${2:Failure message}${2/(.+)/(?1:")/};
endsnippet

snippet at "assert true" b
assertTrue(${1:actual});
endsnippet

snippet af "assert false" b
assertFalse(${1:actual});
endsnippet

snippet ae "assert equals" b
assertEquals(${1:expected}, ${2:actual});
endsnippet

snippet br "break"
break;

endsnippet

snippet cs "case" b
case $1:
	$2
$0
endsnippet

snippet ca "catch" b
catch (${1:Exception} ${2:e})`!p nl(snip)`{
	$0
}
endsnippet

snippet cle "class extends" b
public class ${1:`!p
snip.rv = snip.basename or "untitled"`} ${2:extends ${3:Parent} }${4:implements ${5:Interface} }{
	$0
}
endsnippet

snippet clc "class with constructor, fields, setter and getters" b
public class `!p
snip.rv = snip.basename or "untitled"` {
`!p
args = getArgs(t[1])
if len(args) == 0: snip.rv = ""
for i in args:
	snip.rv += "\n\tprivate " + i[0] + " " + i[1]+ ";"
if len(args) > 0:
	snip.rv += "\n"`
	public `!p snip.rv = snip.basename or "unknown"`($1) {`!p
args = getArgs(t[1])
for i in args:
	snip.rv += "\n\t\tthis." + i[1] + " = " + i[1] + ";"
if len(args) == 0:
	snip.rv += "\n"`
	}$0
`!p
args = getArgs(t[1])
if len(args) == 0: snip.rv = ""
for i in args:
	snip.rv += "\n\tpublic void set" + camel(i[1]) + "(" + i[0] + " " + i[1] + ") {\n" + "\
	\tthis." + i[1] + " = " + i[1] + ";\n\t}\n"

	snip.rv += "\n\tpublic " + i[0] + " get" + camel(i[1]) + "() {\n\
	\treturn " + i[1] + ";\n\t}\n"
`
}
endsnippet

snippet clc "class with constructor, with field names" b
public class `!p
snip.rv = snip.basename or "untitled"` {
`!p
args = getArgs(t[1])
for i in args:
	snip.rv += "\n\tprivate " + i[0] + " " + i[1]+ ";"
if len(args) > 0:
	snip.rv += "\n"`
	public `!p snip.rv = snip.basename or "unknown"`($1) {`!p
args = getArgs(t[1])
for i in args:
	snip.rv += "\n\t\tthis.%s = %s;" % (i[1], i[1])
if len(args) == 0:
	snip.rv += "\n"`
	}
}
endsnippet

snippet clc "class and constructor" b
public class `!p
snip.rv = snip.basename or "untitled"` {

	public `!p snip.rv = snip.basename or "untitled"`($2) {
		$0
	}
}
endsnippet

snippet cl "class" b
public class ${1:`!p
snip.rv = snip.basename or "untitled"`} {
	$0
}
endsnippet

snippet cos "constant string" b
public static final String ${1:var} = "$2";$0
endsnippet

snippet co "constant" b
public static final ${1:String} ${2:var} = $3;$0
endsnippet

snippet de "default" b
default:
	$0
endsnippet

snippet elif "else if"
else if ($1)`!p nl(snip)`{
	$0${VISUAL}
}
endsnippet

snippet el "else" w
else`!p nl(snip)`{
	$0${VISUAL}
}
endsnippet

snippet fi "final" b
final $0
endsnippet

snippet fore "for (each)" b
for ($1 : $2)`!p nl(snip)`{
	$0
}
endsnippet

snippet fori "for" b
for (int ${1:i} = 0; $1 < ${2:10}; $1++)`!p nl(snip)`{
	$0
}
endsnippet

snippet for "for" b
for ($1; $2; $3)`!p nl(snip)`{
	$0
}
endsnippet

snippet if "if" b
if ($1)`!p nl(snip)`{
	$0${VISUAL}
}
endsnippet

snippet imt "import junit_framework_TestCase;"  b
import junit.framework.TestCase;
$0
endsnippet

snippet im "import"  b
import ${1:java}.${2:util}.$0;
endsnippet

snippet in "interface" b
interface ${1:`!p snip.rv = snip.basename or "untitled"`} ${2:extends ${3:Parent} }{
	$0
}
endsnippet

snippet cc "constructor call or setter body"
this.${1:var} = $1;
endsnippet

snippet list "Collections List" b
List<${1:String}> ${2:list} = new ${3:Array}List<$1>();
endsnippet

snippet map "Collections Map" b
Map<${1:String}, ${2:String}> ${3:map} = new ${4:Hash}Map<$1, $2>();
endsnippet

snippet set "Collections Set" b
Set<${1:String}> ${2:set} = new ${3:Hash}Set<$1>();
endsnippet

snippet /Str?|str/ "String" br
String $0
endsnippet

snippet cn "Constructor" b
public `!p snip.rv = snip.basename or "untitled"`(${1:}) {
	$0
}
endsnippet

snippet cn "constructor, \w fields + assigments" b
	`!p
args = getArgs(t[1])
for i in args:
	snip.rv += "\n\tprivate " + i[0] + " " + i[1]+ ";"
if len(args) > 0:
	snip.rv += "\n"`
public `!p snip.rv = snip.basename or "unknown"`($1) {`!p
args = getArgs(t[1])
for i in args:
	snip.rv += "\n\t\tthis.%s = %s;" % (i[1], i[1])
if len(args) == 0:
	snip.rv += "\n"`
}
endsnippet

snippet j.b "java_beans_" i
java.beans.
endsnippet

snippet j.i "java_io" i
java.io.
endsnippet

snippet j.m "java_math" i
java.math.
endsnippet

snippet j.n "java_net_" i
java.net.
endsnippet

snippet j.u "java_util_"  i
java.util.
endsnippet

snippet main "method (main)" b
public static void main(String[] args)`!p nl(snip)`{
	$0
}
endsnippet

snippet try "try/catch" b
try {
	$1${VISUAL}
} catch(${2:Exception} ${3:e}){
	${4:e.printStackTrace();}
}
endsnippet

snippet mt "method throws" b
${1:private} ${2:void} ${3:method}($4) ${5:throws $6 }{
	$0
}
endsnippet

snippet m  "method" b
${1:private} ${2:void} ${3:method}($4) {
	$0
}
endsnippet

snippet md "Method With javadoc" b
/**
 * ${7:Short Description}`!p
for i in getArgs(t[4]):
	snip.rv += "\n\t * @param " + i[1] + " usage..."`
 *`!p
if "throws" in t[5]:
	snip.rv = "\n\t * @throws " + t[6]
else:
	snip.rv = ""``!p
if not "void" in t[2]:
	snip.rv = "\n\t * @return object"
else:
	snip.rv = ""`
 **/
${1:public} ${2:void} ${3:method}($4) ${5:throws $6 }{
	$0
}
endsnippet

snippet /get(ter)?/ "getter" br
public ${1:String} get${2:Name}() {
	return `!p snip.rv = mixedCase(t[2])`;
}
endsnippet

snippet /set(ter)?/ "setter" br
public void set${1:Name}(${2:String} `!p snip.rv = mixedCase(t[1])`) {
	this.`!p snip.rv = mixedCase(t[1])` = `!p snip.rv = mixedCase(t[1])`;
}
endsnippet

snippet /se?tge?t|ge?tse?t|gs/ "setter and getter" br
public void set${1:Name}(${2:String} `!p snip.rv = mixedCase(t[1])`) {
	this.`!p snip.rv = mixedCase(t[1])` = `!p snip.rv = mixedCase(t[1])`;
}`!p snip.rv += "\n"`
public $2 get$1() {
	return `!p snip.rv = mixedCase(t[1])`;
}
endsnippet

snippet pa "package" b
package $0
endsnippet

snippet p "print" b
System.out.print($1);$0
endsnippet

snippet pl "println"  b
System.out.println($1);$0
endsnippet

snippet pr "private" b
private $0
endsnippet

snippet po "protected" b
protected $0
endsnippet

snippet pu "public" b
public $0
endsnippet

snippet re "return" b
return $0
endsnippet

snippet st "static"
static $0
endsnippet

snippet sw "switch" b
switch ($1)`!p nl(snip)`{
	case $2: $0
}
endsnippet

snippet sy "synchronized"
synchronized $0
endsnippet

snippet tc "test case"
public class ${1:`!p snip.rv = snip.basename or "untitled"`} extends ${2:TestCase}`!p nl(snip)`{
	$0
}
endsnippet

snippet t "test" b
`!p junit(snip)`public void test${1:Name}() {
	$0
}
endsnippet

snippet tt "test throws" b
`!p junit(snip)`public void test${1:Name}() ${2:throws Exception }{
	$0
}
endsnippet

snippet th "throw" b
throw new $0
endsnippet

snippet wh "while" b
while ($1)`!p nl(snip)`{
	$0
}
endsnippet

# vim:ft=snippets:
./UltiSnips/javascript-angular.snippets	[[[1
77
priority -50

snippet iti "it (js, inject)" b
it('${1:description}', inject(function($2) {
	$0
}));
endsnippet

snippet befi "before each (js, inject)" b
beforeEach(inject(function($1) {
	$0
}));
endsnippet

snippet aconf "angular config" i
config(function($1) {
	$0
});
endsnippet

snippet acont "angular controller" i
controller('${1:name}', [$2function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet

snippet aconts "angular controller with scope" i
controller('${1:name}', [${2:'$scope', }function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet

snippet adir "angular directive" i
directive('$1', [$2function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	return {
		restrict: '${3:EA}',
		link: function(scope, element, attrs) {
			$0
		}
	};
}]);
endsnippet

snippet adirs "angular directive with scope" i
directive('$1', [${2:'$scope', }function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	return {
		restrict: '${3:EA}',
		link: function(scope, element, attrs) {
			$0
		}
	};
}]);
endsnippet

snippet afact "angular factory" i
factory('${1:name}', [$2function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet

snippet afacts "angular factory with scope" i
factory('${1:name}', [${2:'$scope', }function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet

snippet aserv "angular service" i
service('${1:name}', [$2function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet

snippet aservs "angular service" i
service('${1:name}', [${2:'$scope', }function(${2/('|")([A-Z_$]+)?\1?((, ?)$)?/$2(?3::$4)/ig}) {
	$0
}]);
endsnippet
./UltiSnips/javascript-ember.snippets	[[[1
101
###################################################################
#                        Ember snippets                           #
###################################################################

priority -50

# Application
snippet eapp "App.Name = Ember.Application.create({});"
import Application from '@ember/application';

export default Application.extend({
	${0://Properties here...}
});
endsnippet

# Models
snippet emod "import DS from 'ember-data';"
import DS from 'ember-data';

export default DS.Model.extend({
	${0://Properties here...}
});
endsnippet

# Controller
snippet econtroller "import Controller from '@ember/controller';"
import Controller from '@ember/controller';

export default Controller.extend({
	${0://Properties here...}
});
endsnippet

# Route
snippet eroute "import Route from '@ember/routing/route';"
import Route from '@ember/routing/route';

export default Route.extend({
	${0://Properties here...}
});
endsnippet

# Component
snippet ecomponent "import Component from '@ember/component';"
import Component from '@ember/component';

export default Component.extend({
	${0://Properties here...}
});
endsnippet

# Object
snippet eobj "import EmberObject from '@ember/object';"
import EmberObject from '@ember/object';

export default EmberObject.extend({
	${0://Properties here...}
});
endsnippet

# Mixin
snippet emix "App.MixinName = Ember.Model.extend({...});"
import Mixin from '@ember/object/mixin';

export default Mixin.create({
	${0://Properties here...}
});
endsnippet

# Ember getter and setter
snippet eget "this.get('property');"
${1:this}.get('${2:property}');
endsnippet

snippet eset "this.set('property', value);"
${1:this}.set('${2:property}', ${3:value});
endsnippet

# Computed properties
snippet cproimport "import { computed } from '@ember/object';"
import { computed } from '@ember/object';
endsnippet

snippet cpro "property_name: computed('...', function() {...}),"
${1:property_name}: computed('${3:argument}', function() {
	${0://body...}
}),
endsnippet

# Observers
snippet prooimport "import { observer } from '@ember/object';"
import { observer } from '@ember/object';
endsnippet

snippet proo "property_name: observer('...', function() {...}),"
${1:property_name}: observer('${3:argument}', function() {
	${0://body...}
}),
endsnippet

# vim:ft=snippets:
./UltiSnips/javascript-jasmine-arrow.snippets	[[[1
48
priority -50

# JavaScript versions -- from the TextMate bundle + some additions
# for jasmine-jquery matchers
#

snippet des "Describe (js)" b
describe('${1:description}', () => {
	$0
});
endsnippet

snippet it "it (js)" b
it('${1:description}', () => {
	$0
});
endsnippet

snippet bef "before each (js)" b
beforeEach(() => {
	$0
});
endsnippet

snippet aft "after each (js)" b
afterEach(() => {
	$0
});
endsnippet

snippet befa "before all (js)" b
beforeAll(() => {
	$0
});
endsnippet

snippet afta "after all (js)" b
afterAll(() => {
	$0
});
endsnippet

snippet ru "runs (js)" b
runs(() => {
	$0
});
endsnippet

./UltiSnips/javascript-jsdoc.snippets	[[[1
51
priority -50

# JSDoc snippets

snippet /* "A JSDoc comment" b
/**
 * ${1:${VISUAL}}$0
 */
endsnippet

snippet @au "@author email (First Last)"
@author ${1:`!v g:snips_author`} [${2:`!v g:snips_author_email`}]
endsnippet

snippet @li "@license Description"
@license ${1:MIT}$0
endsnippet

snippet @ver "@version Semantic version"
@version ${1:0.1.0}$0
endsnippet

snippet @fileo "@fileoverview Description" b
/**
 * @fileoverview ${1:${VISUAL:A description of the file}}$0
 */
endsnippet

snippet @constr "@constructor"
@constructor
endsnippet

snippet @p "@param {Type} varname Description"
@param {${1:Type}} ${2:varname} ${3:Description}
endsnippet

snippet @ret "@return {Type} Description"
@return {${1:Type}} ${2:Description}
endsnippet

snippet @pri "@private"
@private
endsnippet

snippet @over "@override"
@override
endsnippet

snippet @pro "@protected"
@protected
endsnippet
./UltiSnips/javascript-node.snippets	[[[1
65
priority -50

snippet #! "#!/usr/bin/env node" b
#!/usr/bin/env node
endsnippet

snippet vreq "assign a CommonJS-style module to a var"
var ${0:${1/(.+\/)*(\w+)(-|\b|$)(\..+$)?/\u$2/g}} = require('$1');
endsnippet

snippet ex "module.exports"
module.exports = $1;
endsnippet

snippet hcs "http.createServer"
http.createServer($1).listen($2);
endsnippet

snippet ncs "net.createServer"
net.createServer(function(${1:socket}){
	$1.on('data', function(${3:data}){
		$4
	});
	$1.on('end', function(){
		$5
	});
}).listen(${6:8124});
endsnippet

snippet pipe "pipe"
pipe(${1:stream})$2
endsnippet

# Express snippets

snippet eget "express GET"
${1:app}.get('$2', $3);
endsnippet

snippet epost "express POST"
${1:app}.post('$2', $3);
endsnippet

snippet eput "express PUT"
${1:app}.put('$2', $3);
endsnippet

snippet edelete "express DELETE"
${1:app}.delete('$2', $3);
endsnippet

# process snippets

snippet stdout "stdout"
process.stdout
endsnippet

snippet stdin "stdin"
process.stdin
endsnippet

snippet stderr "stderr"
process.stderr
endsnippet

./UltiSnips/javascript.snippets	[[[1
225
priority -50

############
#  COMMON  #
############

# The smart snippets use a global options called
# "g:ultisnips_javascript.{option}" which can control the format
# of trailing semicolon, space before function paren, etc.
#
# e.g.
# let g:ultisnips_javascript = {
#      \ 'keyword-spacing': 'always',
#      \ 'semi': 'never',
#      \ 'space-before-function-paren': 'always',
#      \ }


global !p
from javascript_snippets import (
	semi, space_before_function_paren, keyword_spacing
)
endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet get "Get Elements"
getElement${1/(T)|(C)|.*/(?1:s)(?2:s)/}By${1:T}${1/(T)|(I)|(C).*/(?1:agName)(?2:d)(?3:lassName)/}('$2')
endsnippet

snippet '':f "object method string"
'${1:${2:#thing}:${3:click}}': function`!p snip.rv = space_before_function_paren(snip)`(element) {
	${VISUAL}$0
}${10:,}
endsnippet

snippet :f "Object Method"
${1:method_name}: function`!p snip.rv = space_before_function_paren(snip)`(${3:attribute}) {
	${VISUAL}$0
}${10:,}
endsnippet

snippet :, "Object Value JS"
${1:value_name}: ${0:value},
endsnippet

snippet : "Object key key: 'value'"
${1:key}: ${2:"${3:value}"}${4:, }
endsnippet

snippet proto "Prototype (proto)"
${1:class_name}.prototype.${2:method_name} = function`!p snip.rv = space_before_function_paren(snip)`(${3:first_argument}) {
	${VISUAL}$0
}`!p snip.rv = semi(snip)`

endsnippet

snippet fun "function (named)" b
function ${1:function_name}`!p snip.rv = space_before_function_paren(snip)`(${2:argument}) {
	${VISUAL}$0
}
endsnippet

snippet vf "function (assigned to var)"
${1:var }${2:function_name} = function $2`!p snip.rv = space_before_function_paren(snip)`($3) {
	${VISUAL}$0
}`!p snip.rv = semi(snip)`
endsnippet

# Drop priority so this only triggers when not beginning of line.
priority -51
snippet fun "function (anonymous)" w
function`!p snip.rv = space_before_function_paren(snip)`($1) {
	${VISUAL}$0
}$2
endsnippet
priority -50

snippet anf "function (anonymous)" i
function`!p snip.rv = space_before_function_paren(snip)`($1) {
	${VISUAL}$0
}
endsnippet

snippet iife "Immediately-Invoked Function Expression (iife)"
(function`!p snip.rv = space_before_function_paren(snip)`(${1:window}) {
	${VISUAL}$0
}(${2:$1}))`!p snip.rv = semi(snip)`
endsnippet

snippet ;fe "Minify safe iife"
;(function`!p snip.rv = space_before_function_paren(snip)`(${1}) {
	${VISUAL}$0
}(${2}))
endsnippet

snippet timeout "setTimeout function"
setTimeout(function`!p snip.rv = space_before_function_paren(snip)`() {
	${VISUAL}$0
}${2:.bind(${3:this})}, ${1:10})`!p snip.rv = semi(snip)`
endsnippet

snippet fi "for prop in obj using hasOwnProperty" b
for`!p snip.rv = keyword_spacing(snip)`(${1:prop} in ${2:obj}){
	if`!p snip.rv = keyword_spacing(snip)`($2.hasOwnProperty($1)) {
		${VISUAL}$0
	}
}
endsnippet

snippet if "if (condition) { ... }"
if`!p snip.rv = keyword_spacing(snip)`(${1:true}) {
	${VISUAL}$0
}
endsnippet

snippet ife "if (condition) { ... } else { ... }"
if`!p snip.rv = keyword_spacing(snip)`(${1:true}) {
	${VISUAL}$0
}`!p snip.rv = keyword_spacing(snip)`else`!p snip.rv = keyword_spacing(snip)`{
	${2}
}
endsnippet

snippet switch
switch`!p snip.rv = keyword_spacing(snip)`(${VISUAL}${1:expression}) {
	case '${VISUAL}${3:case}':
		${4}
		break`!p snip.rv = semi(snip)`
	${0}
	default:
		${2}
}
endsnippet

snippet case "case 'xyz': ... break"
case`!p snip.rv = keyword_spacing(snip)`'${VISUAL}${1:case}':
	${VISUAL}$0
	break`!p snip.rv = semi(snip)`
endsnippet

snippet do "do { ... } while (condition)"
do`!p snip.rv = keyword_spacing(snip)`{
	${VISUAL}$0
}`!p snip.rv = keyword_spacing(snip)`while`!p snip.rv = keyword_spacing(snip)`(${1:/* condition */})`!p snip.rv = semi(snip)`
endsnippet

snippet ret "Return statement"
return ${VISUAL}$0`!p snip.rv = semi(snip)`
endsnippet

snippet us
'use strict'`!p snip.rv = semi(snip)`
endsnippet

snippet imp "import"
import ${2} from ${1}
endsnippet

# Debugging
snippet de
debugger`!p snip.rv = semi(snip)`
endsnippet
snippet cl "console.log"
console.log(${0})`!p snip.rv = semi(snip)`
endsnippet
snippet cd "console.debug"
console.debug(${0})`!p snip.rv = semi(snip)`
endsnippet
snippet ce "console.error"
console.error(${0})`!p snip.rv = semi(snip)`
endsnippet
snippet cw "console.warn"
console.warn(${0})`!p snip.rv = semi(snip)`
endsnippet
snippet ci "console.info"
console.info(${0})`!p snip.rv = semi(snip)`
endsnippet
snippet ct "console.trace"
console.trace(${0:label})`!p snip.rv = semi(snip)`
endsnippet
snippet ctime "console.time ... console.timeEnd"
console.time("${1:label}")`!p snip.rv = semi(snip)`
${0:${VISUAL}}
console.timeEnd("$1")`!p snip.rv = semi(snip)`
endsnippet
snippet ctimestamp "console.timeStamp"
console.timeStamp("${1:label}")`!p snip.rv = semi(snip)`
endsnippet
snippet ca "console.assert"
console.assert(${1:expression}, ${0:obj})`!p snip.rv = semi(snip)`
endsnippet
snippet cclear "console.clear"
console.clear()`!p snip.rv = semi(snip)`
endsnippet
snippet cdir "console.dir"
console.dir(${0:obj})`!p snip.rv = semi(snip)`
endsnippet
snippet cdirx "console.dirxml"
console.dirxml(${1:object})`!p snip.rv = semi(snip)`
endsnippet
snippet cgroup "console.group"
console.group("${1:label}")`!p snip.rv = semi(snip)`
${0:${VISUAL}}
console.groupEnd()`!p snip.rv = semi(snip)`
endsnippet
snippet cgroupc "console.groupCollapsed"
console.groupCollapsed("${1:label}")`!p snip.rv = semi(snip)`
${0:${VISUAL}}
console.groupEnd()`!p snip.rv = semi(snip)`
endsnippet
snippet cprof "console.profile"
console.profile("${1:label}")`!p snip.rv = semi(snip)`
${0:${VISUAL}}
console.profileEnd()`!p snip.rv = semi(snip)`
endsnippet
snippet ctable "console.table"
console.table(${1:"${2:value}"})`!p snip.rv = semi(snip)`
endsnippet
snippet clstr "console.log stringified"
console.log(JSON.stringify(${0}, null, 2))`!p snip.rv = semi(snip)`
endsnippet

# vim:ft=snippets:
./UltiSnips/javascript_react.snippets	[[[1
56
global !p
# Capitalize the first letter without affecting the rest of the letters
def capitalize_first(word):
	if(word):
		word = word[0].upper() + word[1:]
	return word
endglobal

# Functional components
snippet rfc "react functional component" b
import React, {useState} from "react"

function ${1:`!p snip.rv = snip.basename`}(${2}){
	return(
		<div>
			${3:<p>Body</p>}
		</div>
		)
}

export default $4`!p snip.rv = snip.basename`
endsnippet
# React Hooks
snippet useS "useState Hook" b
const [${1}, set`!p snip.rv=capitalize_first(t[1])`] = useState(${3:"${4}"})
endsnippet
snippet useE "useEffect Hook" b
useEffect(() => {
	${1:${0}}
		}${2})
endsnippet
snippet useC "useContext Hook" b
const ${1:context} = useContext(${2})
endsnippet
snippet useRe "useReducer Hook" b
const [${3:state}, ${4:dispatch}] = useReducer(${5:reducer}, ${2:initial_value})
endsnippet
snippet useCB "useCallback(fn, inputs)" b
const ${1:callback} = useCallback((${2})) => ${3:{
	${4}
}}, [${5}])
endsnippet
snippet useM "useMemo(fn, inputs)" b
const ${1:memorized} = useMemo(() => ${2:{
	${3}
}}, [${4}])
endsnippet
snippet useR "useRef(defaultValue)" b
const ${1:ref} = useRef(${2:null})
endsnippet
snippet ir "import React"
import React from "react"
endsnippet
snippet irc "import React and Component"
import React, { Component } from "react"
endsnippet
./UltiSnips/jinja2.snippets	[[[1
209
priority -50

# http://jinja.pocoo.org/

# jinja2 is a full featured template engine for Python. It has full
# unicode support, an optional integrated sandboxed execution
# environment, widely used and BSD licensed.

# possible extends:
#extends html


snippet block "block" b
{% block ${1:name} %}
		$2
{% endblock $1 %}
endsnippet


snippet {{ "variable" b
{{ $1 }}
endsnippet


snippet {# "comment" b
{# $1 #}
endsnippet


snippet # "comment" b
{# $1 #}
endsnippet


snippet raw "escaped block" b
{% raw %}
		$1
{% endraw %}
endsnippet


snippet extends "extends" b
{% extends "${1:template}" %}
endsnippet


snippet include "include" b
{% include "${1:template}" %}
endsnippet


snippet import "import" b
{% import "${1:template}" %}
endsnippet


snippet from "from/import/as" b
{% from "${1:template}" import ${2:name}${3: as ${4:$2}} %}
endsnippet


snippet filter "filter" b
{% filter ${1:filter} %}
	$2
{% endfilter %}
endsnippet


# Being able to quickly remove the whole 'else' block seems faster to me than
# choosing between 'for' and 'for/else' snippets from the menu.
# snippet for "for" b
# {% for ${1:item} in ${2:sequence} %}
#     $3${4:
# {% else %}
#     $5}
# {% endfor %}
# endsnippet


snippet for "for" b
{% for ${1:item} in ${2:sequence} %}
	$3
{% endfor %}
endsnippet


snippet for "for/else" b
{% for ${1:item} in ${2:sequence} %}
	$3
{% else %}
	$4
{% endfor %}
endsnippet


snippet if "if" b
{% if ${1:expr} %}
	$2
{% endif %}
endsnippet


snippet if "if/else" b
{% if ${1:expr} %}
	$2
{% else %}
	$3
{% endif %}
endsnippet


snippet if "if/elif/else" b
{% if ${1:expr} %}
	$2
{% elif %}
	$3
{% else %}
	$4
{% endif %}
endsnippet


snippet macro "macro" b
{% macro ${1:name}(${2:args}) %}
	$3
{% endmacro %}
endsnippet


snippet call "call" b
{% call ${1:name}(${2:args}) %}
	$3
{% endcall %}
endsnippet


snippet set "set" b
{% set ${1:name} = ${2:'value'} %}
endsnippet


snippet trans "translation" b
{% trans %}
	$1
{% endtrans %}
endsnippet


snippet with "with" b
{% with %}
	$1
{% endwith %}
endsnippet

snippet autoescape "autoescape" b
{% autoescape ${1:true} %}
	$2
{% endautoescape %}
endsnippet

# Filters
# @todo: expand only when snippet is preceeded by a |

snippet batch "batch items" w
batch(linecount=$1, fill_with=${2:None})
endsnippet


snippet dictsort "sort and yield (key, value) pairs" w
dictsort(case_sensitive=${1:False}, by=${2:'key'})
endsnippet


snippet round "round number" w
round(precision=${1:0}, method=${2:'common|ceil|floor'})
endsnippet


snippet urlize "convert plain-text url to <a/>" w
urlize(trim_url_limit=${1:None}, nofollow=${2:False})
endsnippet


snippet wordwrap "wordwrap" w
wordwrap(width=${1:79}, break_long_words=${2:True})
endsnippet


snippet truncate "truncate" w
truncate(lenght=${1:79}, killwords=${2:False}, end=${3:'...''})
endsnippet


snippet sum "sum of sequence of numbers + start" w
sum(attribute=${1:None}, start=${2:0})
endsnippet


snippet sort "sort an iterable" w
sort(reverse=${1:False}, case_sensitive=${2:False}, attribute=${3:None})
endsnippet


snippet indent "indent" w
indent(width=${1:4}, indentfirst=${2:False})
endsnippet


# vim:ft=snippets:
./UltiSnips/json.snippets	[[[1
51
priority -50

snippet s "String" b
"${1:key}": "${0:value}",
endsnippet

snippet n "Number" b
"${1:key}": ${0:value},
endsnippet

snippet a "Array" b
[
	${VISUAL}$0
],
endsnippet

snippet na "Named array" b
"${1:key}": [
	${VISUAL}$0
],
endsnippet

snippet o "Object" b
{
	${VISUAL}$0
},
endsnippet

snippet no "Named object" b
"${1:key}": {
	${VISUAL}$0
},
endsnippet

snippet null "Null" b
"${0:key}": null,
endsnippet


global !p
def compB(t, opts):
	if t:
		opts = [m[len(t):] for m in opts if m.startswith(t)]
	if len(opts) == 1:
		return opts[0]
	return "(" + '|'.join(opts) + ')'
endglobal

snippet b "Bool" b
"${1:key}": $2`!p snip.rv=compB(t[2], ['true', 'false'])`,
endsnippet
./UltiSnips/julia.snippets	[[[1
43
# Documentation
snippet docf "function documentation" b
#' @description
#'
#' ${1:function description}
#'
#' ${2:@param ${3:name}::${4:Type} ${5:Description}}
#'
#' ${6:@returns ${7:name}::${8:Type} ${9:Description}}
#'
#' @examples
#'
#' ${10: function call examples}
endsnippet

snippet doct "type definition" b
#' @description
#'
#' ${1:type description}
#'
#' ${2:@field ${3:name}::${4:Type} ${5:Description}}
#'
#' @examples
#'
#' ${10: constructor examples}
endsnippet

snippet par "function parameter documentation" b
#' @param ${1:name}::${2:Type} ${0:Description}
endsnippet

snippet fld "type field documentation" b
#' @field ${1:name}::${2:Type} ${0:Description}
endsnippet

# Debugging
snippet deb "Debugger breakpoint" b
Main.@bp
endsnippet

snippet inf "Infiltrator breakpoint" b
Main.@infiltrate
endsnippet
./UltiSnips/ledger.snippets	[[[1
7
priority -50

snippet t "Transaction" b
${1:`!v strftime("%Y")`}-${2:`!v strftime("%m")`}-${3:`!v strftime("%d")`} ${4:*} ${5:Payee}
	${6:Expenses}  		\$${7:0.00}
	${8:Assets:Checking}$0
endsnippet
./UltiSnips/lhaskell.snippets	[[[1
3
priority -50

extends haskell
./UltiSnips/lua.snippets	[[[1
116
priority -50

#################################
# Snippets for the Lua language #
#################################
snippet #! "#!/usr/bin/env lua" b
#!/usr/bin/env lua
$0
endsnippet

snippet assert "Assertion" b
assert(${1:condition}`!p
if t[2]:
	snip.rv = ", "
else:
	snip.rv = ""
`${2:msg})
endsnippet

snippet !fun(ction)?! "New function" br
function ${1:new_function}(${2:args})
	$0
end
endsnippet

snippet forp "pair for loop" b
for ${1:name},${2:val} in pairs(${3:table_name}) do
	$0
end
endsnippet

snippet fori "ipair for foop" b
for ${1:idx},${2:val} in ipairs(${3:table_name}) do
	$0
end
endsnippet

snippet for "numeric for loop" b
for ${1:i}=${2:first},${3:last}${4/^..*/(?0:,:)/}${4:step} do
	$0
end
endsnippet

snippet do "do block"
do
	$0
end
endsnippet

snippet repeat "repeat loop" b
repeat
	$1
until $0
endsnippet

snippet while "while loop" b
while $1 do
	$0
end
endsnippet

snippet if "if statement" b
if $1 then
	$0
end
endsnippet

snippet ife "if/else statement" b
if $1 then
	$2
else
	$0
end
endsnippet

snippet eif "if/elseif statement" b
if $1 then
	$2
elseif $3 then
	$0
end
endsnippet

snippet eife "if/elseif/else statement" b
if $1 then
	$2
elseif $3 then
	$4
else
	$0
end
endsnippet

snippet pcall "pcall statement" b
local ok, err = pcall(${1:your_function})
if not ok then
	handler(${2:ok, err})
${3:else
	success(${4:ok, err})
}end
endsnippet

snippet local "local x = 1"
local ${1:x} = ${0:1}
endsnippet

snippet use "Use" b
use { '$1' }
endsnippet

snippet req "Require" b
require('$1')
endsnippet


# vim:ft=snippets:
./UltiSnips/mako.snippets	[[[1
92
priority -50

#################
# From snipmate #
#################
snippet def "definition" b
<%def name="${1:name}">
	${2:}
</%def>
endsnippet

snippet call "call" b
<%call expr="${1:name}">
	${2:}
</%call>
endsnippet

snippet doc "doc" b
<%doc>
	${1:}
</%doc>
endsnippet

snippet text "text" b
<%text>
	${1:}
</%text>
endsnippet

snippet for "for" b
% for ${1:i} in ${2:iter}:
	${3:}
% endfor
endsnippet

snippet if "if " b
% if ${1:condition}:
	${2:}
% endif
endsnippet

snippet if "if/else" b
% if ${1:condition}:
	${2:}
% else:
	${3:}
% endif
endsnippet

snippet try "try" b
% try:
	${1:}
% except${2:}:
	${3:pass}
% endtry
endsnippet

snippet wh "wh" b
% while ${1:}:
	${2:}
% endwhile
endsnippet

snippet $ "$" i
${${1:}}
endsnippet

snippet <% "<%" b
<% ${1:} %>
endsnippet

snippet <!% "<!%" b
<!% ${1:} %>
endsnippet

snippet inherit "inherit" b
<%inherit file="${1:filename}" />
endsnippet

snippet include "include" b
<%include file="${1:filename}" />
endsnippet

snippet namespace "namespace" b
<%namespace file="${1:name}" />
endsnippet

snippet page "page" b
<%page args="${1:}" />
endsnippet

# vim:ft=snippets:
./UltiSnips/markdown.snippets	[[[1
148
priority -50

global !p
# A overkill(dirty) table with automatic alignment feature
def create_table(snip):
	# retrieving single line from current string and treat it like tabstops count
	placeholders_string = snip.buffer[snip.line].strip()
	rows_amount = int(placeholders_string[0])
	columns_amount = int(placeholders_string[1])

	prefix_str = "from vimsnippets import display_width;"

	# erase current line
	snip.buffer[snip.line] = ""

	# create anonymous snippet with expected content and number of tabstops
	anon_snippet_title = "| "
	anon_snippet_delimiter = "|"
	for col in range(1, columns_amount+1):
		sync_rows = [x*columns_amount+col for x in range(rows_amount+1)]
		sync_str = ",".join(["t[{0}]".format(x) for x in sync_rows])
		max_width_str = "max(list(map(display_width, [" + sync_str + "])))"
		cur_width_str = "display_width(t[" + str(col) + "])"
		rv_val = "(" + max_width_str + "-" + cur_width_str + ")*' '"
		anon_snippet_title += "${" + str(col)  + ":head" + str(col)\
			+ "}`!p " + prefix_str + "snip.rv=" + rv_val + "` | "
		anon_snippet_delimiter += ":`!p " + prefix_str + "snip.rv = "\
			+ max_width_str + "*'-'" + "`-|"

	anon_snippet_title += "\n"

	anon_snippet_delimiter += "\n"
	anon_snippet_body = ""
	for row in range(1, rows_amount+1):
		body_row = "| "
		for col in range(1, columns_amount+1):
			sync_rows = [x*columns_amount+col for x in range(rows_amount+1)]
			sync_str = ",".join(["t[{0}]".format(x) for x in sync_rows])
			max_width_str = "max(list(map(display_width, [" + sync_str + "])))"
			cur_width_str = "display_width(t[" + str(row*columns_amount+col) + "])"
			rv_val = "(" + max_width_str + "-" + cur_width_str + ")*' '"
			placeholder = "R{0}C{1}".format(row, col)
			body_row += "${" + str(row*columns_amount+col)  + ":" + placeholder\
				+ "}`!p " + prefix_str + "snip.rv=" + rv_val + "` | "

		body_row += "\n"
		anon_snippet_body += body_row

	anon_snippet_table = anon_snippet_title + anon_snippet_delimiter + anon_snippet_body

	# expand anonymous snippet
	snip.expand_anon(anon_snippet_table)
endglobal

###########################
# Sections and Paragraphs #
###########################
snippet sec "Section" b
# ${1:Section Name} #
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name} ##
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name} ###
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name} ####
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name} #####
$0
endsnippet

###################
# Text formatting #
###################

snippet * "italics"
*${1:${VISUAL}}*$0
endsnippet

snippet ** "bold"
**${1:${VISUAL}}**$0
endsnippet

snippet *** "bold italics"
***${1:${VISUAL}}***$0
endsnippet

snippet /* "Comment"
<!-- ${1:${VISUAL}} -->$0
endsnippet

################
# Common stuff #
################
snippet link "Link to something"
[${1:${VISUAL:Text}}](${3:https://${2:www.url.com}})$0
endsnippet

snippet img "Image"
![${1:pic alt}](${2:path}${3/.+/ "/}${3:opt title}${3/.+/"/})$0
endsnippet

snippet ilc "Inline Code" i
\`${1:${VISUAL}}\`$0
endsnippet

snippet cbl "Codeblock" b
\`\`\`$1
${2:${VISUAL}}
\`\`\`
$0
endsnippet

snippet refl "Reference Link"
[${1:${VISUAL:Text}}][${2:id}]$0

[$2]:${4:https://${3:www.url.com}} "${5:$4}"
endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

snippet detail "Disclosure"
<details${3: open=""}>
  ${1:<summary>${2}</summary>}$0
</details>
endsnippet

post_jump "create_table(snip)"
snippet "tb([1-9][1-9])" "Fancy table" br
`!p snip.rv = match.group(1)`
endsnippet

# vim:ft=snippets:
./UltiSnips/matlab.snippets	[[[1
24
priority -50

snippet switch "switch ... otherwise"
switch ${1:n}
	case ${2:0}
		${3}${4:
	otherwise
		${5}}
end
endsnippet

snippet clc "class with constructor" b
classdef ${1:`!p
snip.rv = snip.basename or "class_name"`} 
	properties
		${2}
	end
	methods
		function obj = $1(${3})
			${4}
		end${0}
	end
end
endsnippet
./UltiSnips/objc.snippets	[[[1
272
priority -50

###########################################################################
#                            TextMate Snippets                            #
###########################################################################

snippet imp "#import (imp)" b
#import "${1:`!p snip.rv = re.sub(r'\..*$', '.h', fn)`}"
endsnippet

snippet Imp "#import <> (Imp)"
#import <${1:Cocoa/Cocoa.h}>
endsnippet

snippet cl "020 Class (objc)"
@interface ${1:`!p
if len(fn):
		snip.rv = re.sub(r'\..*$', '', fn)
else:
		snip.rv = "object"
`} : ${2:NSObject}
{
}
@end

@implementation $1
- (id)init
{
	if((self = [super init]))
	{$0
	}
	return self;
}
@end
endsnippet

snippet array "NSArray (array)"
NSMutableArray *${1:array} = [NSMutableArray array];
endsnippet

snippet dict "NSDictionary (dict)"
NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];
endsnippet

snippet forarray "for NSArray loop (forarray)"
unsigned int	${1:object}Count = [${2:array} count];

for(unsigned int index = 0; index < $1Count; index += 1)
{
	${3:id}	$1 = [$2 objectAtIndex:index];
	$0
}
endsnippet

snippet objacc "Object Accessors (objacc)"
- (${1:id})${2:thing}
{
	return $2;
}

- (void)set${2/./\u$0/}:($1)aValue
{
	$0${1/( \*)?$/(?1:$1: )/}old${2/./\u$0/} = $2;
	$2 = [aValue retain];
	[old${2/./\u$0/} release];
}
endsnippet

snippet sel "@selector"
@selector(${1:method}:)
endsnippet

snippet cdacc "CoreData Accessors Implementation"
- (${1:id})${2:attribute}
{
	[self willAccessValueForKey:@"$2"];
	$1 value = [self primitiveValueForKey:@"$2"];
	[self didAccessValueForKey:@"$2"];
	return value;
}

- (void)set${2/./\u$0/}:($1)aValue
{
	[self willChangeValueForKey:@"$2"];
	[self setPrimitiveValue:aValue forKey:@"$2"];
	[self didChangeValueForKey:@"$2"];
}
endsnippet

snippet delegate "Delegate Responds to Selector"
if([${1:[self delegate]} respondsToSelector:@selector(${2:selfDidSomething:})])
	[$1 ${3:${2/((^\s*([A-Za-z0-9_]*:)\s*)|(:\s*$)|(:\s*))/(?2:$2self :\:<>)(?4::)(?5: :)/g}}];

endsnippet

snippet thread "Detach New NSThread"
[NSThread detachNewThreadSelector:@selector(${1:method}:) toTarget:${2:aTarget} withObject:${3:anArgument}]
endsnippet

snippet ibo "IBOutlet (ibo)"
IBOutlet ${1:NSSomeClass} *${2:${1/^[A-Z](?:[A-Z]+|[a-z]+)([A-Z]\w*)/\l$1/}};
endsnippet

snippet I "Initialize Implementation (I)"
+ (void)initialize
{
	[[NSUserDefaults standardUserDefaults] registerDefaults:[NSDictionary dictionaryWithObjectsAndKeys:
		$0@"value", @"key",
		nil]];
}
endsnippet

snippet bind "Key:value binding (bind)"
bind:@"${1:binding}" toObject:${2:observableController} withKeyPath:@"${3:keyPath}" options:${4:nil}
endsnippet

snippet arracc "LoD array (arracc)"
- (void)addObjectTo${1:Things}:(${2:id})anObject
{
	[${3:${1/./\l$0/}} addObject:anObject];
}

- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i
{
	[$3 insertObject:anObject atIndex:i];
}

- ($2)objectIn$1AtIndex:(unsigned int)i
{
	return [$3 objectAtIndex:i];
}

- (unsigned int)indexOfObjectIn$1:($2)anObject
{
	return [$3 indexOfObject:anObject];
}

- (void)removeObjectFrom$1AtIndex:(unsigned int)i
{
	[$3 removeObjectAtIndex:i];
}

- (unsigned int)countOf$1
{
	return [$3 count];
}

- (NSArray *${1/./\l$0/}
{
	return $3;
}

- (void)set$1:(NSArray *)new$1
{
	[$3 setArray:new$1];
}
endsnippet

snippet arracc "LoD array interface (arracc)"
- (void)addObjectTo${1:Things}:(${2:id})anObject;
- (void)insertObject:($2)anObject in$1AtIndex:(unsigned int)i;
- ($2)objectIn$1AtIndex:(unsigned int)i;
- (unsigned int)indexOfObjectIn$1:($2)anObject;
- (void)removeObjectFrom$1AtIndex:(unsigned int)i;
- (unsigned int)countOf$1;
- (NSArray *)${1/./\l$0/};
- (void)set$1:(NSArray *)new$1;
endsnippet

snippet focus "Lock Focus"
[self lockFocus];
$0
[self unlockFocus];
endsnippet

snippet pool "NSAutoreleasePool (pool)"
NSAutoreleasePool *pool = [NSAutoreleasePool new];
$0
[pool drain];
endsnippet

snippet log "NSLog (log) 2"
NSLog(@"$1"${1/[^%]*(%)?.*/(?1:, :\);)/}$2${1/[^%]*(%)?.*/(?1:\);)/}
endsnippet

snippet alert "NSRunAlertPanel (alert)"
int choice = NSRunAlertPanel(@"${1:Something important!}", @"${2:Something important just happend, and now I need to ask you, do you want to continue?}", @"${3:Continue}", @"${4:Cancel}", nil);
if(choice == NSAlertDefaultReturn) // "$3"
{
	$0;
}
else if(choice == NSAlertAlternateReturn) // "$4"
{
		$0
}
endsnippet

snippet format "NSString stringWithFormat (format)"
[NSString stringWithFormat:@"$1", $2]$0
endsnippet

snippet objacc "Object Accessors Interface (objacc)"
- (${1:id})${2:thing};
- (void)set${2/./\u$0/}:($1)aValue;
endsnippet

snippet prop "Property"
@property (${1/^(e)$|.*/(?1:r)/}${1:r}${1/^(?:(r)|(e)|(c)|(a))$|.*/(?1:etain)(?2:adonly)(?3:opy)(?4:ssign)/}) ${2:NSSomeClass}$ *${3:${2/^[A-Z](?:[A-Z]+|[a-z]+)([A-Z]\w*)/\l$1/}};
endsnippet

snippet getprefs "Read from defaults (getprefs)"
[[NSUserDefaults standardUserDefaults] objectForKey:${1:key}];
endsnippet

snippet obs "Register for Notification"
[[NSNotificationCenter defaultCenter] addObserver:${1:self} selector:@selector(${3:${2/^([A-Z]{2})?(.+?)(Notification)?$/\l$2/}}:) name:${2:NSWindowDidBecomeMainNotification} object:${4:nil}];
endsnippet

snippet responds "Responds to Selector"
if ([${1:self} respondsToSelector:@selector(${2:someSelector:})])
{
		[$1 ${3:${2/((:\s*$)|(:\s*))/:<>(?3: )/g}}];
}
endsnippet

snippet gsave "Save and Restore Graphics Context (gsave)"
[NSGraphicsContext saveGraphicsState];
$0
[NSGraphicsContext restoreGraphicsState];

endsnippet

snippet acc "Scalar Accessors (acc)"
- (${1:unsigned int})${2:thing}
{
	return ${3:$2};
}

- (void)set${2/./\u$0/}:(${1:unsigned int})new${2/./\u$0/}
{
	$3 = new${2/./\u$0/};
}
endsnippet

snippet acc "Scalar Accessors Interface (acc)"
- (${1:unsigned int})${2:thing};
- (void)set${2/./\u$0/}:($1)new${2/./\u$0/};
endsnippet

snippet stracc "String Accessors (stracc)"
- (NSString *)${1:thing}
{
	return ${2:$1};
}

- (void)set${1/.*/\u$0/}:(NSString *)/})${3:a${1/.*/\u$0/}}
{
	$3 = [$3 copy];
	[$2 release];
	$2 = $3;
}
endsnippet

snippet syn "Synthesize"
@synthesize ${1:property};
endsnippet

snippet setprefs "Write to defaults (setprefs)"
[[NSUserDefaults standardUserDefaults] setObject:${1:object} forKey:${2:key}];
endsnippet

# vim:ft=snippets:
./UltiSnips/ocaml.snippets	[[[1
174
priority -50

snippet rs "raise" b
raise (${1:Not_found})
endsnippet

snippet open "open"
let open ${1:module} in
${2:e}
endsnippet

snippet try "try"
try ${1:e}
with ${2:Not_found} -> ${3:()}
endsnippet

snippet ref "ref"
let ${1:name} = ref ${2:val} in
${3:e}
endsnippet

snippet matchl "pattern match on a list"
match ${1:list} with
| [] -> ${2:()}
| x::xs -> ${3:()}
endsnippet

snippet matcho "pattern match on an option type"
match ${1:x} with
| Some(${2:y}) -> ${3:()}
| None -> ${4:()}
endsnippet

snippet fun "anonymous function"
(fun ${1:x} -> ${2:x})
endsnippet

snippet cc "commment"
(* ${1:comment} *)
endsnippet

snippet let "let .. in binding"
let ${1:x} = ${2:v} in
${3:e}
endsnippet

snippet lr "let rec"
let rec ${1:f} =
	${2:expr}
endsnippet

snippet if "if"
if ${1:(* condition *)} then
	${2:(* A *)}
else
	${3:(* B *)}
endsnippet

snippet If "If"
if ${1:(* condition *)} then
	${2:(* A *)}
endsnippet

snippet while "while"
while ${1:(* condition *)} do
	${2:(* A *)}
done
endsnippet

snippet for "for"
for ${1:i} = ${2:1} to ${3:10} do
	${4:(* BODY *)}
done
endsnippet

snippet match "match"
match ${1:(* e1 *)} with
| ${2:p} -> ${3:e2}
endsnippet

snippet Match "match"
match ${1:(* e1 *)} with
| ${2:p} -> ${3:e2}
endsnippet

snippet class "class"
class ${1:name} = object
	${2:methods}
end
endsnippet

snippet obj "obj"
object
	${2:methods}
end
endsnippet

snippet Obj "object"
object (self)
	${2:methods}
end
endsnippet

snippet {{ "object functional update"
{< ${1:x} = ${2:y} >}
endsnippet

snippet beg "beg"
begin
	${1:block}
end
endsnippet

snippet ml "module instantiantion with functor"
module ${1:Mod} = ${2:Functor}(${3:Arg})
endsnippet

snippet mod "module - no signature"
module ${1:(* Name *)} = struct
	${2:(* BODY *)}
end
endsnippet

snippet Mod "module with signature"
module ${1:(* Name *)} : ${2:(* SIG *)} = struct
	${3:(* BODY *)}
end
endsnippet

snippet sig "anonymous signature"
sig
	${2:(* BODY *)}
end
endsnippet

snippet sigf "functor signature or anonymous functor"
functor (${1:Arg} : ${2:ARG}) -> ${3:(* BODY *)}
endsnippet

snippet func "define functor - no signature"
module ${1:M} (${2:Arg} : ${3:ARG}) = struct
	${4:(* BODY *)}
end
endsnippet

snippet Func "define functor - with signature"
module ${1:M} (${2:Arg} : ${3:ARG}) : ${4:SIG} = struct
	${5:(* BODY *)}
end
endsnippet

snippet mot "Declare module signature"
module type ${1:(* Name *)} = sig
	${2:(* BODY *)}
end
endsnippet

snippet module "Module with anonymous signature"
module ${1:(* Name *)} : sig
	${2:(* SIGNATURE *)}
end = struct
	${3:(* BODY *)}
end
endsnippet

snippet oo "odoc"
(** ${1:odoc} *)
endsnippet

snippet qt "inline qtest"
(*$T ${1:name}
	${2:test}
*)
endsnippet
./UltiSnips/octave.snippets	[[[1
2
extends matlab

./UltiSnips/pandoc.snippets	[[[1
12
extends markdown

# overwrite if necessary
priority -49

snippet title "Title Header" b
% ${1:`!v vim_snippets#Filename('$1', 'title')`}
% ${2:`!v g:snips_author`}
% ${3:`!v strftime("%d %B %Y")`}

$0
endsnippet
./UltiSnips/perl.snippets	[[[1
139
priority -50

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet ife "Conditional if..else (ife)"
if ($1) {
	${2:# body...}
}
else {
	${3:# else...}
}

endsnippet

snippet ifee "Conditional if..elsif..else (ifee)"
if ($1) {
	${2:# body...}
}
elsif ($3) {
	${4:# elsif...}
}
else {
	${5:# else...}
}

endsnippet

snippet xunless "Conditional one-line (unless)"
${1:expression} unless ${2:condition};

endsnippet

snippet xif "Conditional one-line (xif)"
${1:expression} if ${2:condition};

endsnippet

snippet sub "Function (sub)"
sub ${1:function_name} {
	${2:# body...}
}

endsnippet

snippet xfore "Loop one-line (xforeach)"
${1:expression} foreach @${2:array};

endsnippet

snippet xwhile "Loop one-line (xwhile)"
${1:expression} while ${2:condition};

endsnippet

snippet test "Test"
#!/usr/bin/env perl -w

use strict;
use Test::More tests => ${1:1};
use ${2:ModuleName};

ok(${3:assertion});

endsnippet

snippet class "class"
package ${1:ClassName};

${2:use parent qw(${3:ParentClass});}${2/.+/\n\n/}sub new {
	my $class = shift;
	$class = ref $class if ref $class;
	my $self = bless {}, $class;
	$self;
}

1;

endsnippet

snippet eval "eval"
local $@;
eval {
	${1:# do something risky...}
};
if (my $${2:exception} = $@) {
	${3:# handle failure...}
}

endsnippet

snippet for "for"
for (my $${1:var} = 0; $$1 < ${2:expression}; $$1++) {
	${3:# body...}
}

endsnippet

snippet fore "foreach"
foreach ${1:my $${2:x}} (@${3:array}) {
	${4:# body...}
}

endsnippet

snippet if "if"
if ($1) {
	${2:# body...}
}

endsnippet

snippet slurp "slurp"
my $${1:var} = do { local $/ = undef; open my $fh, '<', ${2:$file}; <$fh> };

endsnippet

snippet unless "unless"
unless ($1) {
	${2:# body...}
}

endsnippet

snippet while "while"
while ($1) {
	${2:# body...}
}

endsnippet

snippet until "until"
until ($1) {
	${2:# body...}
}

endsnippet

# vim:ft=snippets:
./UltiSnips/php-laravel.snippets	[[[1
270
#resource controller
snippet l_rsc "Laravel resource controller" b
/*!
 * \class       $1
 *
 * \author      ${3:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

class ${1:`!v expand('%:t:r')`} extends ${2:BaseController} {
    function __construct() {
    }
    
    public function index() {
    }
    
    public function create() {
    }
    
    public function store() {
    }
    
    public function show($id) {
    }
    
    public function edit($id) {
    }
    
    public function update($id) {
    }
    
    public function destroy($id) {
    }
}
endsnippet

#service service provider
snippet l_ssp "Laravel service provider for service" b
<?php

/*!
 * \namespace   $1
 * \class       $2
 *
 * \author      ${3:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${1:Services};

use Illuminate\Support\ServiceProvider;

class ${2:`!v expand('%:t:r')`} extends ServiceProvider {
    
    public function register() {
        $this->app->bind('$4Service', function ($app) {
            return new $5(
                $app->make('Repositories\\$6Interface')
            );
        });
    }
}
endsnippet

#repository service provider
snippet l_rsp "Laravel service provider for repository" b
<?php

/*!
 * \namespace   $2
 * \class       $3
 *
 * \author      ${4:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${2:Repositories\\${1:}};

use Entities\\$1;
use $2\\$1Repository;
use Illuminate\Support\ServiceProvider;

class ${3:`!v expand('%:t:r')`} extends ServiceProvider {
    /*!
     * \var     defer
     * \brief   Defer service
     */
    protected $defer = ${5:true};

    public function register() {
        $this->app->bind('$2\\$1Interface', function($app) {
            return new $1Repository(new $1());
        });
    }

    /*!
     * \brief   If $defer == true need this fn
     */ 
    public function provides() {
        return ['$2\\$1Interface'];
    }
}
endsnippet

#model
snippet l_md "Laravel simple model" b
<?php

/*!
 * \namespace   $1
 * \class       $2
 *
 * \author      ${3:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${1:Entities};

class ${2:`!v expand('%:t:r')`} extends \Eloquent {
    protected $table   = '${4:`!p snip.rv = t[2].lower()`}';

    public $timestamps = ${5:false};

    protected $hidden  = [$6];

    protected $guarded = [${7:'id'}];
}
endsnippet

#abstract repository
snippet l_ar "Laravel abstract Repository" b
<?php

/*!
 * \namespace   $1
 * \class       $2
 * \implements  $3
 *
 * \author      ${4:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${1:Repositories};

use Illuminate\Database\Eloquent\Model;

abstract class ${2:`!v expand('%:t:r')`} implements ${3:BaseRepositoryInterface} {
    protected $model;

    /*!
     * \fn      __construct
     *
     * \brief   Take the model
     */

    public function __construct(Model $model) {
        $this->model = $model;
    }

    /*!
     * \fn      all
     *
     * \return  Illuminate\Database\Eloquent\Collection
     */
    public function all($columns = ['*']) {
        return $this->model->all()->toArray();
    }

    /*!
     * \fn      create
     *
     * \return  Illuminate\Database\Eloquent\Model
     */
    public function create(array $attributes) {
        return $this->model->create($attributes);
    }

    /*!
     * \fn      destroy
     *
     * \return  int
     */
    public function destroy($ids) {
        return $this->model->destroy($ids);
    }

    /*!
     * \fn      find
     *
     * \return  mixed
     */
    public function find($id, $columns = ['*']) {
        return $this->model->find($id, $columns);
    }
}
endsnippet

#repository
snippet l_r "Laravel Repository" b
<?php

/*!
 * \namespace   $1
 * \class       $3
 * \implements  $4
 *
 * \author      ${5:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${1:Repositories\\$2};

class ${3:`!v expand('%:t:r')`} extends \\$6 implements ${4:$3RepositoryInterface} {
    $7
}
endsnippet

#service
snippet l_s "Laravel Service" b
<?php

/*!
 * \namespace   $1
 * \class       $2
 *
 * \author      ${6:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace Services\\$1;

use ${3:Repositories\\${4:Interface}};

class ${2:`!v expand('%:t:r')`} {
    protected $${5:repo};
    
    /*!
     * \fn      __construct
     */
    public function __construct($4 $repo) {
        $this->$5 = $repo;
    }
}
endsnippet

#facade
snippet l_f "Laravel Facade" b
<?php

/*!
 * \namespace   $1
 * \class       $2
 *
 * \author      ${5:`!v g:snips_author`}
 * \date        `!v strftime('%d-%m-%y')`
 */

namespace ${1:Services};

use \Illuminate\Support\Facades\Facade;

class ${2:`!v expand('%:t:r')`} extends Facade {
    /*!
     * \fn          getFacadeAccessor
     *
     * \return      string
     */
    protected static function getFacadeAccessor() { return '${4:$3Service}'; }
}
endsnippet
./UltiSnips/php-phpspec.snippets	[[[1
222
# Snippets for phpspec, to use add the following to your .vimrc
# `autocmd BufRead,BufNewFile,BufEnter *Spec.php UltiSnipsAddFiletypes php-phpspec`

priority -50

snippet spec "class XYZSpec extends ObjectBehaviour"
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

/**
 * @author `!v g:snips_author`
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends ObjectBehavior
{
	function it_$1()
	{
		${0:${VISUAL}}
	}
}
endsnippet

snippet it "function it_does_something() { ... }"
function it_$1()
{
	${0:${VISUAL}}
}
endsnippet

snippet let "function let() { ... }"
function let()
{
	${0:${VISUAL}}
}
endsnippet

snippet letgo "function letgo() { ... }"
function letgo()
{
	${0:${VISUAL}}
}
endsnippet

# Object construction
snippet cw "$this->beConstructedWith($arg)"
$this->beConstructedWith($1);
endsnippet

snippet ct "$this->beConstructedThrough($methodName, [$arg])"
$this->beConstructedThrough(${1:'methodName'}, [${2:'$arg'}]);
endsnippet

# Identity and comparison matchers
snippet sreturn "$this->XYZ()->shouldReturn('value')"
$this->${1:method}()->shouldReturn(${2:'value'});
endsnippet

snippet snreturn "$this->XYZ()->shouldNotReturn('value')"
$this->${1:method}()->shouldNotReturn(${2:'value'});
endsnippet

snippet sbe "$this->XYZ()->shouldBe('value')"
$this->${1:method}()->shouldBe(${2:'value'});
endsnippet

snippet snbe "$this->XYZ()->shouldNotBe('value')"
$this->${1:method}()->shouldNotBe(${2:'value'});
endsnippet

snippet sequal "$this->XYZ()->shouldEqual('value')"
$this->${1:method}()->shouldEqual(${2:'value'});
endsnippet

snippet snequal "$this->XYZ()->shouldNotEqual('value')"
$this->${1:method}()->shouldNotEqual(${2:'value'});
endsnippet

snippet sbequalto "$this->XYZ()->shouldBeEqualTo('value')"
$this->${1:method}()->shouldBeEqualTo(${2:'value'});
endsnippet

snippet snbequalto "$this->XYZ()->shouldNotBeEqualTo('value')"
$this->${1:method}()->shouldNotBeEqualTo(${2:'value'});
endsnippet

snippet sblike "$this->XYZ()->shouldBeLike('value')"
$this->${1:method}()->shouldBeLike(${2:'value'});
endsnippet

snippet snblike "$this->XYZ()->shouldNotBeLike('value')"
$this->${1:method}()->shouldNotBeLike(${2:'value'});
endsnippet

# Throw matcher
snippet sthrowm "$this->shouldThrow('\Exception')->duringXYZ($arg)"
$this->shouldThrow(${1:'\Exception'})->during${2:Method}(${3:'$arg'});
endsnippet

snippet sthrowi "$this->shouldThrow('\Exception')->duringInstantiation()"
$this->shouldThrow(${1:'\Exception'})->duringInstantiation();
endsnippet

# Type matchers
snippet stype "$this->shouldHaveType('Type')"
$this->shouldHaveType($1);
endsnippet

snippet sntype "$this->shouldNotHaveType('Type')"
$this->shouldNotHaveType($1);
endsnippet

snippet srinstance "$this->shouldReturnAnInstanceOf('Type')"
$this->shouldReturnAnInstanceOf($1);
endsnippet

snippet snrinstance "$this->shouldNotReturnAnInstanceOf('Type')"
$this->shouldNotReturnAnInstanceOf($1);
endsnippet

snippet sbinstance "$this->shouldBeAnInstanceOf('Type')"
$this->shouldBeAnInstanceOf($1);
endsnippet

snippet snbinstance "$this->shouldNotBeAnInstanceOf('Type')"
$this->shouldNotBeAnInstanceOf($1);
endsnippet

snippet simplement "$this->shouldImplement('Type')"
$this->shouldImplement($1);
endsnippet

snippet snimplement "$this->shouldNotImplement('Type')"
$this->shouldNotImplement($1);
endsnippet

# Object state matchers
snippet sbstate "$this->shouldBeXYZ()"
$this->shouldBe$1();
endsnippet

snippet snbstate "$this->shouldNotBeXYZ()"
$this->shouldNotBe$1();
endsnippet

# Count matchers
snippet scount "$this->XYZ()->shouldHaveCount(7)"
$this->${1:method}()->shouldHaveCount(${2:7});
endsnippet

snippet sncount "$this->XYZ()->shouldNotHaveCount(7)"
$this->${1:method}()->shouldNotHaveCount(${2:7});
endsnippet

# Scalar type matchers
snippet sbscalar "$this->XYZ()->shouldBeString|Array|Bool()"
$this->${1:method}()->shouldBe${2:String|Array|Bool}();
endsnippet

snippet snbscalar "$this->XYZ()->shouldNotBeString|Array|Bool()"
$this->${1:method}()->shouldNotBe${2:String|Array|Bool}();
endsnippet

# Contain matcher
snippet scontain "$this->XYZ()->shouldContain('value')"
$this->${1:method}()->shouldContain(${2:'value'});
endsnippet

snippet sncontain "$this->XYZ()->shouldNotContain('value')"
$this->${1:method}()->shouldNotContain(${2:'value'});
endsnippet

# Array matchers
snippet skey "$this->XYZ()->shouldHaveKey('key')"
$this->${1:method}()->shouldHaveKey(${2:'key'});
endsnippet

snippet snkey "$this->XYZ()->shouldNotHaveKey('key')"
$this->${1:method}()->shouldNotHaveKey(${2:'key'});
endsnippet

snippet skeyvalue "$this->XYZ()->shouldHaveKeyWithValue('key', 'value')"
$this->${1:method}()->shouldHaveKeyWithValue(${2:'key'}, ${3:'value'});
endsnippet

snippet snkeyvalue "$this->XYZ()->shouldNotHaveKeyWithValue('key', 'value')"
$this->${1:method}()->shouldNotHaveKeyWithValue(${2:'key'}, ${3:'value'});
endsnippet

# String matchers
snippet sstart "$this->XYZ()->shouldStartWith('string')"
$this->${1:method}()->shouldStartWith(${2:'string'});
endsnippet

snippet snstart "$this->XYZ()->shouldNotStartWith('string')"
$this->${1:method}()->shouldNotStartWith(${2:'string'});
endsnippet

snippet send "$this->XYZ()->shouldEndWith('string')"
$this->${1:method}()->shouldEndWith(${2:'string'});
endsnippet

snippet snend "$this->XYZ()->shouldNotEndWith('string')"
$this->${1:method}()->shouldNotEndWith(${2:'string'});
endsnippet

snippet smatch "$this->XYZ()->shouldMatch('/wizard/i')"
$this->${1:method}()->shouldMatch(${2:'/wizard/i'});
endsnippet

snippet snmatch "$this->XYZ()->shouldNotMatch('/wizard/i')"
$this->${1:method}()->shouldNotMatch(${2:'/wizard/i'});
endsnippet
./UltiSnips/php-symfony2.snippets	[[[1
360
# sugguestion? report bugs?
# go to https://github.com/chrisyue/vim-snippets/issues

priority -50

snippet classn "Basic class with namespace snippet" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

/**
 * ${1:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
`$2
{
    public function __construct(${3:$options})
    {
        ${4:// code}
    }$0
}
endsnippet

snippet contr "Symfony2 controller" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;

/**
 * ${1:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends Controller
{
}
endsnippet

snippet sfa "Symfony 2 Controller action"
/**
* @Route("/${1:route_name}", name="$1")
* @Template()
*/
public function $1Action($2)
{
	$3
	return ${4:[];}$0
}
endsnippet

snippet act "Symfony2 action" b
/**
 * @Route("$3", name="$4")
 * @Method({${5:"POST"}})
 * @Template()
 */
public function $1Action($2)
{
	$6
}
endsnippet

snippet actt "Symfony2 action and template" b
/**
 * @Route("$3", name="$4")
 * @Method({${5:"GET"}})
 * @Template()
 */
public function $1Action($2)
{
	$6
	return [];
}`!p
relpath = os.path.relpath(path)`
endsnippet

snippet comm "Symfony2 command" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * ${3:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends ContainerAwareCommand
{
	protected function configure()
	{
		$this->setName('$1')
			->setDescription('$2')
			->setDefinition([
				new InputArgument('', InputArgument::REQUIRED, ''),
				new InputOption('', null, InputOption::VALUE_NONE, ''),
			]);
	}

	protected function execute(InputInterface $input, OutputInterface $output)
	{
	}
}
endsnippet

snippet subs "Symfony2 subscriber" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;

/**
 * ${1:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` implements EventSubscriberInterface
{
	public function __construct()
	{
	}

	/**
	 * {@inheritDoc}
	 */
	public static function getSubscribedEvents()
	{
		return [];
	}
}
endsnippet

snippet transf "Symfony2 form data transformer" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Symfony\Component\Form\DataTransformerInterface;
use Symfony\Component\Form\Exception\TransformationFailedException;

/**
 * ${3:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` implements DataTransformerInterface
{
	/**
	 * {@inheritDoc}
	 */
	public function transform($1)
	{
	}

	/**
	 * {@inheritDoc}
	 */
	public function reverseTransform($2)
	{
	}
}
endsnippet

snippet ent "Symfony2 doctrine entity" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Doctrine\ORM\Mapping as ORM;

/**
 * ${3:@author `!v g:snips_author`}
 *
 * @ORM\Entity()
 * @ORM\Table(name="`!p
tmp = re.match(r'.*(?=\.)', fn).group()
tmp = re.sub(r'\B([A-Z])', r'_\1', tmp)
snip.rv = tmp.lower()
`")
 */
`!p
m = re.search(r'Abstract', path)
if m:
	snip.rv = 'abstract '
`class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
`
{
	/**
	 * @ORM\Column(type="integer")
	 * @ORM\GeneratedValue
	 * @ORM\Id
	 */
	private $id;
}
endsnippet

snippet form "Symfony2 form type" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Symfony\Component\Form\AbstractType;
use Symfony\Component\Form\FormBuilderInterface;
use Symfony\Component\OptionsResolver\OptionsResolverInterface;

/**
 * ${2:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends AbstractType
{
	/**
	 * {@inheritDoc}
	 */
	public function buildForm(FormBuilderInterface $builder, array $options)
	{
	}

	/**
	 * {@inheritDoc}
	 */
	public function setDefaultOptions(OptionsResolverInterface $resolver)
	{
		$resolver->setDefaults();
	}

	/**
	 * {@inheritDoc}
	 */
	public function getName()
	{
		return '$1';
	}
}
endsnippet

snippet ev "Symfony2 event" b
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use Symfony\Component\EventDispatcher\Event;

/**
 * ${2:@author `!v g:snips_author`}
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends Event
{
}
endsnippet

snippet redir "Symfony2 redirect" b
$this->redirect($this->generateUrl('$1', $2));
endsnippet

snippet usecontroller "Symfony2 use Symfony\..\Controller" b
use Symfony\Bundle\FrameworkBundle\Controller\Controller;$1
endsnippet

snippet usereauest "Symfony2 use Symfony\..\Request" b
use Symfony\Component\HttpFoundation\Request;$1
endsnippet

snippet useroute "Symfony2 use Sensio\..\Route" b
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;$1
endsnippet

snippet useresponse "Symfony2 use Symfony\..\Response" b
use Symfony\Component\HttpFoundation\Response;$1
endsnippet

snippet usefile "Symfony2 use Symfony\..\File" b
use Symfony\Component\HttpFoundation\File\UploadedFile;$1
endsnippet

snippet useassert "Symfony2 use Symfony\..\Constraints as Assert" b
use Symfony\Component\Validator\Constraints as Assert;$1
endsnippet

snippet usetemplate "Symfony2 use Sensio\..\Template" b
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;$1
endsnippet

snippet usecache "Symfony2 use Sensio\..\Cache" b
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Cache;$1
endsnippet

snippet usemethod "Symfony2 use Sensio\..\Method" b
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;$1
endsnippet

snippet usearray "Symfony2 use Doctrine\..\ArrayCollection" b
use Doctrine\Common\Collections\ArrayCollection;$1
endsnippet

snippet useorm "Symfony2 use Doctrine\..\Mapping as ORM" b
use Doctrine\ORM\Mapping as ORM;$1
endsnippet

snippet usesecure "Symfony2 use JMS\..\Secure" b
use JMS\SecurityExtraBundle\Annotation\Secure;$1
endsnippet

./UltiSnips/php.snippets	[[[1
286
priority -50

global !p
import vim

# Set g:ultisnips_php_scalar_types to 1 if you'd like to enable PHP 7's scalar types for return values
def isPHPScalarTypesEnabled():
	isEnabled = vim.eval("get(g:, 'ultisnips_php_scalar_types', 0)") == "1"
	return isEnabled or re.match('<\?php\s+declare\(strict_types=[01]\);', '\n'.join(vim.current.window.buffer))
endglobal

## Snippets from SnipMate, taken from
## https://github.com/scrooloose/snipmate-snippets.git

snippet gm "PHP Class Getter" b
/**
 * Getter for $1
 *
 * @return ${2:string}
 */
public function get${1/\w+\s*/\u$0/}()`!p snip.rv = ': '+t[2] if isPHPScalarTypesEnabled() else ''`
{
    return $this->$1;
}
endsnippet

snippet sm "PHP Class Setter" b
/**
 * Setter for $1
 *
 * @param ${2:string} $$1
 * @return ${3:`!p snip.rv=snip.basename`}
 */
public function set${1/\w+\s*/\u$0/}(${4:${2/(void|string|int|integer|double|float|object|boolear|null|mixed|number|resource)|(.*)/(?1::$2 )/}}$$1)
{
    $this->$1 = $$1;

    ${5:return $this;}
}
endsnippet

snippet gs "PHP Class Getter Setter" b
/**
 * Getter for $1
 *
 * @return ${2:string}
 */
public function get${1/\w+\s*/\u$0/}()`!p snip.rv = ': '+t[2] if isPHPScalarTypesEnabled() else ''`
{
    return $this->$1;
}

/**
 * Setter for $1
 *
 * @param $2 $$1
 * @return ${3:`!p snip.rv=snip.basename`}
 */
public function set${1/\w+\s*/\u$0/}(${4:${2/(void|string|int|integer|double|float|object|boolear|null|mixed|number|resource)|(.*)/(?1::$2 )/}}$$1)
{
    $this->$1 = $$1;

    ${5:return $this;}
}
endsnippet

snippet pub "Public function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
public function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet pro "Protected function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
protected function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet pri "Private function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
private function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet pubs "Public static function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
public static function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet pros "Protected static function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
protected static function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet pris "Private static function" b
/**
 * ${3:undocumented function}
 *
 * @return ${4:void}
 */
private static function ${1:name}(${2:$param})
{
	${VISUAL}${5:return null;}
}
$0
endsnippet

snippet fu "Function snip" b
function ${1:name}(${2:$param})
{
	${VISUAL}${3:return null;}
}
$0
endsnippet

snippet new "New class instance" b
$${1:variableName} = new ${2:${1/\w+\s*/\u$0/}}($3);
$0
endsnippet

snippet ns "namespace declaration" b
namespace ${1:`!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`};
endsnippet

snippet class "Class declaration template" b
<?php

namespace ${1:`!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`};

/**
 * Class ${1:`!p snip.rv=snip.basename`}
 * @author ${2:`!v g:snips_author`}
 */
class $1
{
}
endsnippet

snippet interface "Interface declaration template" b
<?php

namespace ${1:`!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`};

/**
 * Interface ${1:`!p snip.rv=snip.basename`}
 * @author ${2:`!v g:snips_author`}
 */
interface $1
{
	public function ${3:someFunction}();$4
}
endsnippet

snippet trait "Trait declaration template" b
<?php

namespace ${1:`!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`};

/**
 * Trait ${1:`!p snip.rv=snip.basename`}
 * @author ${2:`!v g:snips_author`}
 */
trait $1
{
}
endsnippet

snippet construct "__construct()" b
/**
 * @param$2 ${1/, /\n     * \@param /g}
 */
public function __construct(${1:$dependencies})
{${1/\w* ?\$(\w+)(, )*/\n        $this->$1 = $$1;/g}
}
$0
endsnippet

# PHPUnit snippets
snippet testcase "class XYZTest extends \PHPUnit_Framework_TestCase { ... }"
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

/**
 * @author `!v g:snips_author`
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends \PHPUnit_Framework_TestCase
{
	public function test$1()
	{
		${0:${VISUAL}}
	}
}
endsnippet

snippet testcase6 "class XYZTest extends TestCase { ... }"
<?php

namespace `!p
relpath = os.path.relpath(path)
m = re.search(r'[A-Z].+(?=/)', relpath)
if m:
	snip.rv = m.group().replace('/', '\\')
`;

use PHPUnit\Framework\TestCase;

/**
 * @author `!v g:snips_author`
 */
class `!p
snip.rv = re.match(r'.*(?=\.)', fn).group()
` extends TestCase
{
	public function test$1()
	{
		${0:${VISUAL}}
	}
}
endsnippet

# :vim:ft=snippets:
./UltiSnips/plsql.snippets	[[[1
733
###########################################################################
#							 PLSQL SNIPPETS								  #
###########################################################################

global !p
# Import package
import datetime

# Return the doc string for PLSQL script
def docstring_plsql(params):
	comment = ""
	if params:
		comment = "/** Parameters\n"
		# Split the arguments
		args = [arg.strip() for arg in params.split(',')]
		for arg in args:
			comment += "* {0:30} : \n".format(arg.split(' ')[0].upper())
		comment += "*/\n"
	# Return the comment string
	return comment

def hdr_params(params, level=0, gap="	 "):
	line = level * gap + "-- -----------------------------------------------"
	comment = line
	if params:
		# Split the arguments
		args = [arg.strip() for arg in params.split(',')]
		for arg in args:
			comment += "\n" + level * gap + "-- {0:20} : ".format(arg.split(' ')[0].upper())
	# comment += line
	# Return the comment string
	return comment

def dyear():
	""" Returns the current Year in YYYY format
	"""
	now = datetime.datetime.now()
	rv=now.year
	return rv

def today():
	""" Returns the current Date in DD-MON-YYYY format
	"""
	now = datetime.datetime.now()
	rv=now.strftime("%d-%b-%Y")
	return rv

def param(var):
	""" Returns the string name wrapped value """
	return "'" + var + " : ' || "
	
endglobal

########################################
#		 SQL Snippets				   #
########################################
snippet doc "Document comment"
	/*
	 *	${0: comment ...}
	 */
endsnippet

snippet hdr "Header Documentation"
-- #############################################################################
-- #	  Copyright (c) `!p snip.rv = dyear()` ${1:company}
-- #				All rights reserved
-- #
-- ############################################################################
-- # Application   : ${2:schema}
-- # File Name:	   : ${3:`!p snip.rv=snip.fn`}
-- # Type		   : Table																					 
-- # Exec Method   : PL/SQL File
-- # Description   : This script ${5:create} under the schema $2
-- #										  
-- # Change History
-- # -----------------------------------------------------------------------
-- # Version	 Date		  Author			Remarks
-- # =======  ===========  ================		============================
-- # 1.0	  `!p snip.rv = today()`	Amit Maindola		 Initial Version
-- #############################################################################

endsnippet

snippet pkggbl	"Package Global variables"
   -- Declare Global Variables
   g_sysdate									DATE := SYSDATE;
   g_delimiter									VARCHAR2( 30 ) := '	  ';
   g_err_length_limit						NUMBER := 1500;
   g_package_name					   CONSTANT VARCHAR2(30) := '${0}';
   g_proc_name VARCHAR2(100)					:= NULL;
   excp_custom									EXCEPTION;

   -- Declare User Global Types

endsnippet

snippet flushca "Flush Cache"
ALTER SYSTEM FLUSH BUFFER_CACHE;
endsnippet

snippet flushsp "Flush Shared Pool"
ALTER SYSTEM FLUSH SHARED_POOL;
endsnippet

snippet err
	show errors;
endsnippet

snippet sel "Select statement"
SELECT ${0:*} FROM ${1} WHERE 1 = 1;
endsnippet

snippet selc "Select statement"
SELECT COUNT(1) FROM ${1} WHERE ${0};
endsnippet

snippet wrn "Where ROWNNUM"
WHERE ROWNUM <= 10 ${0:AND}
endsnippet

snippet arn "AND ROWNNUM"
AND ROWNUM <= 10 ${0:;}
endsnippet

snippet ppram "Retuns param in wrapped format"
	||`!p snip.rv = param(t[1].upper())`$1 $0
endsnippet

snippet dbo "Show output "
	DBMS_OUTPUT.put_line('${0}');
endsnippet

snippet dbop "Show Parameter output "
	DBMS_OUTPUT.put_line(`!p snip.rv = param(t[1].upper())`$1 $0);
endsnippet

snippet dbl "Log message in Log Table, Change procedure as defined by you"
	DEBUG_LOG_PKG.WRITE_LOG(${1:'Test'},${2:$1} ,$0 );
endsnippet

snippet plog "Print Log output "
	printlog(`!p snip.rv = param(t[1].upper())`$1 $0);
endsnippet

snippet dut "DBMS_OUTPUT.put_line"
	DBMS_UTILITY.get_time;
endsnippet

snippet bc "Bulk collect into"
	bulk collect into ${0}
endsnippet

snippet ei "Execute Immediate"
	EXECUTE IMMEDIATE '${0:statement}' ;
endsnippet

snippet eitt "Execute Immediate TRUNCATE Table"
	EXECUTE IMMEDIATE( 'TRUNCATE TABLE ${0:table}');
endsnippet

snippet eitp "Execute Immediate ALTER Table Truncate partition"
	EXECUTE IMMEDIATE( 'ALTER TABLE ${1:table} TRUNCATE PARTITION ${0:partition}');
endsnippet

snippet prmpt "Prompt message"
PROMPT ${1:Creating }...
endsnippet

snippet crseq "Create Sequence"
DROP SEQUENCE ${1:schema}.${2:name}_s;

CREATE SEQUENCE $1.$2_s
   START WITH ${3:1}
   MAXVALUE 999999999999999999999999999
   MINVALUE 1
   NOCYCLE
   NOCACHE
   NOORDER;
endsnippet

snippet crsyn "Create Synonym"

CREATE OR REPLACE SYNONYM ${1:schema}.${2:name} FOR ${3:target}.${0};

endsnippet

snippet crind "Create Index"
DROP INDEX $1.$4;

CREATE INDEX $1.${4:$2_${5}}
ON ${1:schema}.${2:table}(${3}) ${6:TABLESPACE ${0} };
endsnippet

########################################
#		 Table Operation			   #
########################################

snippet drtab "Drop Table"
DROP TABLE ${1:schema}.${2:name} CASCADE CONSTRAINTS ${3:PURGE};

endsnippet

snippet crtab "Create Table"

DROP TABLE ${1:schema}.${2:name} CASCADE CONSTRAINTS PURGE;

CREATE TABLE $1.$2
(
   ${0}
)
${3:TABLESPACE ${4}}
;
endsnippet

snippet ccol  "Add VARCHAR2 column to table"
	${1:,} ${2:name}	VARCHAR2(${0:100})
endsnippet
  
snippet dcol  "Add DATE column to table"
	${1:,} ${0:name}	DATE
endsnippet
  
snippet ncol  "Add NUMBER column to table"
	${1:,} ${0:name}	NUMBER
endsnippet

snippet at "Alter Table"
	ALTER TABLE ${1:table} ${0}
endsnippet


#########################################
#	Declare Types and local variable	#
#########################################
  
snippet tr "Type record"
	TYPE t_${1:rec} IS RECORD (${0:/* columns */} );
endsnippet
   
snippet tt "Type Table"
	TYPE t_${1:tbl} IS TABLE OF ${0:table_name}%ROWTYPE INDEX BY BINARY_INTEGER;
endsnippet

snippet tc "Type Cursor"
	TYPE t_${1:tbl} IS TABLE OF ${0:cur}%ROWTYPE INDEX BY BINARY_INTEGER;
endsnippet

snippet pn
	p_${1}		${2:IN}		NUMBER ${3:DEFAULT ${0:NULL}}
endsnippet

snippet pd
	p_${1}		${2:IN}		DATE ${3:DEFAULT ${0:SYSDATE}}
endsnippet

snippet pc
	P_${1}		${2:IN}		VARCHAR2 ${3:DEFAULT ${0:NULL}}
endsnippet

snippet ln
	l_${1}		NUMBER ${2: := ${3} };
endsnippet

snippet ld
	l_${1}		DATE ${2: := ${3} };
endsnippet

snippet lc
	l_${1}		VARCHAR2(${2:100}) ${3: := ${4} };
endsnippet

snippet gn
	g_${1}		NUMBER ${2: := ${3:10} };
endsnippet

snippet gd
	g_${1}		DATE ${2: := ${3:SYSDATE} };
endsnippet

snippet gc
	g_${1}		VARCHAR2(${2:100}) ${3: := ${4} };
endsnippet

snippet ltbl
	l_tbl_${1}		${0};
endsnippet

snippet lrec
	l_rec_${1}		${0};
endsnippet

#########################################
#		   Condition, Loops				#
#########################################
snippet if "If Condition"
	IF(${1}) THEN
		${0};
	END IF;
endsnippet

snippet ife "IF-Else Condition"
	IF(${1}) THEN
		${2};
	ELSIF
		${0};
	END IF;
endsnippet

snippet els "Else Condition"
	ELSIF ${1:condition} THEN
		${0};
endsnippet

snippet case "Case statement"
	CASE WHEN (${1}) THEN
		${2}
	WHEN (${3}) THEN
		${4}
	${0:ELSE}
	END 
endsnippet

snippet while "While Loop"
	WHILE ${1:a} ${2:condition} ${3:b}	LOOP
		${0};
	END LOOP;
endsnippet

snippet fori "For Loop"
	FOR ${1:indx} in ${2:1}..${3:10}  LOOP
		${4};
	END LOOP;
endsnippet

snippet fort "Table For Loop"
	FOR ${1:indx} in 1..${2:ttb}.count LOOP
		${0};
	END LOOP;
endsnippet

snippet loop "Loop statement"
	LOOP
		${0};
	END LOOP;
endsnippet

snippet fora "For All Loop"
	  IF ( ${1:ttbl}.COUNT > 0 ) THEN
		 BEGIN
			FORALL ${2:indx} IN 1 .. $1.COUNT
				-- Insert/Update
				${0}
		 EXCEPTION --Exception Block
			WHEN OTHERS THEN
			   l_errmsg	  := 'Error while Bulk updating, Error : ' || SQLERRM;
			   RAISE excp_custom;
		 END;
	  END IF;
endsnippet

snippet forc "For Cursor Loop"
	FOR $1_rec IN ${1:cur} ${2:(${3:param})}
	LOOP
		${0}
	END LOOP; -- End $1
endsnippet

#########################################
#		  Cursor Operations				#
#########################################
snippet dcur "Cursor declaration"
	CURSOR ${1:cur} IS
	SELECT ${0}
		FROM $1
		WHERE 1 = 1;
endsnippet

snippet copen "Open Cursor"
	OPEN ${1:cursor} ${2:( ${3:param} )};
	FETCH $1
	INTO ${4:record};
	${0}
	IF ( $1 %NOTFOUND ) THEN
		CLOSE $1;
		l_errmsg := 'No records fetched in cursor : $1.';
		RAISE excp_custom;
	END IF;
	CLOSE $1;
endsnippet

snippet copenbc "Open Cursor Bulk collect"
	OPEN ${1:cursor} ${2:( ${3:param} )};
	FETCH $1
	BULK COLLECT INTO ${4:ttbl};
	CLOSE $1;

	IF ( $4.count = 0 ) THEN
		l_errmsg := 'No records fetched in cursor : $1.';
		RAISE excp_custom;{0}
	END IF;
endsnippet

#########################################
#		BEGIN/DECLARE Blocks			#
#########################################
snippet decl "Declare Begin block"
DECLARE
	${1}
BEGIN	   
	${0:null}
EXCEPTION --Exception Block	  
   WHEN NO_DATA_FOUND THEN
		dbms_output.put_line('No Data Found');
   WHEN OTHERS THEN
	  dbms_output.put_line('Error while . Error : '||sqlerrm);
END;
endsnippet

snippet begin "Begin block"
BEGIN	   
   ${0}
EXCEPTION --Exception Block	  
   WHEN NO_DATA_FOUND THEN
	  printlog('No Data Found');
   WHEN OTHERS THEN
	  printlog('Error while . Error : '||sqlerrm);
END;
endsnippet

snippet excp "Exception Block"
	EXCEPTION --Exception Block
	${0}
		WHEN OTHERS THEN
		${1};
	END;
endsnippet

snippet rae "Raise Application Error"
RAISE_APPLICATION_ERROR(${1:-20000},${0:''});
endsnippet

#########################################
#	   Procedure/Function calling		#
#########################################
snippet crjob "Submit DBMS Job"
-- Submit the job to get the output
BEGIN
	DECLARE
		vjob		  INTEGER;
	BEGIN
		DBMS_JOB.submit( vjob, '${1:procedure}${0:('''')};', SYSDATE );
		DBMS_OUTPUT.put_line( 'Job id : ' || vjob );
		COMMIT;
	END;
END;
endsnippet

snippet whilejob "Submit DBMS Job with While Loop"
-- Submit the job to get the output

BEGIN
	DECLARE
		vjob		  INTEGER;
	BEGIN
		DBMS_JOB.submit ( vjob , '
DECLARE
	l_start_date		  DATE := ''${1:01-Jan-2017}'';
BEGIN
	WHILE l_start_date < ''${2:01-Jan-2017}''
	LOOP
		${3:Procedure}${0:( to_char(l_start_date,''YYYYMMDD'') )};
		l_start_date		  := TRUNC( l_start_date + 1 );
	END LOOP;
EXCEPTION --Exception Block
	WHEN OTHERS THEN
		DBMS_OUTPUT.put_line( ''Error while . Error : '' || SQLERRM );
END;
			'
		  , SYSDATE
		);
		DBMS_OUTPUT.put_line( 'Job id : ' || vjob );
		COMMIT;
	END;
END;
endsnippet

  
#########################################
#		Function creation scripts		#
#########################################
snippet crprintlog "Create Printlog Procedure"
	------------------------------------------------------------------------------------------------
	-- PROCEDURE	: PRINTLOG
	-- Description	: This procedure is used to print log messages in Log file, Table and Console
	------------------------------------------------------------------------------------------------
	PROCEDURE printlog (p_message IN VARCHAR2)
	IS
		l_errmsg									 VARCHAR2 (10000);
	BEGIN
		l_errmsg := SUBSTR ( p_message, 1, g_err_length_limit);
		fnd_file.put_line ( fnd_file.LOG, l_errmsg); -- Debug log file
		DBMS_OUTPUT.put_line (l_errmsg); -- Console output
		DEBUG_LOG_PKG.WRITE_LOG(g_package_name,g_proc_name,p_message); -- Debug table
	END printlog;
endsnippet

snippet crgeterr "Create get_errmsg function"
   -- Form the error message for when others
   FUNCTION get_errmsg( p_message IN VARCHAR2 DEFAULT NULL )
	  RETURN VARCHAR2
   IS
   BEGIN
	  RETURN 'Error occured in ' || g_package_name || '.' || g_proc_name || '. ' || NVL( p_message, '' ) || ' Error : ' || SQLERRM;
   EXCEPTION --Exception Block
	  WHEN OTHERS THEN
		 printlog( 'Error while forming messgage. Error : ' || SQLERRM );
		 RETURN NULL;
   END;
endsnippet

snippet crpksfunc "Create package specification function"
------------------------------------------------------------------------------------------------
-- Function		: `!p snip.rv = t[1].upper()`
-- Description	: This Function will ${4:description}.
`!p snip.rv=hdr_params(t[3]) `
------------------------------------------------------------------------------------------------
FUNCTION ${1:func} ${2:(${3:params})} 
	  RETURN ${0};
endsnippet

snippet crpksproc "Create package specification procedure"
------------------------------------------------------------------------------------------------
-- PROCEDURE	: `!p snip.rv = t[1].upper()`
-- Description	: This Procedure will ${4:description}.
`!p snip.rv=hdr_params(t[3],0) `
------------------------------------------------------------------------------------------------
PROCEDURE ${1:proc} ${2:(${3:params})} ;
endsnippet

snippet crpkbfunc "Create package body function"
	------------------------------------------------------------------------------------------------
	-- Function		: `!p snip.rv = t[1].upper()`
	-- Description	: This Function will ${8:description}.
	`!p snip.rv=hdr_params(t[3],2) `
	------------------------------------------------------------------------------------------------
   FUNCTION ${1:func} ${2:(${3:params})} 
	  RETURN ${4}
   IS
	  -- Declare Cursors
	  -- Declare Variables
	  ${5:l_}							 $4 ${6:( ${7:length} )};
   BEGIN
	  -- Initialize 
	  g_proc_name								:= '`!p snip.rv = t[1].upper()`';
	  ${0}
	  -- Return value
	  RETURN $5 ;
   EXCEPTION
	  WHEN OTHERS
	  THEN
		 RETURN NULL;
   END $1;
endsnippet

snippet crpkbproc "Create package body procedure"

------------------------------------------------------------------------------------------------
-- PROCEDURE	: `!p snip.rv = t[1].upper()`
-- Description	: This Procedure will ${4:description}.
`!p snip.rv=hdr_params(t[3]) `
------------------------------------------------------------------------------------------------
PROCEDURE ${1:proc} ${2:(${3:params})} 
IS
   -- Declare cursors
   -- Declare Out and exception variables
   l_errmsg										VARCHAR2( 10000 ) := null;
   excp_skip									EXCEPTION;
-- Declare Varibales

BEGIN
   -- Initializing out parameters
   g_proc_name									:= '`!p snip.rv = t[1].upper()`';

   ${0}
EXCEPTION -- Exception block of Procedure
   WHEN excp_custom THEN
	  ROLLBACK;
	  printlog( l_errmsg );
   WHEN OTHERS THEN
	  ROLLBACK;
	  l_errmsg									  := get_errmsg;
	  printlog( l_errmsg );
END $1;

endsnippet

snippet crpks "Create Package specification"
CREATE OR REPLACE PACKAGE ${1}.${2}
AS
-- #############################################################################
-- #	  Copyright (c) `!p snip.rv = dyear()` ${3}
-- #				All rights reserved
-- #
-- ############################################################################
-- #
-- # Application   : $1
-- # File Name:	   : `!p snip.rv = t[2].upper()`.pks
-- # Exec Method   : PL/SQL Stored - Procedure
-- # Description   : Package used for ${4}
-- #
-- # Change History
-- # -----------------------------------------------------------------------
-- # Version	 Date		  Author		   Remarks
-- # =======  ===========  =============	============================
-- # 1.0	  `!p snip.rv = today()`  Amit Maindola	   Initial Version
-- #
-- #
-- ############################################################################
   ${0}
END $2;
/

SHOW ERROR
/
endsnippet

snippet crpkb  "Create package body"
CREATE OR REPLACE PACKAGE BODY ${1}.${2}
IS
-- #############################################################################
-- #	  Copyright (c) `!p snip.rv = dyear()` ${3}
-- #				All rights reserved
-- #
-- ############################################################################
-- #
-- # Application   : $1
-- # File Name:	   : `!p snip.rv = t[2].upper()`.pkb
-- # Exec Method   : PL/SQL Stored - Procedure
-- # Description   : Package used for ${4}
-- #
-- # Change History
-- # -----------------------------------------------------------------------
-- # Version	 Date		  Author		   Remarks
-- # =======  ===========  =============	============================
-- # 1.0	  `!p snip.rv = today()`  Amit Maindola	   Initial Version
-- #
-- #
-- ############################################################################ 
   -- Declare Global Variables
   g_sysdate									DATE := SYSDATE;
   g_delimiter									VARCHAR2( 30 ) := '	  ';
   g_err_length_limit						NUMBER := 1500;
   g_package_name					   CONSTANT VARCHAR2(30) := '`!p snip.rv = t[2].upper()`';
   g_proc_name VARCHAR2(100)					:= NULL;
   excp_custom									EXCEPTION;

   -- Declare User Global Types

   ------------------------------------------------------------------------------------------------
   -- PROCEDURE	   : PRINTLOG
   -- Description  : This procedure is used to print log messages
   ------------------------------------------------------------------------------------------------
   PROCEDURE printlog( p_message IN VARCHAR2 )
   IS
   BEGIN
	  DBMS_OUTPUT.PUT_LINE( p_message );
	  DEBUG_LOG_PKG.WRITE_LOG(g_package_name,g_proc_name,p_message);
   END printlog;

   -- Form the error message for when others
   FUNCTION get_errmsg( p_message IN VARCHAR2 DEFAULT NULL )
	  RETURN VARCHAR2
   IS
   BEGIN
	  RETURN 'Error occured in ' || g_package_name || '.' || g_proc_name || '. ' || NVL( p_message, '' ) || ' Error : ' || SQLERRM;
   EXCEPTION --Exception Block
	  WHEN OTHERS THEN
		 printlog( 'Error while forming messgage. Error : ' || SQLERRM );
		 RETURN NULL;
   END;

END $2;
/

SHOW ERROR
/

endsnippet

snippet crproc "Create procedure"

CREATE OR REPLACE PROCEDURE ${1:schema}.${2:name} ${3:( ${4:prams} )}
-- #############################################################################
-- #	  Copyright (c) `!p snip.rv = dyear()` ${5}
-- #				All rights reserved
-- #
-- ############################################################################
-- #
-- # Application   : $1
-- # File Name:	   : `!p snip.rv = t[2].upper()`.prc
-- # Exec Method   : PL/SQL Stored - Procedure
-- # Description   : Package used for ${6}
-- #
-- # Change History
-- # -----------------------------------------------------------------------
-- # Version	 Date		  Author		   Remarks
-- # =======  ===========  =============	============================
-- # 1.0	  `!p snip.rv = today()`  Amit Maindola	   Initial Version
-- #
-- #
-- ############################################################################
is
	g_proc_name									 VARCHAR2(30)	   := '`!p snip.rv = t[2].upper()`';
	l_errmsg									 VARCHAR2( 10000 ) := null;
	excp_custom									 EXCEPTION;
	-- Declare cursors
	-- Declare Varibales
BEGIN
   -- Initializing out parameters

   ${0}
EXCEPTION -- Exception block of Procedure
   WHEN excp_custom THEN
	  ROLLBACK;
	  DEBUG_LOG_PKG.WRITE_LOG(g_proc_name,g_proc_name ,l_errmsg );
   WHEN OTHERS THEN
	  ROLLBACK;
	  l_errmsg									  := 'Exception in procedure. '||SQLERRM;
	  DEBUG_LOG_PKG.WRITE_LOG(g_proc_name,g_proc_name ,l_errmsg );
END $2;

endsnippet

./UltiSnips/proto.snippets	[[[1
52
priority -50

global !p
from vimsnippets import complete

FIELD_TYPES = [
	'double',
	'float',
	'int32',
	'int64',
	'uint32',
	'uint64',
	'sint32',
	'sint64',
	'fixed32',
	'fixed64',
	'sfixed32',
	'sfixed64',
	'bool',
	'string',
	'bytes']
endglobal

snippet mess "Proto message" b
// ${2:TODO(`whoami`): Describe this message.}
message ${1:Name} {
	$0

	// Next available id: 1
}
endsnippet

snippet reqf "Required field" b
// ${4:TODO(`whoami`): Describe this field.}
optional $1`!p snip.rv = complete(t[1], FIELD_TYPES)` ${2:name} = ${3:1};  // Required
endsnippet

snippet optf "Optional field" b
// ${4:TODO(`whoami`): Describe this field.}
optional $1`!p snip.rv = complete(t[1], FIELD_TYPES)` ${2:name} = ${3:1};
endsnippet

snippet repf "Repeated field" b
// ${4:TODO(`whoami`): Describe this field.}
repeated $1`!p snip.rv = complete(t[1], FIELD_TYPES)` ${2:name} = ${3:1};
endsnippet

snippet enum "Enumeration" b
// ${2:TODO(`whoami`): Describe this enum.}
enum ${1:Name} {
}
endsnippet
./UltiSnips/puppet.snippets	[[[1
260
priority -50

#########################################################################
#  Python helper code                                                   #
#########################################################################

global !p
import vim
import os.path
def get_module_namespace_and_basename():
	"""This function will try to guess the current class, define or type
	name you are trying to create. Note that for this to work you should be
	using the module structure as per the style guide. Examples inputs and
	it's output
	* /home/nikolavp/puppet/modules/collectd/manifests/init.pp -> collectd
	* /home/nikolavp/puppet/modules/collectd/manifests/mysql.pp -> collectd::mysql
	* /home/nikolavp/puppet/modules/collectd/types/dbname.pp -> Collectd::Dbname
	"""
	first_time = True
	current_file_path_without_ext = vim.eval('expand("%:p:r")') or ""
	if not current_file_path_without_ext:
		return "name"
	parts = os.path.split(current_file_path_without_ext)
	namespace = ''
	while parts[0] and parts[0] != '/':
		if parts[1] == 'init' and first_time and not namespace:
			first_time = False
			parts = os.path.split(parts[0])
			continue
		if parts[1] in ['manifests', 'types']:
			parsed_name = os.path.split(
				parts[0])[1] + ('::' + namespace).rstrip(':')
			if parts[1] == 'types':
				parsed_name = parsed_name.title()
			return parsed_name
		else:
			namespace = parts[1] + '::' + namespace
		parts = os.path.split(parts[0])
	# couldn't guess the namespace. The user is editing a raw file in no module like the site.pp file
	return "name"
endglobal

###############################################################################
#  Puppet Language Constructs                                                 #
#    See http://docs.puppetlabs.com/puppet/latest/reference/lang_summary.html #
###############################################################################

snippet class "Class declaration" b
class ${1:`!p snip.rv = get_module_namespace_and_basename()`} {
	${0:# body}
}
endsnippet

snippet define "Definition" b
define ${1:`!p snip.rv = get_module_namespace_and_basename()`} {
	${0:# body}
}
endsnippet

snippet type "Data type alias" b
type ${1:`!p snip.rv = get_module_namespace_and_basename()`} = ${2:Type}
endsnippet

snippet lambda "Lambda function chain-called on a variable"
$${1:varname}.${2:each} |${3:Type} $${4:param}| {
	$0
}
endsnippet

#################################################################
#  Puppet Types                                                 #
#    See http://docs.puppetlabs.com/references/latest/type.html #
#################################################################

snippet cron "Cron resource type" b
cron { '${1:name}':
	user    => ${2:user},
	command => '${3:command}',
	minute  => ${3:minute},
	hour    => ${4:hour},
}
endsnippet

snippet exec "Exec resource type" b
exec { '${1:command}':
	command => "${2:$1}",
	user    => "${3:root}",
}
endsnippet

snippet file "File resource type" b
file { '${1:name}':
	source => "puppet://${2:path}",
	mode   => ${3:mode},
}
endsnippet

snippet File "Defaults for file" b
File {
	owner => ${1:username},
	group => ${2:groupname},
}
endsnippet

snippet group "Group resource type" b
group { '${1:groupname}':
	ensure => ${3:present},
	gid    => ${2:gid},
}
endsnippet

snippet mount "Mount resource type" b
mount { '${1:path}':
	device  => '${2:/dev}',
	fstype  => '${3:filesystem}',
	ensure  => mounted,
	options => 'rw,errors=remount-ro',
}
endsnippet

snippet package "Package resource type" b
package { '${1:name}':
	ensure => ${2:installed},
}
endsnippet

snippet user "user resource type" b
user { '${1:username}':
	ensure     => ${2:present},
	uid        => ${3:uid},
	gid        => ${4:gid},
	comment    => ${5:gecos},
	home       => ${6:homedirectory},
	managehome => false,
	require    => Group['${7:group'}],
}
endsnippet

snippet service "Service resource type" b
service { '${1:name}':
	hasstatus => true,
	enable    => true,
	ensure    => running,
}
endsnippet

########################################################################
#  Puppet Functions                                                    #
#    See http://docs.puppetlabs.com/references/latest/function.html    #
########################################################################

snippet alert "Alert Function" b
alert("${1:message}")$0
endsnippet

snippet crit "Crit Function" b
crit("${1:message}")$0
endsnippet

snippet debug "Debug Function" b
debug("${1:message}")$0
endsnippet

snippet defined "Defined Function" b
defined(${1:Resource}["${2:name}"])$0
endsnippet

snippet emerg "Emerg Function" b
emerg("${1:message}")$0
endsnippet

snippet extlookup "Simple Extlookup" b
$${1:Variable} = extlookup("${2:Lookup}")$0
endsnippet

snippet extlookup "Extlookup with defaults" b
$${1:Variable} = extlookup("${2:Lookup}", ${3:Default})$0
endsnippet

snippet extlookup "Extlookup with defaults and custom data file" b
$${1:Variable} = extlookup("${2:Lookup}", ${3:Default}, ${4:Data Source})$0
endsnippet

snippet fail "Fail Function" b
fail("${1:message}")$0
endsnippet

snippet hiera "Hiera Function" b
$${1:Variable} = hiera("${2:Lookup}")$0
endsnippet

snippet hiera "Hiera with defaults" b
$${1:Variable} = hiera("${2:Lookup}", ${3:Default})$0
endsnippet

snippet hiera "Hiera with defaults and override" b
$${1:Variable} = hiera("${2:Lookup}", ${3:Default}, ${4:Override})$0
endsnippet

snippet hiera_hash "Hiera Hash Function" b
$${1:Variable} = hiera_hash("${2:Lookup}")$0
endsnippet

snippet hiera_hash "Hiera Hash with defaults" b
$${1:Variable} = hiera_hash("${2:Lookup}", ${3:Default})$0
endsnippet

snippet hiera_hash "Hiera Hash with defaults and override" b
$${1:Variable} = hiera_hash("${2:Lookup}", ${3:Default}, ${4:Override})$0
endsnippet

snippet hiera_include "Hiera Include Function" b
hiera_include("${1:Lookup}")$0
endsnippet

snippet lookup "Lookup data from hiera"
$${1:varname} = lookup('${2:hiera::key}')$0
endsnippet

snippet trocla "Lookup or generate sensitive information"
trocla('${1:lookup_key}', '${2:plain}', ${3:'length: 32'})$0
endsnippet

snippet include "Include Function" b
include ${1:classname}$0
endsnippet

snippet info "Info Function" b
info("${1:message}")$0
endsnippet

snippet inline_template "Inline Template Function" b
inline_template("<%= ${1:template} %>")$0
endsnippet

snippet notice "Notice Function" b
notice("${1:message}")$0
endsnippet

snippet realize "Realize Function" b
realize(${1:Resource}["${2:name}"])$0
endsnippet

snippet regsubst "Regsubst Function" b
regsubst($${1:Target}, '${2:regexp}', '${3:replacement}')$0
endsnippet

snippet split "Split Function" b
$${1:Variable} = split($${1:Target}, '${2:regexp}')$0
endsnippet

snippet versioncmp "Version Compare Function" b
$${1:Variable} = versioncmp('${1:version}', '${2:version}')$0
endsnippet

snippet warning "Warning Function" b
warning("${1:message}")$0
endsnippet

# vim:ft=snippets:
./UltiSnips/python.snippets	[[[1
782
priority -50

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

#! header
snippet #! "#!/usr/bin/env python" b
#!/usr/bin/env python
$0
endsnippet

snippet #!2 "#!/usr/bin/env python2" b
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
$0
endsnippet

snippet #!3 "#!/usr/bin/env python3" b
#!/usr/bin/env python3
$0
endsnippet

snippet "^# ?[uU][tT][fF]-?8" "# encoding: UTF-8" r
# -*- coding: utf-8 -*-
$0
endsnippet

snippet ifmain "ifmain" b
if __name__ == `!p snip.rv = get_quoting_style(snip)`__main__`!p snip.rv = get_quoting_style(snip)`:
	${1:${VISUAL:main()}}
endsnippet

snippet with "with" b
with ${1:expr}`!p snip.rv = " as " if t[2] else ""`${2:var}:
	${3:${VISUAL:pass}}
$0
endsnippet

snippet for "for loop" b
for ${1:item} in ${2:iterable}:
	${3:${VISUAL:pass}}
endsnippet

##########
# COMMON #
##########

# The smart def and smart class snippets use a global option called
# "g:ultisnips_python_style" which, if set to "doxygen" will use doxygen
# style comments in docstrings.

global !p

NORMAL  = 0x1
DOXYGEN = 0x2
SPHINX  = 0x3
GOOGLE  = 0x4
NUMPY   = 0x5
JEDI    = 0x6

SINGLE_QUOTES = "'"
DOUBLE_QUOTES = '"'


class Arg(object):
	def __init__(self, arg):
		self.arg = arg
		name_and_type = arg.split('=')[0].split(':')
		self.name = name_and_type[0].strip()
		self.type = name_and_type[1].strip() if len(name_and_type) == 2 else None

	def __str__(self):
		return self.name

	def __unicode__(self):
		return self.name

	def is_kwarg(self):
		return '=' in self.arg

	def is_vararg(self):
		return '*' in self.name


def get_args(arglist):
	args = []
	n = len(arglist)
	i = 0
	while i < n:
		l_bracket = 0
		start = i
		while i < n and (l_bracket > 0 or arglist[i] != ','):
			if arglist[i] == '[':
				l_bracket += 1
			elif arglist[i] == ']' and l_bracket > 0:
				l_bracket -= 1
			i += 1
		arg = arglist[start:i]
		if arg:
			args.append(Arg(arg))
		i += 1

	args = [arg for arg in args if arg.name != 'self']

	return args


def get_quoting_style(snip):
	style = snip.opt("g:ultisnips_python_quoting_style", "double")
	if style == 'single':
		return SINGLE_QUOTES
	return DOUBLE_QUOTES

def triple_quotes(snip):
	style = snip.opt("g:ultisnips_python_triple_quoting_style")
	if not style:
		return get_quoting_style(snip) * 3
	return (SINGLE_QUOTES if style == 'single' else DOUBLE_QUOTES) * 3

def triple_quotes_handle_trailing(snip, quoting_style):
	"""
	Generate triple quoted strings and handle any trailing quote char,
	which might be there from some autoclose/autopair plugin,
	i.e. when expanding ``"|"``.
	"""
	if not snip.c:
		# Do this only once, otherwise the following error would happen:
		# RuntimeError: The snippets content did not converge: …
		row, col = vim.current.window.cursor

		# before ultisnip expansion, chars ahead cursor is at row - 1, col
		# after ultisnip expansion, they are pushed to row + 1, col - 1
		# when this function is run, it's already after ultisni expansion
		line = snip.buffer[row + 1]

		# Handle already existing quote chars after the trigger.
		_ret = quoting_style * 3
		while True:
			try:
				nextc = line[col - 1]
			except IndexError:
				break
			if nextc == quoting_style and len(_ret):
				_ret = _ret[1:]
				col = col+1
			else:
				break
		snip.rv = _ret
	else:
		snip.rv = snip.c

def get_style(snip):
	style = snip.opt("g:ultisnips_python_style", "normal")

	if    style == "doxygen": return DOXYGEN
	elif  style == "sphinx": return SPHINX
	elif  style == "google": return GOOGLE
	elif  style == "numpy": return NUMPY
	elif  style == "jedi": return JEDI
	else: return NORMAL


def format_arg(arg, style):
	if style == DOXYGEN:
		return "@param %s TODO" % arg
	elif style == SPHINX:
		return ":param %s: TODO" % arg
	elif style == NORMAL:
		return ":%s: TODO" % arg
	elif style == GOOGLE:
		return "%s (%s): TODO" % (arg, arg.type or "TODO")
	elif style == JEDI:
		return ":type %s: TODO" % arg
	elif style == NUMPY:
		return "%s : TODO" % arg


def format_return(style):
	if style == DOXYGEN:
		return "@return: TODO"
	elif style in (NORMAL, SPHINX, JEDI):
		return ":returns: TODO"
	elif style == GOOGLE:
		return "Returns: TODO"


def write_docstring_args(args, snip):
	if not args:
		snip.rv += ' {0}'.format(triple_quotes(snip))
		return

	snip.rv += '\n' + snip.mkline('', indent='')

	style = get_style(snip)

	if style == GOOGLE:
		write_google_docstring_args(args, snip)
	elif style == NUMPY:
		write_numpy_docstring_args(args, snip)
	else:
		for arg in args:
			snip += format_arg(arg, style)


def write_google_docstring_args(args, snip):
	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		snip += "Args:"
		snip.shift()
		for arg in args:
			snip += format_arg(arg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')

	if kwargs:
		snip += "Kwargs:"
		snip.shift()
		for kwarg in kwargs:
			snip += format_arg(kwarg, GOOGLE)
		snip.unshift()
		snip.rv += '\n' + snip.mkline('', indent='')


def write_numpy_docstring_args(args, snip):
	if args:
		snip += "Parameters"
		snip += "----------"

	kwargs = [arg for arg in args if arg.is_kwarg()]
	args = [arg for arg in args if not arg.is_kwarg()]

	if args:
		for arg in args:
			snip += format_arg(arg, NUMPY)
	if kwargs:
		for kwarg in kwargs:
			snip += format_arg(kwarg, NUMPY) + ', optional'
	snip.rv += '\n' + snip.mkline('', indent='')


def write_init_body(args, parents, snip):
	parents = [p.strip() for p in parents.split(",")]
	parents = [p for p in parents if p != 'object']

	for p in parents:
		snip += p + ".__init__(self)"

	if parents:
		snip.rv += '\n' + snip.mkline('', indent='')

	for arg in filter(lambda arg: not arg.is_vararg(), args):
		snip += "self._%s = %s" % (arg, arg)


def write_slots_args(args, snip):
	quote = get_quoting_style(snip)
	arg_format = quote + '_%s' + quote
	args = [arg_format % arg for arg in args]
	snip += '__slots__ = (%s,)' % ', '.join(args)


def write_function_docstring(t, snip):
	"""
	Writes a function docstring with the current style.

	:param t: The values of the placeholders
	:param snip: UltiSnips.TextObjects.SnippetUtil object instance
	"""
	snip.rv = ""
	snip >> 1

	args = get_args(t[2])
	if args:
		write_docstring_args(args, snip)

	style = get_style(snip)

	if style == NUMPY:
		snip += 'Returns'
		snip += '-------'
		snip += 'TODO'
	else:
		snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

def get_dir_and_file_name(snip):
	return os.getcwd().split(os.sep)[-1] + '.' + snip.basename

endglobal

########################################
# Class & Special Method Name Snippets #
########################################

snippet class "class with docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined.}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += '{0}'.format(triple_quotes(snip))

write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet slotclass "class with slots and docstrings" b
class ${1:MyClass}(${2:object}):

	`!p snip.rv = triple_quotes(snip)`${3:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`
`!p
snip >> 1
args = get_args(t[4])
write_slots_args(args, snip)
`

	def __init__(self$4):
		`!p snip.rv = triple_quotes(snip)`${5:TODO: to be defined.}`!p
snip.rv = ""
snip >> 2

args = get_args(t[4])

write_docstring_args(args, snip)
if args:
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)

write_init_body(args, t[2], snip)
`
		$0
endsnippet


snippet dcl "dataclass" b
@dataclass
class ${1:MyClass}:
	`!p snip.rv = triple_quotes(snip)`${2:Docstring for $1. }`!p snip.rv = triple_quotes(snip)`
	${3:var_1}: ${4:int}
	${5:var_2}: ${6:float} = ${7:0}

	def ${8:total}(self): -> $6:
		return ${0:self.$3 * self.$5}
endsnippet


snippet contain "methods for emulating a container type" b
def __len__(self):
	${1:pass}

def __getitem__(self, key):
	${2:pass}

def __setitem__(self, key, value):
	${3:pass}

def __delitem__(self, key):
	${4:pass}

def __iter__(self):
	${5:pass}

def __reversed__(self):
	${6:pass}

def __contains__(self, item):
	${7:pass}
endsnippet


snippet context "context manager methods" b
def __enter__(self):
	${1:pass}

def __exit__(self, exc_type, exc_value, traceback):
	${2:pass}
endsnippet


snippet attr "methods for customizing attribute access" b
def __getattr__(self, name):
	${1:pass}

def __setattr__(self, name, value):
	${2:pass}

def __delattr__(self, name):
	${3:pass}
endsnippet


snippet desc "methods implementing descriptors" b
def __get__(self, instance, owner):
	${1:pass}

def __set__(self, instance, value):
	${2:pass}

def __delete__(self, instance):
	${3:pass}
endsnippet


snippet cmp "methods implementing rich comparison"
def __eq__(self, other):
	${1:pass}

def __ne__(self, other):
	${2:pass}

def __lt__(self, other):
	${3:pass}

def __le__(self, other):
	${4:pass}

def __gt__(self, other):
	${5:pass}

def __ge__(self, other):
	${6:pass}

def __cmp__(self, other):
	${7:pass}
endsnippet


snippet repr "methods implementing string representation"
def __repr__(self):
	${1:pass}

def __str__(self):
	${2:pass}

def __unicode__(self):
	${3:pass}
endsnippet


# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
def __add__(self, other):
	${1:pass}

def __sub__(self, other):
	${2:pass}

def __mul__(self, other):
	${3:pass}

def __div__(self, other):
	${4:pass}

def __truediv__(self, other):
	${5:pass}

def __floordiv__(self, other):
	${6:pass}


def __mod__(self, other):
	${7:pass}

def __divmod__(self, other):
	${8:pass}

def __pow__(self, other):
	${9:pass}


def __lshift__(self, other):
	${10:pass}

def __rshift__(self, other):
	${11:pass}

def __and__(self, other):
	${12:pass}

def __xor__(self, other):
	${13:pass}

def __or__(self, other):
	${14:pass}


def __neg__(self):
	${15:pass}

def __pos__(self):
	${16:pass}

def __abs__(self):
	${17:pass}

def __invert__(self):
	${18:pass}


def __complex__(self):
	${19:pass}

def __int__(self):
	${20:pass}

def __long__(self):
	${21:pass}

def __float__(self):
	${22:pass}


def __oct__(self):
	${22:pass}

def __hex__(self):
	${23:pass}


def __index__(self):
	${24:pass}

def __coerce__(self, other):
	${25:pass}
endsnippet

snippet deff "function or class method"
def ${1:fname}(`!p snip.rv = "self, " if snip.indent else ""`$2):
	$0
endsnippet

snippet def "function with docstrings" b
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'self' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defc "class method with docstrings" b
@classmethod
def ${1:function}(`!p
if snip.indent:
	snip.rv = 'cls' + (", " if len(t[2]) else "")`${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


snippet defs "static method with docstrings" b
@staticmethod
def ${1:function}(${2:arg1}):
	`!p snip.rv = triple_quotes(snip)`${4:TODO: Docstring for $1.}`!p
write_function_docstring(t, snip) `
	${5:${VISUAL:pass}}
endsnippet


# doesn't expand when there is a word in front
snippet /(^|(?<=\W))\./ "self." r
self.
endsnippet

snippet from "from module import name" b
from ${1:module} import ${2:Stuff}
endsnippet


##############
# PROPERTIES #
##############
snippet roprop "Read Only Property" b
@property
def ${1:name}(self):
	${2:return self._$1}$0
endsnippet

snippet rwprop "Read write property" b
def ${1:name}():
	`!p snip.rv = triple_quotes(snip) if t[2] else ''
`${2:TODO: Docstring for $1.}`!p
if t[2]:
	snip >> 1

	style = get_style(snip)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += format_return(style)
	snip.rv += '\n' + snip.mkline('', indent='')
	snip += triple_quotes(snip)
else:
	snip.rv = ""`
	def fget(self):
		return self._$1$0

	def fset(self, value):
		self._$1 = value
	return locals()

$1 = property(**$1(), doc=$1.__doc__)
endsnippet


############################
# If / Else / Elif / Match #
############################
snippet if "If" b
if ${1:condition}:
	${2:${VISUAL:pass}}
endsnippet

snippet ife "If / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
else:
	${3:pass}
endsnippet

snippet ifee "If / Elif / Else" b
if ${1:condition}:
	${2:${VISUAL:pass}}
elif ${3:condition}:
	${4:pass}
else:
	${5:pass}
endsnippet

snippet match "Structural pattern matching" b
match ${1:expression}:
	case ${2:pattern_1}:
		${3:pass}
	case ${4:pattern_2}:
		${0:pass}
endsnippet

snippet matchw "Pattern matching with wildcard" b
match ${1:expression}:
	case ${2:pattern_1}:
		${3:pass}
	case _:
		${0:pass}
endsnippet


##########################
# Try / Except / Finally #
##########################
snippet try "Try / Except" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
endsnippet

snippet trye "Try / Except / Else" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
else:
	${5:pass}
endsnippet

snippet tryf "Try / Except / Finally" b
try:
	${1:${VISUAL:pass}}
except ${2:Exception} as ${3:e}:
	${4:raise $3}
finally:
	${5:pass}
endsnippet

snippet tryef "Try / Except / Else / Finally" b
try:
	${1:${VISUAL:pass}}
except${2: ${3:Exception} as ${4:e}}:
	${5:raise}
else:
	${6:pass}
finally:
	${7:pass}
endsnippet


######################
# Assertions & Tests #
######################

snippet ae "Assert equal" b
self.assertEqual(${1:${VISUAL:first}}, ${2:second})
endsnippet

snippet at "Assert True" b
self.assertTrue(${1:${VISUAL:expression}})
endsnippet

snippet af "Assert False" b
self.assertFalse(${1:${VISUAL:expression}})
endsnippet

snippet aae "Assert almost equal" b
self.assertAlmostEqual(${1:${VISUAL:first}}, ${2:second})
endsnippet

snippet ar "Assert raises" b
self.assertRaises(${1:exception}, ${2:${VISUAL:func}}${3/.+/, /}${3:arguments})
endsnippet

snippet an "Assert is None" b
self.assertIsNone(${1:${VISUAL:expression}})
endsnippet

snippet ann "Assert is not None" b
self.assertIsNotNone(${1:${VISUAL:expression}})
endsnippet

snippet testcase "pyunit testcase" b
class Test${1:Class}(${2:unittest.TestCase}):

	`!p snip.rv = triple_quotes(snip)`${3:Test case docstring.}`!p snip.rv = triple_quotes(snip)`

	def setUp(self):
		${4:pass}

	def tearDown(self):
		${5:pass}

	def test_${6:name}(self):
		${7:${VISUAL:pass}}
endsnippet

snippet " "triple quoted string (double quotes)" b
"""
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, '"')`
endsnippet

snippet ' "triple quoted string (single quotes)" b
'''
${1:${VISUAL:doc}}
`!p triple_quotes_handle_trailing(snip, "'")`
endsnippet

snippet doc "doc block (triple quotes)"
`!p snip.rv = triple_quotes(snip)`
${1:${VISUAL:doc}}
`!p snip.rv = triple_quotes(snip)`
endsnippet

snippet pmdoc "pocoo style module doc string" b
# -*- coding: utf-8 -*-
"""
	`!p snip.rv = get_dir_and_file_name(snip)`
	`!p snip.rv = '~' * len(get_dir_and_file_name(snip))`

	${1:DESCRIPTION}

	:copyright: (c) `date +%Y` by ${2:YOUR_NAME}.
	:license: ${3:LICENSE_NAME}, see LICENSE for more details.
"""
$0
endsnippet

# vim:ft=snippets:
./UltiSnips/r.snippets	[[[1
191
priority -20

global !p
import os
from vimsnippets import complete

FIELD_TYPES = [
'character',
'data.frame',
'integer',
'list',
'logical',
'matrix',
'numeric',
'vector']
endglobal

snippet #! "#!/usr/bin/env Rscript" b
#!/usr/bin/env Rscript
$0
endsnippet

snippet setwd "Set workingdir" b
setwd("${1:`!p snip.rv = os.getcwd()`}")
endsnippet

snippet as "Apply type on variable" w
as.$1`!p snip.rv = complete(t[1], FIELD_TYPES)`($2${VISUAL})
endsnippet

snippet is "Test type on variable" w
is.$1`!p snip.rv = complete(t[1], FIELD_TYPES)`($2${VISUAL})
endsnippet

snippet dl "Download and install a package" b
download.file("${1:${VISUAL:url to package}}", destfile = "${2:${1/.*\/(\S*)$/(?1:$1)/ga}}")
install.packages("$2", type = "source", repos = NULL)
library("${3:${2/^(\w+)_.*$/(?1:$1)/ga}}")
endsnippet

snippet lib "Import a library"
library('${0:${VISUAL:package}}')
endsnippet

snippet req "Require a file"
require('${0:${VISUAL:package}}')
endsnippet

snippet source "Source a file"
source('${0:${VISUAL:file}}')
endsnippet

snippet if "If statement"
if ($1) {
	${0:${VISUAL}}
}
endsnippet

snippet eif "Else-If statement"
else if ($1) {
	${0:${VISUAL}}
}
endsnippet

snippet el "Else statement"
else {
	${0:${VISUAL}}
}
endsnippet

snippet ife "if .. else"
if ($1) {
	${2:${VISUAL}}
} else {
	$0
}
endsnippet

snippet wh "while loop"
while($1) {
	${0:${VISUAL}}
}
endsnippet

snippet for "for loop"
for (${1:item} in ${2:list}) {
	${0:${VISUAL}}
}
endsnippet

snippet fun "Function definition"
${1:name} <- function ($2) {
	${0:${VISUAL}}
}
endsnippet

snippet ret "Return call"
return(${0:${VISUAL}})
endsnippet

snippet df "Data frame"
${1:name}[${2:rows}, ${0:cols}]
endsnippet

snippet c "c function"
c(${0:${VISUAL:items}})
endsnippet

snippet li "list function"
list(${0:${VISUAL:items}})
endsnippet

snippet mat "matrix function"
matrix(${1:${VISUAL:data}}, nrow = ${2:rows}, ncol = ${0:cols})
endsnippet

snippet apply "apply function"
apply(${1:${VISUAL:array}}, ${2:margin}, ${0:function})
endsnippet

snippet lapply "lapply function"
lapply(${1:${VISUAL:list}}, ${0:function})
endsnippet

snippet sapply "sapply function"
sapply(${1:${VISUAL:list}}, ${0:function})
endsnippet

snippet vapply "vapply function"
vapply(${1:${VISUAL:list}}, ${2:function}, ${0:type})
endsnippet

snippet mapply "mapply function"
mapply(${1:${VISUAL:function}}, ${0:...})
endsnippet

snippet tapply "tapply function"
tapply(${1:${VISUAL:vector}}, ${2:index}, ${0:function})
endsnippet

snippet rapply "rapply function"
rapply(${1:${VISUAL:list}}, ${0:function})
endsnippet

snippet pl "Plot function"
plot(${1:${VISUAL:x}}, ${0:y})
endsnippet

snippet ggp "ggplot2 plot"
ggplot(${1:${VISUAL:data}}, aes(${0:aesthetics}))
endsnippet

snippet fis "Fisher test"
fisher.test(${1:x}, ${0:y})
endsnippet

snippet chi "Chi Squared test"
chisq.test(${1:x}, ${0:y})
endsnippet

snippet tt "t-test"
t.test(${1:x}, ${0:y})
endsnippet

snippet wil "Wilcox test"
wilcox.test(${1:x}, ${0:y})
endsnippet

snippet cor "Correlation test"
cor.test(${1:x}, ${0:y})
endsnippet

snippet fte "FTE test"
var.test(${1:x}, ${0:y})
endsnippet

snippet kvt "KV test"
kv.test(${1:x}, ${0:y})
endsnippet

#################################
#  easily create string vector  #
#################################
# Given individual words separated by spaces
# Select words (e.g. shift-v for whole line (such as the line above)
# then press <Tab> then type "vec", press <Tab> again to get this:
# var <- c("#","Given","individual","words","separated","by","spaces")
# var <- c("#","type","out","individual","words","separated","by","spaces")
snippet vec
${1:var} <- c("${0:${VISUAL:/ /","/g}}")
endsnippet
./UltiSnips/rails.snippets	[[[1
878
priority -50

snippet anaf "accepts_nested_attributes_for"
accepts_nested_attributes_for :${1:association_name}${2:${3:, allow_destroy: true}${4:, reject_if: proc \{ |obj| ${5:obj.blank?} \}}}

endsnippet

snippet tcbi "Create binary column"
t.binary :${1:title}${2:, limit: ${3:2}.megabytes}
$0
endsnippet

snippet tcb "Create boolean column"
t.boolean :${1:title}
$0
endsnippet

snippet clac "Create controller class"
class ${1:Model}Controller < ApplicationController
	before_action :find_${2:model}

	$0

	private
	def find_$2
		@$2 = ${3:$1}.find(params[:id]) if params[:id]
	end
end
endsnippet

snippet tcda "Create date column"
t.date :${1:title}
$0
endsnippet

snippet tcdt "Create datetime column"
t.datetime :${1:title}
$0
endsnippet

snippet tcd "Create decimal column"
t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}
$0
endsnippet

snippet tcf "Create float column"
t.float :${1:title}
$0
endsnippet

snippet clact "Create functional test class"
require 'test_helper'

class ${1:Model}ControllerTest < ActionController::TestCase
	test$0
end

endsnippet

snippet tci "Create integer column"
t.integer :${1:title}
$0
endsnippet

snippet tcl "Create lock_version column"
t.integer :lock_version, null: false, default: 0
$0
endsnippet

# FIXME: handling literal bracket pair inside of nested tab groups?
snippet tcr "Create references column"
t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}
$0
endsnippet

snippet resources "Create resources controller class"
class ${1:Model}sController < ApplicationController
	before_action :find_${1/./\l$0/}, only: [:show, :edit, :update, :destroy]

	# GET /${1/./\l$0/}s
	# GET /${1/./\l$0/}s.json
	def index
		@${1/./\l$0/}s = ${1:Model}.all

		respond_to do |wants|
			wants.html # index.html.erb
			wants.json  { render json: @${1/./\l$0/}s }
		end
	end

	# GET /${1/./\l$0/}s/1
	# GET /${1/./\l$0/}s/1.json
	def show
		respond_to do |wants|
			wants.html # show.html.erb
			wants.json  { render json: @${1/./\l$0/} }
		end
	end

	# GET /${1/./\l$0/}s/new
	# GET /${1/./\l$0/}s/new.json
	def new
		@${1/./\l$0/} = ${1:Model}.new

		respond_to do |wants|
			wants.html # new.html.erb
			wants.json  { render json: @${1/./\l$0/} }
		end
	end

	# GET /${1/./\l$0/}s/1/edit
	def edit
	end

	# POST /${1/./\l$0/}s
	# POST /${1/./\l$0/}s.json
	def create
		@${1/./\l$0/} = ${1:Model}.new(params[:${1/./\l$0/}])

		respond_to do |wants|
			if @${1/./\l$0/}.save
				flash[:notice] = '${1:Model} was successfully created.'
				wants.html { redirect_to(@${1/./\l$0/}) }
				wants.json  { render json: @${1/./\l$0/}, status: :created, location: @${1/./\l$0/} }
			else
				wants.html { render action: "new" }
				wants.json  { render json: @${1/./\l$0/}.errors, status: :unprocessable_entity }
			end
		end
	end

	# PUT /${1/./\l$0/}s/1
	# PUT /${1/./\l$0/}s/1.json
	def update
		respond_to do |wants|
			if @${1/./\l$0/}.update(params[:${1/./\l$0/}])
				flash[:notice] = '${1:Model} was successfully updated.'
				wants.html { redirect_to(@${1/./\l$0/}) }
				wants.json  { head :ok }
			else
				wants.html { render action: "edit" }
				wants.json  { render json: @${1/./\l$0/}.errors, status: :unprocessable_entity }
			end
		end
	end

	# DELETE /${1/./\l$0/}s/1
	# DELETE /${1/./\l$0/}s/1.json
	def destroy
		@${1/./\l$0/}.destroy

		respond_to do |wants|
			wants.html { redirect_to(${1/./\l$0/}s_url) }
			wants.json  { head :ok }
		end
	end

	private
		def find_${1/./\l$0/}
			@${1/./\l$0/} = ${1:Model}.find(params[:id])
		end

end

endsnippet

snippet tcs "Create string column"
t.string :${1:title}
$0
endsnippet

snippet tct "Create text column"
t.text :${1:title}
$0
endsnippet

snippet tcti "Create time column"
t.time :${1:title}
$0
endsnippet

snippet tcts "Create timestamp column"
t.timestamp :${1:title}
$0
endsnippet

snippet tctss "Create timestamps columns"
t.timestamps
$0
endsnippet

snippet mcol "Migration Create Column (mcc)"
t.column ${1:title}, :${2:string}
$0
endsnippet

snippet mccc "Migration Create Column Continue (mccc)"
t.column ${1:title}, :${2:string}
mccc$0
endsnippet

snippet mtab "Migration Drop Create Table (mdct)"
drop_table :${1:table}${2: [press tab twice to generate create_table]}
endsnippet

snippet mcol "Migration Remove and Add Column (mrac)"
remove_column :${1:table}, :${2:column}${3: [press tab twice to generate add_column]}
endsnippet

snippet rdb "RAILS_DEFAULT_LOGGER.debug (rdb)"
RAILS_DEFAULT_LOGGER.debug "${1:message}"$0
endsnippet

snippet tre "Table column(s) rename"
t.rename(:${1:old_column_name}, :${2:new_column_name})
$0
endsnippet

snippet art "Test Assert Redirected To (art)"
assert_redirected_to ${2:action: "${1:index}"}
endsnippet

snippet asre "Test Assert Response (are)"
assert_response :${1:success}, @response.body$0
endsnippet

snippet aftc "after_create"
after_create $0
endsnippet

snippet aftd "after_destroy"
after_destroy $0
endsnippet

snippet afts "after_save"
after_save $0
endsnippet

snippet aftu "after_update"
after_update $0
endsnippet

snippet aftv "after_validation"
after_validation $0
endsnippet

snippet aftvoc "after_validation_on_create"
after_validation_on_create $0
endsnippet

snippet aftvou "after_validation_on_update"
after_validation_on_update $0
endsnippet

snippet asg "assert(var = assigns(:var))"
assert(${1:var} = assigns(:$1), "Cannot find @$1")
$0
endsnippet

snippet asd "assert_difference"
assert_difference "${1:Model}.${2:count}", ${3:1} do
	$0
end
endsnippet

snippet asnd "assert_no_difference"
assert_no_difference "${1:Model}.${2:count}" do
	$0
end
endsnippet

snippet artnpp "assert_redirected_to (nested path plural)"
assert_redirected_to ${10:${2:parent}_${3:child}_path(${4:@}${5:$2})}
endsnippet

snippet artnp "assert_redirected_to (nested path)"
assert_redirected_to ${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})}
endsnippet

snippet artpp "assert_redirected_to (path plural)"
assert_redirected_to ${10:${2:model}s_path}
endsnippet

snippet artp "assert_redirected_to (path)"
assert_redirected_to ${2:${12:model}_path(${13:@}${14:$12})}
endsnippet

snippet asrj "assert_rjs"
assert_rjs :${1:replace}, ${2:"${3:dom id}"}
endsnippet

snippet ass "assert_select"
assert_select '${1:path}'${2:, ${3:text}: ${4:'${5:inner_html}'}}${6: do
	$0
end}
endsnippet

snippet befc "before_create"
before_create $0
endsnippet

snippet befd "before_destroy"
before_destroy $0
endsnippet

snippet befs "before_save"
before_save $0
endsnippet

snippet befu "before_update"
before_update $0
endsnippet

snippet befv "before_validation"
before_validation $0
endsnippet

snippet befvoc "before_validation_on_create"
before_validation_on_create $0
endsnippet

snippet befvou "before_validation_on_update"
before_validation_on_update
endsnippet

snippet bt "belongs_to (bt)"
belongs_to :${1:object}${2:, class_name: "${3:${1/[[:alpha:]]+|(_)/(?1::\u$0)/g}}", foreign_key: "${4:$1_id}"}
endsnippet

snippet crw "cattr_accessor"
cattr_accessor :${0:attr_names}
endsnippet

snippet defcreate "def create - resource"
def create
	@${1:model} = ${2:${1/[[:alpha:]]+|(_)/(?1::\u$0)/g}}.new(params[:$1])
	$0
	respond_to do |wants|
		if @$1.save
			flash[:notice] = '$2 was successfully created.'
			wants.html { redirect_to(@$1) }
			wants.json { render json: @$1, status: :created, location: @$1 }
		else
			wants.html { render action: "new" }
			wants.json { render json: @$1.errors, status: :unprocessable_entity }
		end
	end
end

endsnippet

snippet test "test do..end"
test "${1:something interesting}" do
	$0
end
endsnippet

snippet deftg "def get request"
def test_should_get_${1:action}
	${2:@${3:model} = ${4:$3s}(:${5:fixture_name})
	}get :$1${6:, id: @$3.to_param}
	assert_response :success
	$0
end
endsnippet

snippet deftp "def post request"
def test_should_post_${1:action}
	${3:@$2 = ${4:$2s}(:${5:fixture_name})
	}post :$1${6:, id: @$2.to_param}, ${2:model}: { $0 }
	assert_response :redirect

end
endsnippet

snippet fina "find(:all)"
find(:all${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})
endsnippet

snippet finf "find(:first)"
find(:first${1:, conditions: ['${2:${3:field} = ?}', ${5:true}]})
endsnippet

snippet fini "find(id)"
find(${1:id})
endsnippet

snippet fine "find_each"
find_each(${1conditions: {:${2:field}: ${3:true}\}}) do |${4:${TM_CURRENT_WORD/(\w+)\./\L$1/g}}|
	$0
end
endsnippet

snippet finb "find_in_batches"
find_in_batches(${1conditions: {:${2:field}: ${3:true}\}}) do |${4:${TM_CURRENT_WORD/(\w+)\./\L$1/g}}s|
	$4s.each do |$4|
		$0
	end
end
endsnippet

snippet habtm "has_and_belongs_to_many (habtm)"
has_and_belongs_to_many :${1:object}${2:, join_table: "${3:table_name}", foreign_key: "${4:$1_id}"}
endsnippet

snippet hm "has_many (hm)"
has_many :${1:object}s${2:, class_name: "$1", foreign_key: "${4:reference}_id"}
endsnippet

snippet hmt "has_many (through)"
has_many :${1:objects}, through: :${2:join_association}${3:, source: :${4:$2_table_foreign_key_to_$1_table}}
endsnippet

snippet hmd "has_many dependent: :destroy"
has_many :${1:object}s${2:, class_name: "$1", foreign_key: "${4:reference}_id"}, dependent: :destroy$0
endsnippet

snippet ho "has_one (ho)"
has_one :${1:object}${2:, class_name: "${3:${1/[[:alpha:]]+|(_)/(?1::\u$0)/g}}", foreign_key: "${4:$1_id}"}
endsnippet

snippet logd "logger.debug"
${1:Rails.}logger.debug { "${1:message}" }$0
endsnippet

snippet loge "logger.error"
logger.error { "${1:message}" }$0
endsnippet

snippet logf "logger.fatal"
logger.fatal { "${1:message}" }$0
endsnippet

snippet logi "logger.info"
logger.info { "${1:message}" }$0
endsnippet

snippet logw "logger.warn"
logger.warn { "${1:message}" }$0
endsnippet

snippet mp "map(&:sym_proc)"
map(&:${1:id})
endsnippet

snippet mapca "map.catch_all"
${1:map}.catch_all "*${2:anything}", controller: "${3:default}", action: "${4:error}"

endsnippet

snippet map "map.named_route"
${1:map}.${2:connect} '${3::controller/:action/:id}'
endsnippet

snippet mapr "map.resource"
${1:map}.resource :${2:resource}${10: do |${11:$2}|
	$0
end}
endsnippet

snippet maprs "map.resources"
${1:map}.resources :${2:resource}${10: do |${11:$2}|
	$0
end}
endsnippet

snippet mapwo "map.with_options"
${1map}.with_options :${2:controller}: '${3:thing}' do |${4:$3}|
	$0
end

endsnippet

snippet mrw "mattr_accessor"
mattr_accessor :${0:attr_names}
endsnippet

snippet ncl "named_scope lambda"
named_scope :name, lambda { |${1param}| { :conditions: ${3:['${4:${5:field} = ?}', ${6:$1}]} } }

endsnippet

snippet nc "named_scope"
named_scope :name${1:, joins: :${2:table}}, conditions: ${3:['${4:${5:field} = ?}', ${6:true}]}

endsnippet

snippet dscope "default_scope"
default_scope ${1:order(${2:'${3:created_at DESC}'})}
endsnippet

snippet flash "flash[...]"
flash[:${1:notice}] = "${2:Successfully created...}"$0
endsnippet

snippet rea "redirect_to (action)"
redirect_to action: "${1:index}"
endsnippet

snippet reai "redirect_to (action, id)"
redirect_to action: "${1:show}", id: ${0:@item}
endsnippet

snippet rec "redirect_to (controller)"
redirect_to controller: "${1:items}"
endsnippet

snippet reca "redirect_to (controller, action)"
redirect_to controller: "${1:items}", action: "${2:list}"
endsnippet

snippet recai "redirect_to (controller, action, id)"
redirect_to controller: "${1:items}", action: "${2:show}", id: ${0:@item}
endsnippet

snippet renpp "redirect_to (nested path plural)"
redirect_to(${2:${10:parent}_${11:child}_path(${12:@}${13:$10})})
endsnippet

snippet renp "redirect_to (nested path)"
redirect_to(${2:${12:parent}_${13:child}_path(${14:@}${15:$12}, ${16:@}${17:$13})})
endsnippet

snippet repp "redirect_to (path plural)"
redirect_to(${2:${10:model}s_path})
endsnippet

snippet rep "redirect_to (path)"
redirect_to(${2:${12:model}_path(${13:@}${14:$12})})
endsnippet

snippet reb "redirect_to :back"
redirect_to :back
endsnippet

snippet ra "render (action)... (ra)"
render action: "${1:action}"
endsnippet

snippet ral "render (action,layout) (ral)"
render action: "${1:action}", layout: "${2:layoutname}"
endsnippet

snippet rf "render (file) (rf)"
render file: "${1:filepath}"
endsnippet

snippet rfu "render (file,use_full_path) (rfu)"
render file: "${1:filepath}", use_full_path: ${2:false}
endsnippet

snippet ri "render (inline) (ri)"
render inline: "${1:<%= 'hello' %>}"
endsnippet

snippet ril "render (inline,locals) (ril)"
render inline: "${1:<%= 'hello' %>}", locals { ${2::name}: "${3:value}"$4 }
endsnippet

snippet rit "render (inline,type) (rit)"
render inline: "${1:<%= 'hello' %>}", type: ${2::rjson}
endsnippet

snippet rl "render (layout) (rl)"
render layout: "${1:layoutname}"
endsnippet

snippet rn "render (nothing) (rn)"
render nothing: ${1:true}
endsnippet

snippet rns "render (nothing,status) (rns)"
render nothing: ${1:true}, status: ${2:401}
endsnippet

snippet rt "render (text) (rt)"
render text: "${1:text to render...}"
endsnippet

snippet rtl "render (text,layout) (rtl)"
render text: "${1:text to render...}", layout: "${2:layoutname}"
endsnippet

snippet rtlt "render (text,layout => true) (rtlt)"
render text: "${1:text to render...}", layout: ${2:true}
endsnippet

snippet rts "render (text,status) (rts)"
render text: "${1:text to render...}", status: ${2:401}
endsnippet

snippet ru "render (update)"
render :update do |${2:page}|
	$2.$0
end
endsnippet

snippet rest "respond_to"
respond_to do |wants|
	wants.${1:html}${2: { $0 }}
end
endsnippet

# FIXME
snippet returning "returning do |variable| ... end"
returning ${1:variable} do${2/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1: |)/}${2:v}${2/(^(?<var>\s*[a-z_][a-zA-Z0-9_]*\s*)(,\g<var>)*,?\s*$)|.*/(?1:|)/}
	$0
end
endsnippet

snippet cmm "Create Migration Model Class"
class Migration${1/(?:^|_)(\w)/\u$1/g} < ApplicationRecord
	self.table_name = :${1:model_name}s
end
endsnippet

snippet t. "t.binary (tcbi)"
t.binary :${1:title}${2:, limit: ${3:2}.megabytes}
t.$0
endsnippet

snippet t. "t.boolean (tcb)"
t.boolean :${1:title}
t.$0
endsnippet

snippet t. "t.date (tcda)"
t.date :${1:title}
t.$0
endsnippet

snippet t. "t.datetime (tcdt)"
t.datetime :${1:title}
t.$0
endsnippet

snippet t. "t.decimal (tcd)"
t.decimal :${1:title}${2:${3:, precision: ${4:10}}${5:, scale: ${6:2}}}
t.$0
endsnippet

snippet t. "t.float (tcf)"
t.float :${1:title}
t.$0
endsnippet

snippet t. "t.integer (tci)"
t.integer :${1:title}
t.$0
endsnippet

snippet t. "t.lock_version (tcl)"
t.integer :lock_version, null: false, default: 0
t.$0
endsnippet

snippet t. "t.references (tcr)"
t.references :${1:taggable}${2:, polymorphic: ${3:{ default: '${4:Photo}' }}}
t.$0
endsnippet

snippet t. "t.rename (tre)"
t.rename(:${1:old_column_name}, :${2:new_column_name})
t.$0
endsnippet

snippet t. "t.string (tcs)"
t.string :${1:title}
t.$0
endsnippet

snippet t. "t.text (tct)"
t.text :${1:title}
t.$0
endsnippet

snippet t. "t.time (tcti)"
t.time :${1:title}
t.$0
endsnippet

snippet t. "t.timestamp (tcts)"
t.timestamp :${1:title}
t.$0
endsnippet

snippet t. "t.timestamps (tctss)"
t.timestamps
t.$0
endsnippet

snippet vaoif "validates_acceptance_of if"
validates_acceptance_of :${1:terms}${2:${3:, accept: "${4:1}"}${5:, message: "${6:You must accept the terms of service}"}}, if: proc { |obj| ${7:obj.condition?} }}
endsnippet

snippet vao "validates_acceptance_of"
validates :${1:terms}${2:, acceptance: ${3:{ accept: "${4:1}"${5:, message: "${6:You must accept the terms of service}"}}} }
endsnippet

snippet va "validates_associated (va)"
validates_associated :${1:attribute}${2:, on: :${3:create}}
endsnippet

snippet vaif "validates_associated if (vaif)"
validates_associated :${1:attribute}${2:, on: :${3:create}, if: proc { |obj| ${5:obj.condition?} }}
endsnippet

snippet vc "validates_confirmation_of (vc)"
validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: "${4:should match confirmation}"}
endsnippet

snippet vcif "validates_confirmation_of if (vcif)"
validates_confirmation_of :${1:attribute}${2:, on: :${3:create}, message: "${4:should match confirmation}", if: proc { |obj| ${5:obj.condition?} }}
endsnippet

snippet ve "validates_exclusion_of (ve)"
validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: "${6:extension %s is not allowed}"}
endsnippet

snippet veif "validates_exclusion_of if (veif)"
validates_exclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: "${6:extension %s is not allowed}"}, if: proc { |obj| ${7:obj.condition?} }}
endsnippet

snippet vfif "validates_format_of if"
validates_format_of :${1:attribute}, with: /${2:^[${3:\w\d}]+\$}/${4:, on: :${5:create}, message: "${6:is invalid}"}, if: proc { |obj| ${7:obj.condition?} }}
endsnippet

snippet vf "validates_format_of"
validates_format_of :${1:attribute}, with: /${2:^[${3:\w\d}]+\$}/${4:, on: :${5:create}, message: "${6:is invalid}"}
endsnippet

snippet viif "validates_inclusion_of if"
validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: "${6:extension %s is not included in the list}"}, if: proc { |obj| ${7:obj.condition?} }}
endsnippet

snippet vi "validates_inclusion_of"
validates_inclusion_of :${1:attribute}${2:, in: ${3:%w( ${4:mov avi} )}, on: :${5:create}, message: "${6:extension %s is not included in the list}"}
endsnippet

snippet vl "validates_length_of (vl)"
validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: "${5:must be present}"}
endsnippet

snippet vlif "validates_length_of if"
validates_length_of :${1:attribute}, within: ${2:3..20}${3:, on: :${4:create}, message: "${5:must be present}"}, if: proc { |obj| ${6:obj.condition?} }}
endsnippet

snippet vnif "validates_numericality_of if"
validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: "${4:is not a number}"}, if: proc { |obj| ${5:obj.condition?} }}
endsnippet

snippet vn "validates_numericality_of"
validates_numericality_of :${1:attribute}${2:, on: :${3:create}, message: "${4:is not a number}"}
endsnippet

snippet vp "validates_presence_of (vp)"
validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: "${4:can't be blank}"}
endsnippet

snippet vpif "validates_presence_of if (vpif) 2"
validates_presence_of :${1:attribute}${2:, on: :${3:create}, message: "${4:can't be blank}"}, if: proc { |obj| ${5:obj.condition?} }}
endsnippet

snippet vu "validates_uniqueness_of (vu)"
validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: "${4:must be unique}"}
endsnippet

snippet vuif "validates_uniqueness_of if (vuif)"
validates_uniqueness_of :${1:attribute}${2:, on: :${3:create}, message: "${4:must be unique}", if: proc { |obj| ${6:obj.condition?} }}
endsnippet

snippet verify "verify -- render"
verify only: [:$1], method: :post, render {:status: 500, text: "use HTTP-POST"}

endsnippet

snippet verify "verify -- redirect"
verify only: [:$1], session: :user, params: :id, redirect_to {:action: '${2:index}'}

endsnippet

snippet wants "wants_format"
wants.${1:js|json|html}${2: { $0 }}
endsnippet

snippet xdelete "xhr delete"
xhr :delete, :${1:destroy}, id: ${2:1}$0
endsnippet

snippet xget "xhr get"
xhr :get, :${1:show}${2:, id: ${3:1}}$0
endsnippet

snippet xpost "xhr post"
xhr :post, :${1:create}, ${2:object}: { $3 }
endsnippet

snippet xput "xhr put"
xhr :put, :${1:update}, id: ${2:1}, ${3:object}: { $4 }$0
endsnippet

snippet col "collection routes"
collection do
	${1:get :${2:action}}
	${3:put :${4:action}}
	${5:post :${6:action}}
	${7:delete :${8:action}}
end
endsnippet

snippet format "format (respond_with)"
format.${1:html|xml|json|js|any} { $0 }
endsnippet

snippet gem "gem"
gem '${1:name}'${2:${3:, "${4:1.0}"}${5:${6:, require: ${7:"${8:$1}"}}${9:, group: :${10:test}}}}
endsnippet

snippet gemg "gem :git"
gem '${1:paperclip}', git: "${2:git://github.com/thoughtbot/paperclip.git}"${3:, branch: "${4:rails3}"}
endsnippet

snippet match "match"
match '${1:${2::controller}${3:/${4::action}${5:/${6::id}${7:(.:format)}}}}'${8: '${9:$2}#${10:$4}'${11:, as: :${12:$10}}}
endsnippet

snippet member "member routes"
member do
	${1:get :${2:action}}
	${3:put :${4:action}}
	${5:post :${6:action}}
	${7:delete :${8:action}}
end
endsnippet

snippet res "resources"
resources :${1:posts}${2: do
	$3
end}
endsnippet

snippet scope "scope"
scope :${1:name}, { ${2:joins(:${3:table}).}where(${4:'${5:$3.${6:field}} = ?', ${7:'${8:value}'}}) }
endsnippet

snippet scopel "scope lambda"
scope :${1:name}, lambda { |${2:param}| ${3:where(${4::${5:field}: ${6:"${7:value}"}})} }
endsnippet

snippet scopee "scope with extension"
scope :${1:name}, { ${2:where(${3::${4:field}: ${5:'${6:value}'}})} } do
	def ${7:method_name}
		$0
	end
end
endsnippet

snippet sb "scoped_by"
scoped_by_${1:attribute}(${2:id})
endsnippet

snippet setup "setup do..end"
setup do
	$0
end
endsnippet

snippet trans "Translation snippet"
I18n.t('`!v substitute(substitute(substitute(@%, substitute(getcwd() . "/", "\/", "\\\\/", "g"), "", ""), "\\(\\.\\(html\\|js\\)\\.\\(haml\\|erb\\)\\|\\(_controller\\)\\?\\.rb\\)$", "", ""), "/", ".", "g")`.${2:${1/[^\w]/_/g}}$3', default: "${1:some_text}"$4)${5:$0}
endsnippet

snippet route_spec
it 'routes to #${1:action}' do
	${2:get}('/${3:url}').should route_to('`!v substitute(expand('%:t:r'), '_routing_spec$', '', '')`#$1'${4:, ${5:params}})$6
end
endsnippet

# vim:ft=snippets:
./UltiSnips/rnoweb.snippets	[[[1
3
priority -50

extends tex, r
./UltiSnips/robot.snippets	[[[1
355
##############################################################################
#                   Robot Framework Snippets for UltiSnips                   #
##############################################################################

priority -50

######################
#  Built In library  #
######################
snippet cat "Catenate"
\${${1:name}}=    Catenate    SEPARATOR=${2:---}    ${3:Hello}    ${4:world}
endsnippet

snippet eval "Evaluate"
\${${1:val}}=    Evaluate    ${2:${x} - 10}
endsnippet

snippet for "FOR loop" b
:FOR    ${${1:element}}    IN    ${2:@{ELEMENTS}}
\    ${0:${VISUAL:Start Element}}    ${$1}
endsnippet

snippet nop "No Operation"
No Operation
endsnippet

snippet rfk "Return From Keyword"
Return From Keyword    ${1:${optional return value}}
endsnippet

snippet rfki "Return From Keyword If"
Return From Keyword If    '\${${1:rc}}' != '${2:abc}'    ${3:${optional return value}}
endsnippet

snippet rk "Run Keyword"
Run Keyword    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkacof "Run Keyword And Continue On Failure"
Run Keyword And Continue On Failure    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkaee "Run Keyword And Expect Error"
Run Keyword And Expect Error    ${1:My error}    ${2:${kw}}    ${3:${args}}
endsnippet

snippet rkaie "Run Keyword And Ignore Error"
Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}
\${${3:result}}    \${${4:return_value}}=    Run Keyword And Ignore Error    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkar "Run Keyword And Return"
Run Keyword And Return    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkari "Run Keyword And Return If"
Run Keyword And Return If    '\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}
endsnippet

snippet rkars "Run Keyword And Return Status"
\${${3:result}}=    Run Keyword And Return Status    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rki "Run Keyword If"
Run Keyword If    '\${${1:rc}}' != '${2:abc}'
...               ${3:${VISUAL:Some keyword returning a value}}
...    ELSE IF    '\${${4:str}}' != '${5:def}'
...               ${6:Another keyword}
...    ELSE
...               ${7:Final keyword}
endsnippet

snippet rkiactf "Run Keyword If Any Critical Tests Failed"
Run Keyword If Any Critical Tests Failed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkiactp "Run Keyword If All Critical Tests Passed"
Run Keyword If All Critical Tests Passed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkiatf "Run Keyword If Any Tests Failed"
Run Keyword If Any Tests Failed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkiatp "Run Keyword If All Tests Passed"
Run Keyword If All Tests Passed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkitf "Run Keyword If Test Failed"
Run Keyword If Test Failed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkitp "Run Keyword If Test Passed"
Run Keyword If Test Passed    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rkito "Run Keyword If Timeout Occurred"
Run Keyword If Timeout Occurred    ${1:${kw}}    ${2:${args}}
endsnippet

snippet rks "Run Keywords"
Run Keywords
...    ${1:${VISUAL:Initialize database    $\{DB NAME\}}}    AND
...    ${2:Clear logs}
endsnippet

snippet rku "Run Keyword Unless"
Run Keyword Unless    '\${${1:rc}}' != '${2:abc}'    ${3:${kw}}    ${4:${args}}
endsnippet

snippet sgv "Set Global Variable"
Set Global Variable    \${${1:name}}    ${2:${value}}
endsnippet

snippet sbe "Should Be Equal"
Should Be Equal    "\${${1:var}}"    "${2:expected value}"    ${3:"optional error msg"}	${4:ignore_case=True}
endsnippet

snippet sleep "Sleep"
Sleep    ${1:2 minutes 10 seconds}
endsnippet

snippet ssv "Set Suite Variable"
Set Suite Variable    \${${1:name}}    ${2:${value}}
endsnippet

snippet stv "Set Test Variable"
Set Test Variable    \${${1:name}}    ${2:${value}}
endsnippet

snippet sv "Set Variable"
\${${1:name}}=    Set Variable    ${2:${value}}
endsnippet

snippet svi "Set Variable If"
\${${1:var}}=    Set Variable If    '\${${2:rc}}' != '${3:abc}'
`!p snip.rv = '...' + ' ' * (len(t[1]) + 23)` ${4:${value true}}
`!p snip.rv = '...' + ' ' * (len(t[1]) + 23)` ${5:${value false}}
endsnippet

snippet wuks "Wait Until Keyword Succeeds"
Wait Until Keyword Succeeds    ${1:10x}    ${2:2s}    ${3:${VISUAL:Some Keyword}}
endsnippet


#####################
#  Dialogs library  #
#####################
snippet pause "Pause test execution"
Import library    Dialogs
Pause execution
endsnippet

snippet tpause "Teardown Pause - pause test execution only on failure"
[Teardown]    Run Keyword If Test Failed    Run Keywords
...    Import library    Dialogs    AND
...    Pause execution
endsnippet


##############################
#  Selenium2Library library  #
##############################
snippet cps "Capture Page Screenshot"
Capture Page Screenshot    ${1:${optional filename}}
endsnippet

snippet esbd "Element Should Be Disabled"
Element Should Be Disabled    \${${1:locator}}
endsnippet

snippet esbe "Element Should Be Enabled"
Element Should Be Enabled    ${${1:locator}}
endsnippet

snippet esbf "Element Should Be Focused"
Element Should Be Focused    ${${1:locator}}
endsnippet

snippet esbv "Element Should Be Visible"
Element Should Be Visible    ${${1:locator}}    ${2:${optional message}}
endsnippet

snippet esc "Element Should Contain"
Element Should Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}
endsnippet

snippet esnbv "Element Should Not Be Visible"
Element Should Not Be Visible    ${${1:locator}}    ${2:${optional message}}
endsnippet

snippet esnc "Element Should Not Contain"
Element Should Not Contain    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}
endsnippet

snippet etsb "Element Text Should Be"
Element Text Should Be    ${${1:locator}}    ${2:${expected}}    ${3:${optional message}}
endsnippet

snippet eaj "Execute Async Javascript"
Execute Async Javascript    ${1:${code line 1}}    ${2:${code line 2}}
endsnippet

snippet ej "Execute Javascript"
Execute Javascript    ${1:${code line 1}}    ${2:${code line 2}}
endsnippet

snippet gwp "Get Window Position"
\${${1:x}}    \${${2:y}}=    Get Window Position
endsnippet

snippet gws "Get Window Size"
\${${1:width}}    \${${2:height}}=    Get Window Size
endsnippet

snippet mbw "Maximize Browser Window"
Maximize Browser Window
endsnippet

snippet md "Mouse Down"
Mouse Down    ${${1:locator}}
endsnippet

snippet mdoi "Mouse Down On Image"
Mouse Down On Image    ${1:${locator}}
endsnippet

snippet mdol "Mouse Down On Link"
Mouse Down On Link    ${1:${locator}}
endsnippet

snippet mout "Mouse Out"
Mouse Out    ${1:${locator}}
endsnippet

snippet mover "Mouse Over"
Mouse Over    ${1:${locator}}
endsnippet

snippet mu "Mouse Up"
Mouse Up    ${1:${locator}}
endsnippet

snippet ob "Open Browser"
Open Browser    ${1:${url}}    ${2:${browser=firefox}}    ${3:${alias=None}}    ${4:${remote_url=False}}    ${5:${desired_capabilities=None}}    ${6:${ff_profile_dir=None}}
endsnippet

snippet ocm "Open Context Menu"
Open Context Menu    ${1:${locator}}
endsnippet

snippet psc "Page Should Contain"
Page Should Contain    ${1:${text}}    ${2:loglevel=INFO}
endsnippet

snippet pscb "Page Should Contain Button"
Page Should Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet pscc "Page Should Contain Checkbox"
Page Should Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psce "Page Should Contain Element"
Page Should Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psci "Page Should Contain Image"
Page Should Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet pscl "Page Should Contain Link"
Page Should Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet pscrb "Page Should Contain Radio Button"
Page Should Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psct "Page Should Contain Textfield"
Page Should Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psnc "Page Should Not Contain"
Page Should Not Contain    ${1:${text}}    ${2:loglevel=INFO}
endsnippet

snippet psncb "Page Should Not Contain Button"
Page Should Not Contain Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psncc "Page Should Not Contain Checkbox"
Page Should Not Contain Checkbox    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psnce "Page Should Not Contain Element"
Page Should Not Contain Element    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psnci "Page Should Not Contain Image"
Page Should Not Contain Image    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psncl "Page Should Not Contain Link"
Page Should Not Contain Link    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psncrb "Page Should Not Contain Radio Button"
Page Should Not Contain Radio Button    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet psnct "Page Should Not Contain Textfield"
Page Should Not Contain Textfield    ${1:${locator}}    ${2:${message=}}    ${3:loglevel=INFO}
endsnippet

snippet rktrof "Register Keyword To Run On Failure"
Register Keyword To Run On Failure    ${1:${kw}}
endsnippet

snippet wuec "Wait Until Element Contains"
Wait Until Element Contains    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}
endsnippet

snippet wuednc "Wait Until Element Does Not Contain"
Wait Until Element Does Not Contain    ${1:${locator}}    ${2:${text}}    ${3:${timeout=None}}    ${4:${error=None}}
endsnippet

snippet wueie "Wait Until Element Is Enabled"
Wait Until Element Is Enabled    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wueinv "Wait Until Element Is Not Visible"
Wait Until Element Is Not Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wueiv "Wait Until Element Is Visible"
Wait Until Element Is Visible    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wupc "Wait Until Page Contains"
Wait Until Page Contains    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wupce "Wait Until Page Contains Element"
Wait Until Page Contains Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wupdnc "Wait Until Page Does Not Contain"
Wait Until Page Does Not Contain    ${1:${text}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

snippet wupdnce "Wait Until Page Does Not Contain Element"
Wait Until Page Does Not Contain Element    ${1:${locator}}    ${2:${timeout=None}}    ${3:${error=None}}
endsnippet

./UltiSnips/rst.snippets	[[[1
311
# -*- coding: utf-8 -*-

priority -50

###########################################################################
#							   General Stuff							  #
###########################################################################
global !p
from collections import Counter
from vimsnippets import complete, has_cjk, display_width

# http://docutils.sourceforge.net/docs/ref/rst/roles.html
TEXT_ROLES = ['emphasis', 'literal', 'code', 'math',
			  'pep-reference', 'rfc-reference',
			  'strong', 'subscript', 'superscript',
			  'title-reference', 'raw']
TEXT_ROLES_REGEX = r'\.\.\srole::?\s(w+)'

# http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
SPECIFIC_ADMONITIONS = ["attention", "caution", "danger",
						"error", "hint", "important", "note",
						"tip", "warning"]
# http://docutils.sourceforge.net/docs/ref/rst/directives.html
DIRECTIVES = ['code', 'contents', 'admonition', 'table', 'csv-table', 'list-table',
			  'class', 'container', 'sidebar', 'topic', 'title',
			  'role', 'default-role', 'raw']

# DIRECTIVES_WITHOUT_TITLE means directive arguments equal None
DIRECTIVES_WITHOUT_TITLE = ['math', 'meta', 'parsed-literal', 'line-block',
							'header', 'compound', 'highlights', 'pull-quote',
							'footer', 'epigraph', 'rubric', 'sectnum']

INCLUDABLE_DIRECTIVES = ['image', 'figure', 'include']

# Directives for Subsubsection Definition
DIRECTIVES_FOR_SUBSTITUTION = ['replace', 'unicode', 'date']

# http://www.pygal.org/en/stable/documentation/types/index.html
CHART_TYPES = ["Line", "StackedLine", "HorizontalLine", "Bar", "StackedBar", "HorizontalBar", "Histogram", "XY", "DateLine", "TimeLine", "TimeDeltaLine", "DateTimeLine", "Pie", "Radar", "Box", "Dot", "Funnel", "Gauge", "SolidGauge", "Pyramid", "Treemap"]

def real_filename(filename):
	"""pealeextension name off if possible
	# i.e. "foo.bar.png will return "foo.bar"
	"""
	return os.path.splitext(filename)[0]

def check_file_exist(rst_path, relative_path):
	"""
	For RST file, it can just include files as relative path.

	:param rst_path: absolute path to rst file
	:param relative_path: path related to rst file
	:return: relative file's absolute path if file exist
	"""
	abs_path = os.path.join(os.path.dirname(rst_path), relative_path)
	if os.path.isfile(abs_path):
		return abs_path

def	make_items(times, leading='+'):
	"""
	make lines with leading char multitimes

	:param: times, how many times you need
	:param: leading, leading character
	"""
	times = int(times)
	if leading == 1:
		msg = ""
		for x in range(1, times+1):
			msg += "%s. Item\n" % x
		return msg
	else:
		return ("%s Item\n" % leading) * times


def look_up_directives(regex, fpath):
	"""
	find all directive args in given file
	:param: regex, the regex that needs to match
	:param: path, to path to rst file

	:return: list, empty list if nothing match
	"""
	try:
		with open(fpath) as source:
			match = re.findall(regex, source.read())
	except IOError:
		match = []
	return match


def get_popular_code_type():
	"""
	find most popular code type in the given rst

	:param path: file to detect

	:return: string, most popular code type in file
	"""
	buf = "".join(vim.current.buffer)
	types = re.findall(r'[:|\.\.\s]code::?\s(\w+)', buf)
	try:
		popular_type = Counter(types).most_common()[0][0]
	except IndexError:
		popular_type = "lua" # Don't break default
	return popular_type
endglobal

snippet part "Part" b
`!p snip.rv = display_width(t[1])*'#'`
${1:${VISUAL:Part name}}
`!p snip.rv = display_width(t[1])*'#'`

$0
endsnippet

snippet chap "Chapter" b
`!p snip.rv = display_width(t[1])*'*'`
${1:${VISUAL:Chapter name}}
`!p snip.rv = display_width(t[1])*'*'`

$0
endsnippet

snippet sec "Section" b
${1:${VISUAL:Section name}}
`!p snip.rv = display_width(t[1])*'='`

$0
endsnippet

snippet ssec "Subsection" b
${1:${VISUAL:Subsection name}}
`!p snip.rv = display_width(t[1])*'-'`

$0
endsnippet

snippet sssec "Subsubsection" b
${1:${VISUAL:Subsubsection name}}
`!p snip.rv = display_width(t[1])*'^'`

$0
endsnippet

snippet para "Paragraph" b
${1:${VISUAL:Paragraph name}}
`!p snip.rv = display_width(t[1])*'"'`

$0
endsnippet

snippet em "Emphasize string" i
`!p
# dirty but works with CJK character detection
if has_cjk(vim.current.line):
	snip.rv ="\ "`*${1:${VISUAL:Em}}*`!p
if has_cjk(vim.current.line):
	snip.rv ="\ "
else:
	snip.rv = " "
`$0
endsnippet

snippet st "Strong string" i
`!p
if has_cjk(vim.current.line):
	snip.rv ="\ "`**${1:${VISUAL:Strong}}**`!p
if has_cjk(vim.current.line):
	snip.rv ="\ "
else:
	snip.rv = " "
`$0
endsnippet

snippet "li(st)? (?P<num>\d+)" "List" br
$0
`!p
# usage: li 4<tab>
# which will extand into a unordered list contains 4 items
snip.rv = make_items(match.groupdict()['num'])
`
endsnippet

snippet "ol(st)? (?P<num>\d+)" "Order List" br
$0
`!p
# usage: ol 4<tab>
# which will extand into a ordered list contains 4 items
snip.rv = make_items(match.groupdict()['num'], 1)
`
endsnippet
###########################################################################
#						  More Specialized Stuff.						  #
###########################################################################
snippet cb "Code Block" b
.. code-block:: ${1:`!p snip.rv = get_popular_code_type()`}

	${2:${VISUAL:code}}

$0
endsnippet

# match snippets :
# img, inc, fig
snippet id "Includable Directives" b
`!p
real_name=real_filename(os.path.basename(t[2]))
di=t[1][:2]

link=""
content=""

if di == 'im':
	link = "|{0}|".format(real_name)

if di == 'fi':
	content="""
	:alt: {0}

	{0}""".format(real_name)
`
..`!p snip.rv = " %s" % link if link else ""` $1`!p
snip.rv=complete(t[1], INCLUDABLE_DIRECTIVES)
`:: ${2:${VISUAL:file}}`!p
if content:
	snip.rv +="    "+content`
`!p
# Tip of whether file is exist in comment type
if not check_file_exist(path, t[2]):
	snip.rv='.. FILE {0} does not exist'.format(t[2])
else:
	snip.rv=""
`$0
endsnippet

snippet di "Directives" b
.. $1`!p snip.rv=complete(t[1], DIRECTIVES)`:: $2

	${3:${VISUAL:Content}}
$0
endsnippet

snippet dt "Directives without title" b
.. $1`!p snip.rv=complete(t[1], DIRECTIVES_WITHOUT_TITLE)`::

	${2:${VISUAL:Content}}
$0
endsnippet

snippet ds "Directives for subscription" b
.. |$1| $2`!p snip.rv=complete(t[2], DIRECTIVES_FOR_SUBSTITUTION)`:: ${3:Content}
$0
endsnippet

snippet sa "Specific Admonitions" b
.. $1`!p snip.rv =complete(t[1], SPECIFIC_ADMONITIONS)`:: $2

	${3:${VISUAL:Content}}

$0
endsnippet

# it will be trigger at start of line or after a word
snippet ro "Text Roles" w
\ :$1`!p snip.rv=complete(t[1],
							   TEXT_ROLES+look_up_directives(TEXT_ROLES_REGEX,
														path))`:\`$2\`\
endsnippet

snippet eu "Embedded URI" i
`!p
if has_cjk(vim.current.line):
	snip.rv = "\ "`\`${1:${VISUAL:Text}} <${2:URI}>\`_`!p
if has_cjk(vim.current.line):
	snip.rv ="\ "
else:
	snip.rv = ""
`$0
endsnippet

snippet fnt "Footnote or Citation" i
[${1:Label}]_ $0

.. [$1] ${2:Reference}
endsnippet

# Only for Nikola — Static Site Generator
snippet chart "Pygal chart for Nikola" b
.. chart:: $1`!p snip.rv=complete(t[1], CHART_TYPES)`
	:title: '${2:Browser usage evolution (in %)}'
	:x_labels: [${3:"2002", "2003", "2004", "2005", "2006", "2007"}]

	'Firefox', [None, None, 0, 16.6, 25, 31]
	'Chrome',  [None, None, None, None, None, None]
	'IE',      [85.8, 84.6, 84.7, 74.5, 66, 58.6]
	'Others',  [14.2, 15.4, 15.3, 8.9, 9, 10.4]
$0
endsnippet

############
#  Sphinx  #
############

snippet sid "SideBar" b
.. sidebar:: ${1:SideBar Title}

	${2:${VISUAL:SideBar Content}}
endsnippet

# vim:set list noet sts=0 sw=4 ts=4:
./UltiSnips/ruby.snippets	[[[1
341
priority -50

#
# Global functions
#

global !p

def write_instance_vars(arglist, snip):
	args = str(arglist).split(',')
	for arg in args:
		name = arg.strip().replace(':', ' ').split(' ', 1)[0]
		if name:
			snip += '  @{} = {}'.format(name, name)
		else:
			snip += ''

endglobal

#
# Snippets
#

snippet #! "#!/usr/bin/env ruby" b
#!/usr/bin/env ruby
$0
endsnippet

snippet "^# ?[uU][tT][fF]-?8" "# encoding: UTF-8" r
# encoding: UTF-8
$0
endsnippet

snippet "\b(de)?f" "def <name>..." r
def ${1:function_name}${2:(${3:*args})}
	$0
end
endsnippet

snippet defi "def initialize ..."
def initialize($1)`!p write_instance_vars(t[1],snip)`$0
end
endsnippet

snippet defr "def <name> ... rescue ..."
def ${1:function_name}${2:(${3:*args})}
	$4
rescue
	$0
end
endsnippet

snippet For "(<from>..<to>).each { |<i>| <block> }"
(${1:from}..${2:to}).each { |${3:i}| $0 }
endsnippet

snippet "(\S+)\.Merge!" ".merge!(<other_hash>) { |<key>,<oldval>,<newval>| <block> }" r
`!p snip.rv=match.group(1)`.merge!(${1:other_hash}) { |${2:key},${3:oldval},${4:newval}| ${5:block} }
endsnippet

snippet "(\S+)\.merge!" ".merge!(<other_hash>) do |<key>,<oldval>,<newval>| <block> end" r
`!p snip.rv=match.group(1)`.merge!(${1:other_hash}) do |${2:key},${3:oldval},${4:newval}|
	${0:block}
end
endsnippet

snippet "(\S+)\.Del(ete)?_?if" ".delete_if { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.delete_if { |${1:key},${2:value}| $0 }
endsnippet

snippet "(\S+)\.del(ete)?_?if" ".delete_if do |<key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.delete_if do |${1:key},${2:value}|
	$0
end
endsnippet

snippet "(\S+)\.Keep_?if" ".keep_if { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.keep_if { |${1:key},${2:value}| $0 }
endsnippet

snippet "(\S+)\.keep_?if" ".keep_if do <key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.keep_if do |${1:key},${2:value}|
	$0
end
endsnippet

snippet "(\S+)\.Reject" ".reject { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.reject { |${1:key},${2:value}| $0 }
endsnippet

snippet "(\S+)\.reject" ".reject do <key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.reject do |${1:key},${2:value}|
	$0
end
endsnippet

snippet "(\S+)\.Select" ".select { |<item>| <block>}" r
`!p snip.rv=match.group(1)`.select { |${1:item}| ${2:block} }
endsnippet

snippet "(\S+)\.select" ".select do |<item>| <block> end" r
`!p snip.rv=match.group(1)`.select do |${1:item}|
	${0:block}
end
endsnippet

snippet "(\S+)\.Sort" ".sort { |<a>,<b>| <block> }" r
`!p snip.rv=match.group(1)`.sort { |${1:a},${2:b}| $0 }
endsnippet

snippet "(\S+)\.sort" ".sort do |<a>,<b>| <block> end" r
`!p snip.rv=match.group(1)`.sort do |${1:a},${2:b}|
	$0
end
endsnippet

snippet "(\S+)\.Each_?k(ey)?" ".each_key { |<key>| <block> }" r
`!p snip.rv=match.group(1)`.each_key { |${1:key}| $0 }
endsnippet

snippet "(\S+)\.each_?k(ey)?" ".each_key do |key| <block> end" r
`!p snip.rv=match.group(1)`.each_key do |${1:key}|
	$0
end
endsnippet

snippet "(\S+)\.Each_?val(ue)?" ".each_value { |<value>| <block> }" r
`!p snip.rv=match.group(1)`.each_value { |${1:value}| $0 }
endsnippet

snippet "(\S+)\.each_?val(ue)?" ".each_value do |<value>| <block> end" r
`!p snip.rv=match.group(1)`.each_value do |${1:value}|
	$0
end
endsnippet

snippet "(\S+)\.ea" "<elements>.each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.each { |${1:e}| $0 }
endsnippet

snippet "(\S+)\.ead" "<elements>.each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.each do |${1:e}|
	$0
end
endsnippet

snippet "each_?s(lice)?" "<array>.each_slice(n) do |slice| <block> end" r
${1:elements}.each_slice(${2:2}) do |${3:slice}|
	$0
end
endsnippet

snippet "Each_?s(lice)?" "<array>.each_slice(n) { |slice| <block> }" r
${1:elements}.each_slice(${2:2}) { |${3:slice}| $0 }
endsnippet

snippet "(\S+)\.Map" ".map { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.map { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| $0 }
endsnippet

snippet "(\S+)\.map" ".map do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.map do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	$0
end
endsnippet

snippet "(\S+)\.Rev(erse)?_?each" ".reverse_each { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.reverse_each { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| $0 }
endsnippet

snippet "(\S+)\.rev(erse)?_?each" ".reverse_each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.reverse_each do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	$0
end
endsnippet

snippet "(\S+)\.Each" ".each { |<element>| <block> }" r
`!p snip.rv=match.group(1)`.each { |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}| $0 }
endsnippet

snippet "(\S+)\.each" ".each do |<element>| <block> end" r
`!p snip.rv=match.group(1)`.each do |${1:`!p
element_name = match.group(1).lstrip('$@')
ematch = re.search("([A-Za-z][A-Za-z0-9_]+?)s?[^A-Za-z0-9_]*?$", element_name)
try:
	wmatch = re.search("([A-Za-z][A-Za-z0-9_]+)$", ematch.group(1))
	snip.rv = wmatch.group(1).lower()
except:
	snip.rv = 'element'
`}|
	$0
end
endsnippet

snippet "(\S+)\.Each_?p(air)?"  ".each_pair { |<key>,<value>| <block> }" r
`!p snip.rv=match.group(1)`.each_pair { |${1:key},${2:value}| $0 }
endsnippet

snippet "(\S+)\.each_?p(air)?" ".each_pair do |<key>,<value>| <block> end" r
`!p snip.rv=match.group(1)`.each_pair do |${1:key},${2:value}|
	$0
end
endsnippet

snippet "(\S+)\.sub" ".sub(<expression>) { <block> }" r
`!p snip.rv=match.group(1)`.sub(${1:expression}) { ${2:"replace_with"} }
endsnippet

snippet "(\S+)\.gsub" ".gsub(<expression>) { <block> }" r
`!p snip.rv=match.group(1)`.gsub(${1:expression}) { ${2:"replace_with"} }
endsnippet

snippet "(\S+)\.index" ".index { |item| <block> }" r
`!p snip.rv=match.group(1)`.index { |${1:item}| ${2:block} }
endsnippet

snippet "(\S+)\.Index" ".index do |item| ... end" r
`!p snip.rv=match.group(1)`.index do |${1:item}|
	${0:block}
end
endsnippet

snippet until "until <expression> ... end"
until ${1:expression}
	$0
end
endsnippet

snippet Until "begin ... end until <expression>"
begin
	$0
end until ${1:expression}
endsnippet

snippet while "while <expression> ... end"
while ${1:expression}
	$0
end
endsnippet

snippet While "begin ... end while <expression>"
begin
	$0
end while ${1:expression}
endsnippet

snippet begin "begin ... rescue ... end"
begin
	$1
rescue
	$0
end
endsnippet

snippet rescue
rescue Exception => e
	puts e.message
	puts e.backtrace.inspect
	${0:# Rescue}
endsnippet

snippet "\b(case|sw(itch)?)" "case <variable> when <expression> ... end" r
case ${1:variable}
when ${2:expression}
  $0
end
endsnippet

snippet class "class <class_name> def initialize ... end end"
class ${1:`!p snip.rv = snip.basename.title().replace('_', '')`}
	def initialize(${2:*args})
		$0
	end
end
endsnippet

snippet module "module"
module ${1:`!p snip.rv = snip.basename.title().replace('_', '')`}
	$0
end
endsnippet

snippet ###
=begin
	$0
=end
endsnippet

snippet priv "private " m
private

$0
endsnippet

snippet prot "protected" m
protected

$0
endsnippet

# vim: set ts=2 sw=2 expandtab:
./UltiSnips/rust.snippets	[[[1
53
#######################################################################
#                            Rust Snippets                            #
#######################################################################

priority -50

snippet fn "fn name(?) -> ? {}"
fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pfn "pub fn name(?) -> ? {}"
pub fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet afn "async fn name(?) -> ? {}"
async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pafn "pub async fn name(?) -> ? {}"
pub async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pri "print!(..)" b
print!("$1"${2/..*/, /}$2);
endsnippet

snippet pln "println!(..)" b
println!("$1"${2/..*/, /}$2);
endsnippet

snippet fmt "format!(..)"
format!("$1"${2/..*/, /}$2);
endsnippet

snippet .it ".iter()" i
.iter()$0
endsnippet

snippet impl "Struct/Trait implementation" b
impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {
	${0}
}
endsnippet

# vim:ft=snippets:
./UltiSnips/sh.snippets	[[[1
106
priority -50

global !p
import vim

# Tests for the existence of a variable declared by Vim's filetype detection
# suggesting the type of shell script of the current file
def testShell(scope, shell):
	return vim.eval("exists('" + scope + ":is_" + shell + "')")

# Loops over the possible variables, checking for global variables
# first since they indicate an override by the user.
def getShell():
	for scope in ["g", "b"]:
		for shell in ["bash", "posix", "sh", "kornshell"]:
			if testShell(scope, shell) == "1":
				if shell == "kornshell":
					return "ksh"
				if shell == "posix":
					return "sh"
				return shell
	return "sh"
endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################
snippet #! "#!/usr/bin/env (!env)" b
`!p snip.rv = '#!/usr/bin/env ' + getShell() + "\n" `
endsnippet

snippet sbash "safe bash options" b
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
`!p snip.rv ='\n\n' `
endsnippet

snippet temp "Tempfile" b
${1:TMPFILE}="$(mktemp -t ${3:--suffix=${4:.SUFFIX}} ${2:`!p
snip.rv = re.sub(r'[^a-zA-Z]', '_', snip.fn) or "untitled"
`}.XXXXXX)"
${5:${6/(.+)/trap "/}${6:rm -f '$${1/.*\s//}'}${6/(.+)/" 0               # EXIT\n/}${7/(.+)/trap "/}${7:rm -f '$${1/.*\s//}'; exit 1}${7/(.+)/" 2       # INT\n/}${8/(.+)/trap "/}${8:rm -f '$${1/.*\s//}'; exit 1}${8/(.+)/" 1 15    # HUP TERM\n/}}

endsnippet

snippet /case|sw(itch)?/ "case .. esac (case)" rb
case ${1:word} in
	${2:pattern} )
		${0:${VISUAL}};;
esac
endsnippet

snippet elif "elif .. (elif)" b
elif ${2:[[ ${1:condition} ]]}; then
	${0:${VISUAL}}
endsnippet

snippet for "for ... done (for)" b
for (( i = 0; i < ${1:10}; i++ )); do
	${0:${VISUAL}}
done
endsnippet

snippet forin "for ... in ... done (forin)" b
for ${1:i}${2/.+/ in /}${2:words}; do
	${0:${VISUAL}}
done
endsnippet

snippet here "here document (here)"
<<-${2:'${1:TOKEN}'}
	$0`echo \\n`${1/['"`](.+)['"`]/$1/}
endsnippet

snippet /ift(est)?/ "if ... then (if)" rb
if ${2:[ ${1:condition} ]}; then
	${0:${VISUAL}}
fi
endsnippet

snippet if "if ... then (if)" b
if [[ ${1:condition} ]]; then
	${0:${VISUAL}}
fi
endsnippet

snippet until "until ... (done)" b
until ${2:[[ ${1:condition} ]]}; do
	${0:${VISUAL}}
done
endsnippet

snippet /wh(ile)?/ "while ... (done)" rb
while ${2:[[ ${1:condition} ]]}; do
	${0:${VISUAL}}
done
endsnippet

snippet func "function() {...}" b
${1:function} () {
	${0:${VISUAL}}
}
endsnippet

# vim:ft=snippets:
./UltiSnips/smarty.snippets	[[[1
28
# snippets for smarty3

extends html
extends javascript
extends css




# https://www.smarty.net/docs/en/language.function.append.tpl
snippet append "{append} is used for creating or appending template variable arrays during the execution of a template."
{append var='${1}' value='${2}'${3: index='${4|first,last|}'}${5: scope='${6|parent,root,global|}'}}
endsnippet

# https://www.smarty.net/docs/en/language.function.assign.tpl
snippet assign "{assign} is used for assigning template variables during the execution of a template."
{assign var='${1}' value='${2}'${3: scope='${4|parent,root,global|}'}}
endsnippet

# https://www.smarty.net/docs/en/language.function.config.load.tpl
snippet config_load "config_load"
{config_load file='${1}'${2: section='${3}'}${4: scope='${5|local,parent,global|}'}}
endsnippet

# https://www.smarty.net/docs/en/language.function.include.tpl
snippet include "{include} tags are used for including other templates in the current template. Any variables available in the current template are also available within the included template."
{include file='${1}'${2: assign='${3}'}${4: cache_lifetime=${5}}${6: compile_id='${7}'}${8: cache_id='${9}'}${10: scope='${11|parent,root,global|}'}${12: variables}}
endsnippet
./UltiSnips/snippets.snippets	[[[1
21
priority -50

# We use a little hack so that the snippet is expanded
# and parsed correctly
snippet usnip "Ultisnips snippet definition" b
`!p snip.rv = "snippet"` ${1:Tab_trigger} "${2:Description}" ${3:b}
${0:${VISUAL}}
`!p snip.rv = "endsnippet"`
endsnippet

snippet global "Global snippet" b
`!p snip.rv = "global"` !p
${0:${VISUAL}}
`!p snip.rv = "endglobal"`
endsnippet

snippet vis "${VISUAL}" i
\$\{VISUAL${1:${2:default}${3:/transform/}}\}
endsnippet

# vim:ft=snippets:
./UltiSnips/soy.snippets	[[[1
63
priority -50

extends html

snippet ns "Namespace" b
{namespace ${1:name}}
endsnippet

snippet tmpl "Template" b
/**
 * ${2:TODO(`whoami`): Describe this template.}
 */
{template .${1:name}}
	$0
{/template}
endsnippet

snippet msg "Message" b
{msg desc="${1:description}"}
	$0
{/msg}
endsnippet

snippet let "let command" b
{let $${1:identifier}: ${2:expression} /}
endsnippet

snippet if "if .. (if)" b
{if ${1:expression}}
	$0
{/if}
endsnippet

snippet ife "if .. else (ife)" b
{if ${1:expression}}
	$2
{else}
	$0
{/if}
endsnippet

snippet eli "else if .. (eli)" b
{elif ${1:expression}}
	$0
endsnippet

snippet fore "foreach command" b
{foreach $${1:var} in ${2:ref}}
	$0
{/foreach}
endsnippet

snippet for "for command" b
{for $${1:var} in range(${2:rangeexpr})}
	$0
{/for}
endsnippet

snippet call "template call" b
{call ${1:tmpl}}
	$0
{/call}
endsnippet
./UltiSnips/supercollider.snippets	[[[1
10
snippet for
for (${1:1}, ${2:10}) {${3: |i}|}
	$0
}
endsnippet
snippet sdef
SynthDef(\\${1:synthName}, {${2: |${3:x}|}
	$0
}).add;
endsnippet
./UltiSnips/svelte.snippets	[[[1
1
extends html, javascript, css
./UltiSnips/tcl.snippets	[[[1
52
priority -50

###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################
snippet for "for... (for)" b
for {${1:set i 0}} {${2:\$i < \$n}} {${3:incr i}} {
	$4
}

endsnippet

snippet foreach "foreach... (foreach)"
foreach ${1:var} ${2:\$list} {
	$3
}

endsnippet

snippet if "if... (if)" b
if {${1:condition}} {
	$2
}

endsnippet

snippet proc "proc... (proc)" b
proc ${1:name} {${2:args}} \
{
	$3
}

endsnippet

snippet switch "switch... (switch)" b
switch ${1:-exact} -- ${2:\$var} {
	${3:match} {
		$4
	}
	default {$5}
}

endsnippet

snippet while "while... (while)" b
while {${1:condition}} {
	$2
}

endsnippet

# vim:ft=snippets:
./UltiSnips/tex.snippets	[[[1
578
##########
# GLOBAL #
##########

global !p

def create_table(snip):
	rows = snip.buffer[snip.line].split('x')[0]
	cols = snip.buffer[snip.line].split('x')[1]
	int_val = lambda string: int(''.join(s for s in string if s.isdigit()))
	rows = int_val(rows)
	cols = int_val(cols)
	offset = cols + 1
	old_spacing = snip.buffer[snip.line][:snip.buffer[snip.line].rfind('\t') + 1]
	snip.buffer[snip.line] = ''
	final_str = old_spacing + "\\begin{tabular}{|" + "|".join(['$' + str(i + 1) for i in range(cols)]) + "|}\n"
	for i in range(rows):
		final_str += old_spacing + '\t'
		final_str += " & ".join(['$' + str(i * cols + j + offset) for j in range(cols)])
		final_str += " \\\\\\\n"
	final_str += old_spacing + "\\end{tabular}\n$0"
	snip.expand_anon(final_str)

def add_row(snip):
	row_len = int(''.join(s for s in snip.buffer[snip.line] if s.isdigit()))
	old_spacing = snip.buffer[snip.line][:snip.buffer[snip.line].rfind('\t') + 1]
	snip.buffer[snip.line] = ''
	final_str = old_spacing
	final_str += " & ".join(['$' + str(j + 1) for j in range(row_len)])
	final_str += " \\\\\\"
	snip.expand_anon(final_str)
endglobal


###############
# ENVIRONMENT #
###############

snippet beg "begin{} / end{}" bi
\begin{$1}
	${0:${VISUAL}}
\end{$1}
endsnippet

snippet cnt "Center" bi
\begin{center}
	${0:${VISUAL}}
\end{center}
endsnippet

snippet desc "Description" bi
\begin{description}
	\item[${1:${VISUAL}}] $0
\end{description}
endsnippet

snippet lemma "Lemma" bi
\begin{lemma}
	${0:${VISUAL}}
\end{lemma}
endsnippet

snippet prop "Proposition" bi
\begin{prop}[$1]
	${0:${VISUAL}}
\end{prop}
endsnippet

snippet thrm "Theorem" bi
\begin{theorem}[$1]
	${0:${VISUAL}}
\end{theorem}
endsnippet

snippet post "postulate" bi
\begin{postulate}[$1]
	${0:${VISUAL}}
\end{postulate}
endsnippet

snippet prf "Proof" bi
\begin{myproof}[$1]
	${0:${VISUAL}}
\end{myproof}
endsnippet

snippet def "Definition" bi
\begin{definition}[$1]
	${0:${VISUAL}}
\end{definition}
endsnippet

snippet nte "Note" bi
\begin{note}[$1]
	${0:${VISUAL}}
\end{note}
endsnippet

snippet prob "Problem" bi
\begin{problem}[$1]
	${0:${VISUAL}}
\end{problem}
endsnippet

snippet corl "Corollary" bi
\begin{corollary}[$1]
	${0:${VISUAL}}
\end{corollary}
endsnippet

snippet example "Example" bi
\begin{example}[$1]
	${0:${VISUAL}}
\end{example}
endsnippet

snippet notion "Notation" bi
\begin{notation}[$1]
	$0${VISUAL}
\end{notation}
endsnippet

snippet conc "Conclusion" bi
\begin{conclusion}[$1]
	$0${VISUAL}
\end{conclusion}
endsnippet

snippet fig "Figure environment" bi
\begin{figure}[${1:htpb}]
	\centering
	${2:\includegraphics[width=0.8\textwidth]{$3}}
	\caption{${4:$3}}
	\label{fig:${5:${3/\W+/-/g}}}
\end{figure}
endsnippet

snippet enum "Enumerate" bi
\begin{enumerate}
	\item ${0:${VISUAL}}
\end{enumerate}
endsnippet

snippet item "Itemize" bi
\begin{itemize}
	\item ${0:${VISUAL}}
\end{itemize}
endsnippet

snippet case "cases" bi
\begin{cases}
	${0:${VISUAL}}
\end{cases}
endsnippet

snippet abs "abstract environment" b
\begin{abstract}
	${0:${VISUAL}}
.\end{abstract}
endsnippet

snippet tab "tabular / array environment" b
\begin{${1:t}${1/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}{${2:c}}
$0${2/(?<=.)(c|l|r)|./(?1: & )/g}
\end{$1${1/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}

	\begin{${4:t}${4/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}{${5:c}}
		$0${5/(?<=.)(c|l|r)|./(?1: & )/g}
	\end{$4${4/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}
\end{table}
endsnippet

########
# MATH #
########

snippet cc "subset" w
\subset 
endsnippet

snippet inn "in " w
\in 
endsnippet

snippet Nn "cap" w
\cap 
endsnippet

snippet UU "cup" w
\cup 
endsnippet

snippet uuu "bigcup" w
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" w
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

snippet HH "H" w
\mathbb{H}
endsnippet

snippet DD "D" w
\mathbb{D}
endsnippet

snippet inmath "Inline Math" w
\\(${1}\\) $0
endsnippet

snippet dm "Display Math" w
\[
	${1:${VISUAL}}
\]$0
endsnippet

snippet frac "Fraction" w
\frac{$1}{$2}$0
endsnippet

snippet compl "Complement" i
^{c}
endsnippet

snippet ss "Super Script" i
^{$1}$0
endsnippet

snippet __ "subscript" Aw
_{$1}$0
endsnippet

snippet srt "Square Root" wi
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet srto "... Root" wi
\sqrt[$1]{${2:${VISUAL}}}$0
endsnippet

snippet bf "Bold" wi
\bf{${1:${VISUAL}}}$0
endsnippet

snippet it "Italic" wi
\it{${1:${VISUAL}}}$0
endsnippet

snippet un "Underline" wi
\un{${1:${VISUAL}}}$0
endsnippet

snippet rm "Text" wi
\rm{${1:${VISUAL}}}$0
endsnippet

snippet itm "Item" wi
\item ${0:${VISUAL}}
endsnippet

snippet ceil "Ceil" w
\left\lceil $1 \right\rceil $0
endsnippet

snippet floor "Floor" w
\left\lfloor $1 \right\rfloor$0
endsnippet

snippet pmat "Pmat" w
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "Bmat" w
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

snippet () "Left( right)" w
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" wi
\left<${1:${VISUAL}} \right>$0
endsnippet

snippet conj "conjugate" w
\overline{$1}$0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n z^n}
endsnippet

snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}} 
endsnippet

snippet limsup "limsup" w
\limsup_{${1:n} \to ${2:\infty}} 
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

snippet ooo "\infty" w
\infty
endsnippet

snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

snippet => "Implies" w
\implies
endsnippet

snippet =< "Implied by" w
\impliedby
endsnippet

snippet iff "iff" w
\iff
endsnippet

snippet == "Equals" w
&= $1 \\\\
endsnippet

snippet != "Not Equal" w
\neq 
endsnippet

snippet <= "leq" w
\le 
endsnippet

snippet >= "geq" w
\ge 
endsnippet

snippet nn "Tikz node" w
\node[$5] (${1/[^0-9a-zA-Z]//g}${2}) ${3:at (${4:0,0}) }{$${1}$};
$0
endsnippet

snippet lll "l" w
\ell
endsnippet

snippet xx "cross" Aw
\times 
endsnippet

snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rw
\\`!p snip.rv = match.group(1)`
endsnippet

snippet <! "normal" Aw
\triangleleft 
endsnippet

snippet "((\d|\w)+)invs" "inverse" Awr
`!p snip.rv = match.group(1)`^{-1}
endsnippet

snippet !> "mapsto" Aw
\mapsto 
endsnippet

##########
# TABLES #
#########

pre_expand "create_table(snip)"
snippet "gentbl(\d+)x(\d+)" "Generate table of *width* by *height*" r
endsnippet

pre_expand "add_row(snip)"
snippet "tr(\d+)" "Add table row of dimension ..." r
endsnippet


###########
# POSTFIX #
###########

snippet bar "bar" wi
\bar{${1:${VISUAL}}}$0
endsnippet

snippet "\<(.*?)\|" "bra" wri
\bra{`!p snip.rv = match.group(1).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

snippet "\|(.*?)\>" "ket" wri
\ket{`!p snip.rv = match.group(1).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet

snippet "(.*)\\bra{(.*?)}([^\|]*?)\>" "braket" Awri
`!p snip.rv = match.group(1)`\braket{`!p snip.rv = match.group(2)`}{`!p snip.rv = match.group(3).replace('q', f'\psi').replace('f', f'\phi')`}
endsnippet


#############
# PRE-AMBLE #
#############

snippet pac "usepackage - removes square braces if options removed" b
\usepackage`!p snip.rv='[' if t[1] else ""`${1:options}`!p snip.rv = ']' if t[1] else ""`{${2:package}}$0
endsnippet

snippet docls "Document Class" bA
\documentclass{$1}$0
endsnippet


#########
# OTHER #
#########

snippet acl "Acroynm expanded" bi
\acl{${1:acronym}}
endsnippet

snippet ac "Acroynm normal" bi
\ac{${1:acronym}}
endsnippet

snippet ni "Non-indented paragraph" bi
\noindent
endsnippet


############
# SECTIONS #
############

snippet chap "Chapter" wi
\chapter{$1${VISUAL}}
endsnippet

snippet sec "Section" wi
\section{$1${VISUAL}}
endsnippet

snippet sec* "Section*" wi
\section*{$1${VISUAL}}
endsnippet

snippet sub "Subsection" wi
\subsection{$1${VISUAL}}
endsnippet

snippet sub* "Subsection*" wi
\subsection*{$1${VISUAL}}
endsnippet

snippet subsub "Subsection" wi
\subsubsection{$1${VISUAL}}
endsnippet

snippet subsub* "Subsubsection" wi
\subsubsection*{$1${VISUAL}}
endsnippet

snippet par "Paragraph" wi
\paragraph{$1${VISUAL}}
endsnippet

snippet par* "Paragraph*" wi
\paragraph*{$1${VISUAL}}
endsnippet

snippet subpar "Sub Paragraph" wi
\subparagraph{$1${VISUAL}}
endsnippet

snippet subpar* "Sub Paragraph*" wi
\subparagraph*{$1${VISUAL}}
endsnippet

snippet chapl "Chapter with label" wi
\chapter{$1${VISUAL}}
\label{cha:${2:${1/\W+/-/g}}}
endsnippet

snippet secl "Section with label" wi
\section{$1${VISUAL}}
\label{sec:${2:${1/\W+/-/g}}}
endsnippet

snippet sec*l "Section* with label" wi
\section*{$1${VISUAL}}
\label{sec:${2:${1/\W+/-/g}}}
endsnippet

snippet subl "Subsection with label" wi
\subsection{$1${VISUAL}}
\label{sub:${2:${1/\W+/-/g}}}
endsnippet

snippet sub*l "Subsection* with label" wi
\subsection*{$1${VISUAL}}
\label{sub:${2:${1/\W+/-/g}}}
endsnippet

snippet subsubl "Subsection with label" wi
\subsubsection{$1${VISUAL}}
\label{ssub:${2:${1/\W+/-/g}}}
endsnippet

snippet subsub*l "Subsubsection with label" wi
\subsubsection*{$1${VISUAL}}
\label{ssub:${2:${1/\W+/-/g}}}
endsnippet

snippet parl "Paragraph with label" wi
\paragraph{$1${VISUAL}}
\label{par:${2:${1/\W+/-/g}}}
endsnippet

snippet par*l "Paragraph* with label" wi
\paragraph*{$1${VISUAL}}
\label{par:${2:${1/\W+/-/g}}}
endsnippet

snippet subparl "Sub Paragraph with label" wi
\subparagraph{$1${VISUAL}}
\label{subp:${2:${1/\W+/-/g}}}
endsnippet

snippet subpar*l "Sub Paragraph* with label" wi
\subparagraph*{$1${VISUAL}}
\label{subp:${2:${1/\W+/-/g}}}
endsnippet

# vim:ft=snippets:
./UltiSnips/texmath.snippets	[[[1
53
priority -50

##############
# MATH STUFF #
##############

snippet eqnn "Equation without a number" b
\begin{equation*}
	${0:${VISUAL}}
\end{equation*}
endsnippet

snippet al "Align" b
\begin{align}
	${0:${VISUAL}}
\end{align}
endsnippet

snippet alnn "Align without a number" b
\begin{align*}
	${0:${VISUAL}}
\end{align*}
endsnippet

snippet eqa "Equation array" b
\begin{eqnarray}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray}
endsnippet

snippet eqann "Equation array without a number" b
\begin{eqnarray*}
	${1:${VISUAL}} & ${2:${VISUAL}} & ${0:${VISUAL}}
\end{eqnarray*}
endsnippet

#################
# PHYSICS STUFF #
#################

snippet dv "Derivative" w
\dv[${1:${VISUAL}}]{${2}}{${3}}
endsnippet

snippet pdv "Partial Derivative" w
\pdv[${1:${VISUAL}}]{${2}}{${3}}
endsnippet

snippet SI "SI-Unit" w
\SI{${1:${VISUAL}}}{${2}}
endsnippet

# vim:ft=snippets:
./UltiSnips/typescript.snippets	[[[1
18
priority -50

extends javascript

snippet int "interface"
interface ${1} {
}
endsnippet
snippet nspc "namespace"
namespace ${1} {
}
endsnippet
priority -49
snippet fun "function (named)" b
function ${1:function_name} (${2:argument}: ${3:argument_type}) {
	${VISUAL}$0
}
endsnippet
./UltiSnips/typescript_react.snippets	[[[1
12
priority -50
extends javascript_react
extends typescript

priority -49
snippet rfc "react functional component"
import React, { FC } from "react"

interface ${1:function_name}Props {${4:props_types}}

export const ${1:function_name}: FC<${1:function_name}Props> = (${2:props}) => ${3:function_body}
endsnippet
./UltiSnips/vim.snippets	[[[1
24
priority -50

###########################################################################
#                            SnipMate Snippets                            #
###########################################################################
snippet gvar "Global / configuration variable" b
if !exists("g:${1:MyUltraImportantVar}")
	let g:$1 = ${2:"${3:<tab>}"}
endif
endsnippet

snippet guard "script reload guard" b
if exists('${1:did_`!p snip.rv = snip.fn.replace('.','_')`}') || &cp${2: || version < 700}
	finish
endif
let $1 = 1$3
endsnippet

snippet f "function" b
fun ${1:function_name}($2)
	${3:" code}
endf
endsnippet
# vim:ft=snippets:
./UltiSnips/vue.snippets	[[[1
1
extends html, javascript, css
./UltiSnips/xhtml.snippets	[[[1
3
priority -50

extends html
./UltiSnips/xml.snippets	[[[1
16
priority -50

snippet xml "XML declaration" b
<?xml version="1.0"?>

endsnippet

snippet t "Simple tag" b
<${1:tag}>
	${2:${VISUAL}}
</${1/([\w:._-]+).*/$1/}>
endsnippet

snippet ti "Inline tag" b
<${1:tag}>${2:${VISUAL}}</${1/([\w:._-]+).*/$1/}>
endsnippet
./UltiSnips/zsh.snippets	[[[1
12
priority -50

extends sh

priority -49

snippet #! "#!/usr/bin/env zsh" b
#!/usr/bin/env zsh
$0
endsnippet

# vim:ft=snippets:
./addon-info.json	[[[1
9
{
  "name" : "vim-snippets",
  "author" : "community",
  "maintainer" : "honza @ github & others",
  "repository" : {"type": "git", "url": "git://github.com/honza/vim-snippets.git"},
  "dependencies" : {
  },
  "description" : "community driven set of snippets for snipmate"
}
./autoload/vim_snippets.vim	[[[1
27
" this is well known Filename found in snipmate (and the other engines), but
" rewritten and documented :)
"
" optional arg1: string in which to replace '$1' by filename with extension
"   and path dropped. Defaults to $1
" optional arg2: return this value if buffer has no filename
"  But why not use the template in this case, too?
"  Doesn't make sense to me
fun! vim_snippets#Filename(...)
  let template = get(a:000, 0, "$1")
  let arg2 = get(a:000, 1, "")

  let basename = expand('%:t:r')

  if basename == ''
    return arg2
  else
    return substitute(template, '$1', basename, 'g')
  endif
endf

" original code:
" fun! Filename(...)
"     let filename = expand('%:t:r')
"     if filename == '' | return a:0 == 2 ? a:2 : '' | endif
"     return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
" endf
./plugin/vimsnippets.vim	[[[1
50
if exists("b:done_vimsnippets")
   finish
endif
let b:done_vimsnippets = 1

" Some variables need default value
if !exists("g:snips_author")
    let g:snips_author = "yourname"
endif

if !exists("g:snips_email")
    let g:snips_email = "yourname@email.com"
endif

if !exists("g:snips_github")
    let g:snips_github = "https://github.com/yourname"
endif

" Expanding the path is not needed on Vim 7.4
if &cp || version >= 704
    finish
endif

" Add pythonx to the python search path if needed (i.e. <= Vim 7.3).
if !has("python") && !has("python3")
   finish
end

" This will fail if UltiSnips is not installed.
try
   call UltiSnips#bootstrap#Bootstrap()
catch /E117/
   finish
endtry


" This should have been set by UltiSnips, otherwise something is wrong.
if !exists("g:_uspy")
   finish
end


" Expand our path
let s:SourcedFile=expand("<sfile>")
exec g:_uspy "import vim, os, sys"
exec g:_uspy "sourced_file = vim.eval('s:SourcedFile')"
exec g:_uspy "while not os.path.exists(os.path.join(sourced_file, 'pythonx')):
   \ sourced_file = os.path.dirname(sourced_file)"
exec g:_uspy "module_path = os.path.join(sourced_file, 'pythonx')"
exec g:_uspy "sys.path.append(module_path)"
./pythonx/javascript_snippets.py	[[[1
48
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Helper utilities to format javascript snippets.
"""

ALWAYS = 'always'
NEVER = 'never'


def get_option(snip, option, default=None):
    return snip.opt('g:ultisnips_javascript["{}"]'.format(option), default)


def semi(snip):
    option = get_option(snip, 'semi', ALWAYS)

    if option == NEVER:
        ret = ''
    elif option == ALWAYS:
        ret = ';'
    else:
        ret = ';'
    return ret


def space_before_function_paren(snip):
    option = get_option(snip, 'space-before-function-paren', NEVER)

    if option == NEVER:
        ret = ''
    elif option == ALWAYS:
        ret = ' '
    else:
        ret = ''
    return ret


def keyword_spacing(snip):
    option = get_option(snip, 'keyword-spacing', ALWAYS)

    if option == NEVER:
        ret = ''
    elif option == ALWAYS:
        ret = ' '
    else:
        ret = ''
    return ret
./pythonx/vimsnippets.py	[[[1
119
# vim:set et fileencoding=utf8 sts=0 sw=4 ts=4:

"""Helper methods used in UltiSnips snippets."""

import string, vim, re

def complete(tab, opts):
    """
    get options that match with tab

    :param tab: query string
    :param opts: list that needs to be completed

    :return: a string that match with tab
    """
    el = [x for x in tab]
    pat = "".join(list(map(lambda x: x + "\w*" if re.match("\w", x) else x,
                           el)))
    try:
        opts = [x for x in opts if re.search(pat, x, re.IGNORECASE)]
    except:
        opts = [x for x in opts if x.startswith(tab)]
    if not len(opts) or str.lower(tab) in list(map(str.lower, opts)):
        return ""
    cads = "|".join(opts[:5])
    if len(opts) > 5: cads += "|..."
    return "({0})".format(cads)

def _parse_comments(s):
    """ Parses vim's comments option to extract comment format """
    i = iter(s.split(","))

    rv = []
    try:
        while True:
            # get the flags and text of a comment part
            flags, text = next(i).split(':', 1)

            if len(flags) == 0:
                rv.append(('OTHER', text, text, text, ""))
            # parse 3-part comment, but ignore those with O flag
            elif 's' in flags and 'O' not in flags:
                ctriple = ["TRIPLE"]
                indent = ""

                if flags[-1] in string.digits:
                    indent = " " * int(flags[-1])
                ctriple.append(text)

                flags, text = next(i).split(':', 1)
                assert flags[0] == 'm'
                ctriple.append(text)

                flags, text = next(i).split(':', 1)
                assert flags[0] == 'e'
                ctriple.append(text)
                ctriple.append(indent)

                rv.append(ctriple)
            elif 'b' in flags:
                if len(text) == 1:
                    rv.insert(0, ("SINGLE_CHAR", text, text, text, ""))
    except StopIteration:
        return rv

def get_comment_format():
    """ Returns a 4-element tuple (first_line, middle_lines, end_line, indent)
    representing the comment format for the current file.

    It first looks at the 'commentstring', if that ends with %s, it uses that.
    Otherwise it parses '&comments' and prefers single character comment
    markers if there are any.
    """
    commentstring = vim.eval("&commentstring")
    if commentstring.endswith("%s"):
        c = commentstring[:-2]
        return (c.rstrip(), c.rstrip(), c.rstrip(), "")
    comments = _parse_comments(vim.eval("&comments"))
    for c in comments:
        if c[0] == "SINGLE_CHAR":
            return c[1:]
    return comments[0][1:]


def make_box(twidth, bwidth=None):
    b, m, e, i = (s.strip() for s in get_comment_format())
    m0 = m[0] if m else ''
    bwidth_inner = bwidth - 3 - max(len(b), len(i + e)) if bwidth else twidth + 2
    sline = b + m + bwidth_inner * m0 + 2 * m0
    nspaces = (bwidth_inner - twidth) // 2
    mlines = i + m + " " + " " * nspaces
    mlinee = " " + " "*(bwidth_inner - twidth - nspaces) + m
    eline = i + m + bwidth_inner * m0 + 2 * m0 + e
    return sline, mlines, mlinee, eline

def foldmarker():
    "Return a tuple of (open fold marker, close fold marker)"
    return vim.eval("&foldmarker").split(",")


def display_width(str):
    """Return the required over-/underline length for str."""
    try:
        # Respect &ambiwidth and &tabstop, but old vim may not support this
        return vim.strdisplaywidth(str)
    except AttributeError:
        # Fallback
        from unicodedata import east_asian_width
        result = 0
        for c in str:
            result += 2 if east_asian_width(c) in ('W', 'F') else 1
        return result

# http://stackoverflow.com/questions/2718196/find-all-chinese-text-in-a-string-using-python-and-regex
def has_cjk(s):
    """Detect if s contains CJK characters."""
    cjk_re = re.compile(u'[⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〺〻㐀-䶵一-鿃豈-鶴侮-頻並-龎]', re.UNICODE)

    return cjk_re.search(s) is not None
./snippets/_.snippets	[[[1
288
# Global snippets

# (c) holds no legal value ;)
snippet c)
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${1:`g:snips_author`}. All Rights Reserved.
snippet date
	`strftime("%Y-%m-%d")`
snippet ddate
	`strftime("%B %d, %Y")`
snippet diso
	`strftime("%Y-%m-%dT%H:%M:%S")`
snippet time
	`strftime("%H:%M")`
snippet datetime
	`strftime("%Y-%m-%d %H:%M")`
snippet lorem
	Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
snippet GPL2
	${1:One line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, see <http://www.gnu.org/licenses/>.
	${0}
snippet LGPL2
	${1:One line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This library is free software; you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published
	by the Free Software Foundation; either version 2.1 of the License, or
	(at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with this library; if not, see <http://www.gnu.org/licenses/>.
	${0}
snippet GPL3
	${1:one line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
	${0}
snippet LGPL3
	${1:One line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This library is free software; you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published
	by the Free Software Foundation; either version 3 of the License, or
	(at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public License
	along with this library; if not, see <http://www.gnu.org/licenses/>.
	${0}
snippet AGPL3
	${1:one line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as
	published by the Free Software Foundation, either version 3 of the
	License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Affero General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
	${0}
snippet GMGPL linking exception
	As a special exception, if other files instantiate generics from
	this unit, or you link this unit with other files to produce an
	executable, this unit does not by itself cause the resulting
	executable to be covered by the GNU General Public License.
	This exception does not however invalidate any other reasons why the
	executable file might be covered by the GNU Public License.

	${0}
snippet BSD2
	${1:one line to give the program's name and a brief description}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	The views and conclusions contained in the software and documentation
	are those of the authors and should not be interpreted as representing
	official policies, either expressed or implied, of $2.
	${0}
snippet BSD3
	${1:one line to give the program's name and a brief description}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
	3. Neither the name of the ${3:organization} nor the
	names of its contributors may be used to endorse or promote products
	derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	${0}
snippet BSD4
	${1:one line to give the program's name and a brief description}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.
	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.
	3. All advertising materials mentioning features or use of this software
	must display the following acknowledgement:
	This product includes software developed by the ${3:organization}.
	4. Neither the name of the $3 nor the
	names of its contributors may be used to endorse or promote products
	derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY $2 ''AS IS'' AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL $2 BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	${0}
snippet MIT
	${1:one line to give the program's name and a brief description}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the "Software"),
	to deal in the Software without restriction, including without limitation
	the rights to use, copy, modify, merge, publish, distribute, sublicense,
	and/or sell copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included
	in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
	OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	${0}
snippet APACHE
	${1:one line to give the program's name and a brief description}
	Copyright `strftime("%Y")` ${2:`g:snips_author`}

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
	${0}
snippet BEERWARE
	${1:one line to give the program's name and a brief description}
	Copyright `strftime("%Y")` ${2:`g:snips_author`}

	Licensed under the "THE BEER-WARE LICENSE" (Revision 42):
	$2 wrote this file. As long as you retain this notice you
	can do whatever you want with this stuff. If we meet some day, and you think
	this stuff is worth it, you can buy me a beer or coffee in return
	${0}
snippet WTFPL
			DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
					Version 2, December 2004

	Copyright `strftime("%Y")` ${0:`g:snips_author`}

	Everyone is permitted to copy and distribute verbatim or modified
	copies of this license document, and changing it is allowed as long
	as the name is changed.

			DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
	TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

	 0. You just DO WHAT THE FUCK YOU WANT TO.

	${0}
snippet MPL2
	This Source Code Form is subject to the terms of the Mozilla Public
	License, v. 2.0. If a copy of the MPL was not distributed with this
	file, You can obtain one at http://mozilla.org/MPL/2.0/.
	${0}
snippet AGPL
	${1:One line to give the program's name and a brief description.}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")` ${2:`g:snips_author`}

	This program  is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as
	published by the Free Software Foundation, either version 3 of the
	License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Affero General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program. If not, see <http://www.gnu.org/licenses/>.
snippet ISC
	${1:one line to give the program's name and a brief description}
	Copyright `&enc[:2] == "utf" ? "©" : "(c)"` `strftime("%Y")`, ${2:`g:snips_author`}

	Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	${0}
./snippets/actionscript.snippets	[[[1
152
snippet main
	package {
		import flash.display.*;
		import flash.Events.*;

		public class Main extends Sprite {
			public function Main (	) {
				trace("start");
				stage.scaleMode = StageScaleMode.NO_SCALE;
				stage.addEventListener(Event.RESIZE, resizeListener);
			}

			private function resizeListener (e:Event):void {
				trace("The application window changed size!");
				trace("New width:  " + stage.stageWidth);
				trace("New height: " + stage.stageHeight);
			}

		}

	}
snippet class
	${1:public|internal} class ${2:name} ${0:extends } {
		public function $2 (	) {
			("start");
		}
	}
snippet all
	package name {

		${1:public|internal|final} class ${2:name} ${0:extends } {
			private|public| static const FOO = "abc";
			private|public| static var BAR = "abc";

			// class initializer - no JIT !! one time setup
			if Cababilities.os == "Linux|MacOS" {
				FOO = "other";
			}

			// constructor:
			public function $2 (	){
				super2();
				trace("start");
			}
			public function name (a, b...){
				super.name(..);
				lable:break
			}
		}
	}

	function A(){
		// A can only be accessed within this file
	}
snippet switch
	switch(${1}){
		case ${2}:
			${0}
		break;
		default:
	}
snippet case
		case ${1}:
			${0}
		break;
snippet package
	package ${1:package}{
		${0}
	}
snippet wh
	while ${1:cond}{
		${0}
	}
snippet do
	do {
		${0}
	} while (${1:cond})
snippet for enumerate names
	for (${1:var} in ${2:object}){
		${0}
	}
snippet for enumerate values
	for each (${1:var} in ${2:object}){
		${0}
	}
snippet get_set
	function get ${1:name} {
		return ${2}
	}
	function set $1 (newValue) {
		${0}
	}
snippet interface
	interface name {
		function method(${1}):${0:returntype};
	}
snippet try
	try {
		${1:${VISUAL}}
	} catch (error:ErrorType) {
		${2}
	} finally {
		${0}
	}
# For Loop (same as c.snippet)
snippet for for (..) {..}
	for (${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${0}
	}
# Custom For Loop
snippet forr
	for (${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {
		${0}
	}
# If Condition
snippet if
	if ($1) {
		${0:${VISUAL}}
	}
snippet el
	else {
		${0:${VISUAL}}
	}
# Ternary conditional
snippet t Ternary: `condition ? true : false`
	$1 ? $2 : $0
snippet fun
	function ${1:function_name}(${2})${3}
	{
		${0}
	}
# FlxSprite (usefull when using the flixel library)
snippet FlxSprite
	package
	{
		import org.flixel.*

		public class ${1:ClassName} extends ${2:FlxSprite}
		{
			public function $1(${3: X:Number, Y:Number}):void
			{
				super(X,Y);
				${4}
			}

			override public function update():void
			{
				super.update();
				${0}
			}
		}
	}
./snippets/ada.snippets	[[[1
217
snippet wi with
	with ${1};${0}

snippet pac package
	package ${1} is
		${0}
	end $1;

snippet pacb package body
	package body ${1} is
		${0}
	end $1;

snippet ent entry ... when
	entry ${1}(${2}) when ${3} is
	begin
		${0}
	end $1;

snippet task task
	task ${1} is
		entry ${0}
	end $1;

snippet taskb task body
	task body ${1} is
		${2}
	begin
		${0}
	end $1;

snippet acc accept
	accept ${1}(${2}) do
		${0}
	end $1;

snippet prot protected type
	protected type ${1}(${2}) is
		${0}
	end $1;

snippet prob protected body
	protected body ${1} is
		${2}
	begin
		${0}
	end $1;

snippet gen generic type
	generic
		type ${1} is ${2};${0}

snippet ty type
	type ${1} is ${2};${0}

snippet tyd type with default value
	type ${1} is ${2}
		with Default_Value => ${3};${0}

snippet subty subtype
	subtype ${1} is ${2};${0}

snippet dec declare block
	declare
		${1}
	begin
		${0}
	end;

snippet decn declare named block
	${1}:
	declare
		${2}
	begin
		${0}
	end $1;

snippet ifex if expression
	if ${1} then ${2} else ${0}

snippet casex case expression
	case ${1} is
		when ${2} => ${3},${0}

snippet fora for all
	for all ${1} ${2:in} ${3} => ${0}

snippet fors for some
	for some ${1} ${2:in} ${3} => ${0}

snippet if if
	if ${1} then
		${0:${VISUAL}}
	end if;

snippet ife if ... else
	if ${1} then
		${2:${VISUAL}}
	else
		${0}
	end if;

snippet el else
	else
		${0:${VISUAL}}

snippet eif elsif
	elsif ${1} then
		${0}

snippet wh while
	while ${1} loop
		${0:${VISUAL}}
	end loop;

snippet nwh named while
	${1}:
	while ${2} loop
		${0:${VISUAL}}
	end loop $1;

snippet for for
	for ${1:I} in ${2} loop
		${0}
	end loop;

snippet fore for each
	for ${1} of ${2} loop
		${0}
	end loop;

snippet nfor named for
	${1}:
	for ${2:I} in ${3} loop
		${0}
	end loop $1;

snippet nfore named for each
	${1}:
	for ${2} of ${3} loop
		${0}
	end loop $1;

snippet proc procedure
	procedure ${1}(${2}) is
		${3}
	begin
		${0}
	end $1;

snippet procd procedure declaration
	procedure ${1};${0}

snippet fun function
	function ${1}(${2}) return ${3} is
		${4}
	begin
		${0}
	end $1;

snippet fune expression function
	function ${1} return ${2} is
		(${3});${0}

snippet fund function declaration
	function ${1} return ${2};${0}

snippet ret extended return
	return ${1} do
		${0}
	end return;

snippet rec record
	record
		${0}
	end record;

snippet case case
	case ${1} is
		when ${2} => ${3};${0}
	end case;

snippet whe when
	when ${1} => ${2};${0}

snippet wheo when others
	when others => ${1};${0}

snippet lo loop
	loop
		${0}
	end loop;

snippet nlo named loop
	${1}:
	loop
		${0}
	end loop $1;

snippet ex exit when
	exit when ${1};${0}

snippet put Ada.Text_IO.Put
	Ada.Text_IO.Put(${1});${0}

snippet putl Ada.Text_IO.Put_Line
	Ada.Text_IO.Put_Line(${1});${0}

snippet get Ada.Text_IO.Get
	Ada.Text_IO.Get(${1});${0}

snippet getl Ada.Text_IO.Get_Line
	Ada.Text_IO.Get_Line(${1});${0}

snippet newline Ada.Text_IO.New_Line
	Ada.Text_IO.New_Line(${1:1});${0}

./snippets/all.snippets	[[[1
1
extends _
./snippets/alpaca.snippets	[[[1
38
snippet mod
	module ${0:`expand('%:t:r')`}
snippet imp
	import ${0:http}
snippet impt
	import type ${0:option.option}
snippet exp
	export ${0}
snippet expt
	export ${0}
snippet fn
	val ${1:fn} ${2}: fn ${3:'a} -> ${4:'a}
	let $1 ${5} =
		${0:${VISUAL}}
snippet mat
	match ${1} with
	| ${2} -> ${0}
snippet -
	| ${1} -> ${0}
snippet let
	let ${1} = ${2:${VISUAL}} in
	${0}
snippet letf
	let ${1} =
		${0:${VISUAL}}
snippet ty
	type ${1:msg}
		= ${0}
snippet test
	test "${1}" =
		${0:${VISUAL}}
snippet doc
	{-| ${0}
	-}
snippet p
	|> ${0}
snippet ae
	assert.equal ${0}
./snippets/apache.snippets	[[[1
35
# Snippets for code blocks used oftenly in Apache files.
# <Directory>
snippet dir
	<Directory ${1:/}>
		DirectoryIndex ${0:index.html}
		Order Deny,Allow
		Deny from All
	</Directory>
# <FilesMatch>
snippet filesmatch
	<FilesMatch "${1:regex}">
		${0:${VISUAL}}
	</FilesMatch>
# <IfModule>
snippet ifmodule
	<IfModule ${1:mod_example.c}>
		${0:${VISUAL}}
	</IfModule>
# <LimitExcept>
snippet limitexcept
	<LimitExcept ${1:POST GET}>
		${0:${VISUAL}}
	</LimitExcept>
# <Proxy>
snippet proxy
	<Proxy ${1:*}>
		${0:${VISUAL}}
	</Proxy>
# <VirtualHost>
snippet virtualhost
	<VirtualHost ${1:*}:${2:80}>
		ServerAdmin ${3:webmaster@example.com}
		DocumentRoot ${4:/www/example.com}
		ServerName ${0:www.example.com}
	</VirtualHost>
./snippets/arduino.snippets	[[[1
124
snippet setup
	void setup()
	{
		Serial.begin(${1:9600});
		${2}
	}

snippet loop
	void loop()
	{
		${0}
	}

snippet inc
	#include <${1}.h>

snippet def
	#define ${1}

# if
snippet if
	if ($1) {
		${0:${VISUAL}}
	}
# else
snippet el
	else {
		${1}
	}
# else if
snippet elif
	else if ($1) {
		${2}
	}
# ifi
snippet ifi
	if ($1) ${2};

# switch
snippet switch
	switch (${1:/* variable */}) {
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
		default:
			${6}
	}

snippet case
	case ${1:/* variable case */}:
		${2}
		${3:break;}

# for
snippet for
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}
# for (custom)
snippet forr
	for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {
		${5}
	}
# while
snippet wh
	while ($1) {
		${2}
	}
# do... while
snippet do
	do {
		${2}
	} while ($1);
##
## Functions
# function definition
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4}
	}

## IO
# pinMode OUTPUT
snippet pinout
	pinMode(${1}, OUTPUT);
# pinMode INPUT
snippet pinin
	pinMode(${1}, INPUT);
# digitalWrite HIGH
snippet dwHigh
	digitalWrite(${1}, HIGH);
# digitalWrite LOW
snippet dwLow
	digitalWrite(${1}, LOW);
# digitalRead
snippet dr
	digitalRead(${1});
# analogRead
snippet ar
	analogRead(${1});
# analogWrite
snippet aw
	analogWrite(${1});
# serialRead
snippet sr
	Serial.read();
# serialWrite
snippet sw
	Serial.write();
# serial.print
snippet sp
	Serial.print(${1});
# serial.println
snippet sl
	Serial.println(${1});


# delay
snippet dl
	delay(${1});
# millis
snippet ml
	millis();
./snippets/asm.snippets	[[[1
195
snippet scode Start basic code for assembly
	.data


	.text


	.global main


	main:


snippet scodes Start basic code for assembly with _start label
	.data


	.text


	.globl _start


	_start:


snippet lo Long
	$1: .long $2
snippet wo Word
	$1: .word $2
snippet by Byte
	$1: .byte $2
snippet sp Space
	$1: .space $2
snippet ai Ascii
	$1: .ascii "$2"
snippet az Asciz
	$1: .asciz "$2"
snippet ze Zero
	$1: .zero "$2"
snippet qu Quad
	$1: .quad "$2"
snippet si Single
	$1: .single "$2"
snippet do Double
	$1: .single "$2"
snippet fl Float
	$1: .single "$2"
snippet oc Octa
	$1: .single "$2"
snippet sh Short
	$1: .single "$2"
snippet exit0 Exit without error
	movl \$1, %eax
	xorl %ebx, %ebx
	int \$0x80

snippet exit Exit with error
	mov \$1, %eax
	mov $1, %ebx
	int \$0x80

snippet readfstdin Read fixed length text from stdin
	mov \$3, %eax
	mov \$2, %ebx
	mov $1, %ecx
	mov $2, %edx
	int \$0x80

snippet writestdout Write text to stdout
	mov \$4, %eax
	mov \$1, %ebx
	mov $1, %ecx
	mov $2, %edx
	int \$0x80

snippet writestderr Write text to stderr
	mov \$4, %eax
	mov \$2, %ebx
	mov $1, %ecx
	mov $2, %edx
	int \$0x80

snippet * Multiplication
	mov $1, %eax
	mul $2

snippet / Division
	mov $1, %eax
	div $2

snippet jmpl Conditional lower jump
	cmp $1, $2
	jl $3 

snippet jmple Conditional lower or equal jump
	cmp $1, $2
	jle $3 

snippet jmpe Conditional equal jump
	cmp $1, $2
	je $3 

snippet jmpn Conditional not equal jump
	cmp $1, $2
	jn $3

snippet jmpg Conditional greater jump
	cmp $1, $2
	jg $3

snippet jmpge Conditional greater or equal jump
	cmp $1, $2
	je $3

snippet loopn Loop n times
	mov $1, %ecx

	et_for:
		$2

		loop et_for

snippet loopnn Loop n-1 times
	mov $1, %ecx
	dec %ecx

	et_for:
		$2

		loop et_for

snippet loopv Loop through a vector
	lea $1, %edi
	xor %ecx, %ecx

	et_for:
		cmp %ecx, $2
		je $3

		$4

		inc %ecx
		jmp et_for

snippet mul Multiply
	xor %edx, %edx
	mov $1, %eax
	mul $2
snippet mul64 Multiply numbers greater than 2^32
	mov $1, %edx
	mov $2, %eax
	mul $3
snippet div Divide
	xor %edx, %edx
	mov $1, %eax
	div $2
snippet div64 Divide numbers greater than 2^32
	mov $1, %edx
	mov $2, %eax
	div $3
snippet pr Call printf
	pushl $1
	call printf
	popl $2
snippet sc Call scanf
	pushl $1
	call scanf
	popl $2
snippet mindex Current index from a matrix
	xor %edx, %edx
	movl $1, %eax
	mull $2
	addl $3, %eax
snippet ffl Call fflush
	pushl \$0
	call fflush
	popl $1
snippet at Call atoi
	pushl $1
	call atoi
	popl $2
snippet len Call strlen
	pushl $1
	call strlen
	popl $2
snippet proc Basic procedure
	$1:
	pushl %ebp
	movl %esp, %ebp

	$2

	popl %ebp
	ret
./snippets/autoit.snippets	[[[1
66
snippet if
	If $1 Then
		${0:; True code}
	EndIf
snippet el
	Else
		${0}
snippet eif
	ElseIf $1 Then
		${0:; True code}
# If/Else block
snippet ife
	If $1 Then
		${2:; True code}
	Else
		${0:; Else code}
	EndIf
# If/ElseIf/Else block - because there is eif this is not really neccessary
snippet ifelif
	If ${1:condition 1} Then
		${2:; True code}
	ElseIf ${3:condition 2} Then
		${4:; True code}
	Else
		${0:; Else code}
	EndIf
# Switch block
snippet switch
	Switch ($1)
	Case ${2:case1}:
		${3:; Case 1 code}
	Case Else:
		${0:; Else code}
	EndSwitch
# Select block
snippet select
	Select ($1)
	Case ${2:case1}:
		${3:; Case 1 code}
	Case Else:
		${0:; Else code}
	EndSelect
# While loop
snippet wh
	While ($1)
		${0:; code...}
	WEnd
# For loop
snippet for
	For ${1:n} = ${3:1} to ${2:count}
		${0:; code...}
	Next
# New Function
snippet func
	Func ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${0:Return}
	EndFunc
# Message box
snippet msg
	MsgBox(${0:MsgType}, ${1:"Title"}, ${2:"Message Text"})
# Debug Message
snippet debug
	MsgBox(0, "Debug", ${0:"Debug Message"})
# Show Variable Debug Message
snippet showvar
	MsgBox(0, "${0:VarName}", $1)
./snippets/awk.snippets	[[[1
82
# cannot use /usr/bin/env because it does not support parameters (as -f)
snippet #! #!/usr/bin/awk -f
	#!/usr/bin/awk -f
# @include is a gawk extension
snippet inc @include
	@include "${1}"${0}
# @load is a gawk extension
snippet loa @load
	@load "${1}"${0}
snippet beg BEGIN { ... }
	BEGIN {
		${0}
	}
# BEGINFILE is a gawk extension
snippet begf BEGINFILE { ... }
	BEGINFILE {
		${0}
	}
snippet end END { ... }
	END {
		${0}
	}
# ENDFILE is a gawk extension
snippet endf ENDFILE { ... }
	ENDFILE {
		${0}
	}
snippet pri print
	print ${1:"${2}"}${0}
snippet printf printf
	printf("${1:%s}\n", ${2})${0}
snippet ign IGNORECASE
	IGNORECASE = ${1:1}
snippet if if {...}
	if (${1}) {
		${0:${VISUAL}}
	}
snippet ife if ... else ...
	if (${1}) {
		${2:${VISUAL}}
	} else {
		${0}
	}
snippet eif else if ...
	else if (${1}) {
		${0}
	}
snippet el else {...}
	else {
		${0}
	}
snippet wh while
	while (${1}) {
		${2}
	}
snippet do do ... while
	do {
		${0}
	} while (${1})
snippet for for
	for (${2:i} = 0; i < ${1:n}; ${3:++i}) {
		${0}
	}
snippet fore for each
	for (${1:i} in ${2:array}) {
		${0}
	}
# the switch is a gawk extension
snippet sw switch
	switch (${1}) {
	case ${2}:
		${3}
		break
	default:
		${0}
		break
	}
# the switch is a gawk extension
snippet case case
	case ${1}:
		${0}
		break
./snippets/bash.snippets	[[[1
25
extends sh

# Shebang
snippet #!
	#!/usr/bin/env bash

snippet s#!
	#!/usr/bin/env bash
	set -eu

snippet if
	if [[ $1 ]]; then
		${0:${VISUAL}}
	fi
snippet elif
	elif [[ $1 ]]; then
		${0:${VISUAL}}
snippet wh
	while [[ $1 ]]; do
		${0:${VISUAL}}
	done
snippet until
	until [[ $1 ]]; do
		${0:${VISUAL}}
	done
./snippets/c.snippets	[[[1
394
## Main
# main
snippet main
	int main(int argc, char *argv[])
	{
		${0}
	}
# main(void)
snippet mainn
	int main(void)
	{
		${0}
	}
##
## Preprocessor
# #include <...>
snippet inc
	#include <${1:stdio}.h>
	$0
# #include "..."
snippet Inc
	#include "${1:`vim_snippets#Filename("$1.h")`}"
	$0
# ifndef...define...endif
snippet ndef
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif /* ifndef $1 */
# define
snippet def
	#define
# ifdef...endif
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
# if
snippet #if
	#if ${1:FOO}
		${0:${VISUAL}}
	#endif
# header include guard
snippet once
	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}

	#define $1

	${0}

	#endif /* end of include guard: $1 */
# Disable C++ name mangling in C headers
snippet nocxx
	#ifdef __cplusplus
	extern "C" {
	#endif

	${0}

	#ifdef __cplusplus
	} /* extern "C" */
	#endif
##
## Control Statements
# if
snippet if
	if (${1:true}) {
		${0:${VISUAL}}
	}
snippet ife
	if (${1:true}) {
		${2:${VISUAL}}
	} else {
		${0}
	}
# else
snippet el
	else {
		${0:${VISUAL}}
	}
# else if
snippet elif
	else if (${1:true}) {
		${0:${VISUAL}}
	}
# ifi
snippet ifi
	if (${1:true}) ${0};
# ternary
snippet t Ternary: `condition ? true : false`
	$1 ? $2 : $0
# switch
snippet switch
	switch (${1:/* variable */}) {
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
		default:
			${6}
	}
# switch without default
snippet switchndef
	switch (${1:/* variable */}) {
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
	}
# case
snippet case
	case ${1:/* variable case */}:
		${2}
		${3:break;}
snippet ret
	return ${0};
snippet ex
	exit($0);
##
## Loops
# for
snippet for
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}
# for (custom)
snippet forr
	for (int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++}) {
		${5}
	}
# while
snippet wh
	while (${1:1}) {
		${0:${VISUAL}}
	}
snippet wht
	while (true) {
		${0:${VISUAL}}
	}
# do... while
snippet do
	do {
		${0:${VISUAL}}
	} while ($1);
##
## Functions
# function definition
snippet fun
	${1:void} ${2:function_name}(${3})
	{
		${4}
	}
# function definition with zero parameters
snippet fun0
	${1:void} ${2:function_name}()
	{
		${3}
	}
# function definition with Doxygen documentation
snippet dfun0
	/*! \brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * \return ${3:Return parameter description}
	 */
	${4:void} ${5:function_name}()
	{
		${6}
	}
# function definition with one parameter
snippet fun1
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter})
	{
		${5}
	}
# function definition with one parameter with  Doxygen documentation
snippet dfun1
	/*! \brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * \param $3 ${4:Parameter description}
	 * \return ${5:Return parameter description}
	 */
	${6:void} ${7:function_name}(${8:Type} ${3:Parameter})
	{
		${9}
	}
# function definition with two parameters
snippet fun2
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})
	{
		${7}
	}
# function definition with two parameters with  Doxygen documentation
snippet dfun2
	/*! \brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * \param $3 ${4:Parameter description}
	 * \param $5 ${6:Parameter description}
	 * \return ${7:Return parameter description}
	 */
	${8:void} ${9:function_name}(${10:Type} ${3:Parameter}, ${11:Type} ${5:Parameter})
	{
		${12}
	}
# function definition with three parameters
snippet fun3
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})
	{
		${9}
	}
# function definition with three parameters with  Doxygen documentation
snippet dfun3
	/*! \brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * \param $3 ${4:Parameter description}
	 * \param $5 ${6:Parameter description}
	 * \param $7 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${10:void} ${11:function_name}(${12:Type} ${3:Parameter}, ${13:Type} ${5:Parameter}, ${14:Type} ${7:Parameter})
	{
		${15}
	}
# function declaration
snippet fund
	${1:void} ${2:function_name}(${3});
##
## Types
# typedef
snippet td
	typedef ${1:int} ${2:MyCustomType};
# struct
snippet st
	/*! \struct $1
	 *  \brief ${3:Brief struct description}
	 *
	 *  ${4:Detailed description}
	 */
	struct ${1:`vim_snippets#Filename('$1_t', 'name')`} {
		${2:Data} /*!< ${4:Description} */
	}${5: /* optional variable list */};
# typedef struct
snippet tds
	/*! \struct $2
	 *  \brief ${5:Brief struct description}
	 *
	 *  ${6:Detailed description}
	 */
	typedef struct ${2:_$1 }{
		m_${3:Data} /*!< ${4:Description} */
	} ${1:`vim_snippets#Filename('$1_t', 'name')`};

snippet enum
	/*! \enum $1
	 *
	 *  ${2:Detailed description}
	 */
	enum ${1:name} { ${0} };
# typedef enum
snippet tde
	/*! \enum $2
	 *
	 *  ${4:Detailed description}
	 */
	typedef enum {
		${1:Data} /*!< ${3:Description} */
	} ${2:foo};
##
## Input/Output
# printf
snippet pr
	printf("${1:%s}\n"${2});
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});
snippet prd
	printf("${1:} = %d\n", $1);
snippet prf
	printf("${1:} = %f\n", $1);
snippet prx
	printf("${1:} = %${2}\n", $1);
snippet warn
	warn("${1:%s}"$0);
snippet warnx
	warnx("${1:%s}"$0);
snippet err
	err(${1:1}, "${2:%s}"$0);
snippet errx
	errx(${1:1}, "${2:%s}"$0);
# getopt
snippet getopt
	int choice;
	while (1)
	{
		static struct option long_options[] =
		{
			/* Use flags like so:
			{"verbose",	no_argument,	&verbose_flag, 'V'}*/
			/* Argument styles: no_argument, required_argument, optional_argument */
			{"version", no_argument,	0,	'v'},
			{"help",	no_argument,	0,	'h'},
			${1}
			{0,0,0,0}
		};

		int option_index = 0;

		/* Argument parameters:
			no_argument: " "
			required_argument: ":"
			optional_argument: "::" */

		choice = getopt_long( argc, argv, "vh",
					long_options, &option_index);

		if (choice == -1)
			break;

		switch( choice )
		{
			case 'v':
				${2}
				break;

			case 'h':
				${3}
				break;

			case '?':
				/* getopt_long will have already printed an error */
				break;

			default:
				/* Not sure how to get here... */
				return EXIT_FAILURE;
		}
	}

	/* Deal with non-option arguments here */
	if ( optind < argc )
	{
		while ( optind < argc )
		{
			${0}
		}
	}

## Assertions
snippet asr
	assert($1);

snippet anl
	assert(${1:ptr} != NULL);

## Dynamic Allocation
snippet mlc
	${1:ptr} = (${2:type}*) malloc(sizeof($2));

snippet clc
	${1:ptr} = (${2:type}*) calloc(${3:size}, sizeof($2));

snippet rlc
	${1:ptr} = realloc($1, ${2:size} * sizeof(${3:type}));

snippet mlcd
	${1:type} ${2:ptr} = ($1*) malloc(sizeof($1));

snippet clcd
	${1:type} ${2:ptr} = ($1*) calloc(${3:size}, sizeof($1));

snippet fre
	free(${1:ptr});

##
# TODO section
snippet todo
	/*! TODO: ${1:Todo description here}
	 *  \todo $1
	 */
## Miscellaneous
# This is kind of convenient
snippet .
	[${1}]

snippet asm
	__asm__ __volatile__(
	"${0}\n\t"
	:
	:
	);
./snippets/chef.snippets	[[[1
204
# Opscode Chef Cookbook Recipe Resources
# Snippet by: Mike Smullin <mike@smullindesign.com>
# Based on: http://wiki.opscode.com/display/chef/Resources

# @TODO: Include Meta attributes and actions in all snippets
# @TODO: Finish writing snippets for remaining Resources

snippet cookbook_file
	# Cookbook File resource
	cookbook_file ${1:"/path/to/file"} do # The remote path where the file will reside
		${2:#}backup ${3} # How many backups of this file to keep. Set to false  if you want no backups
		${4:#}group ${5} # The group owner of the file (string or id)
		${6:#}mode ${7} # The octal mode of the file - e.g. 0755
		${8:#}owner ${9} # The owner for the file
		${10:#}source ${11} # The basename of the source file
		${12:#}cookbook ${13} # The cookbook this file is stored in

		${14:#}${15: action :create} # Create this file (Default)
		${16:#}${17: action :create_if_missing} # Create only if it doesn't exist yet
		${18:#}${0: action :delete} # Delete this file
	end

snippet execute
	# Execute resource
	execute ${1:"command to execute"} do # The command to execute
		${2:#}creates ${3:nil} # A file this command creates - if the file exists, the command will not be run.
		${4:#}cwd ${5:nil} # Current working directory to run the command from.
		${6:#}environment ${7:nil} # A hash of environment variables to set before running this command.
		${8:#}group ${9:nil} # A group name or group ID that we should change to before running this command.
		${10:#}path ${11:nil} # An array of paths to use when searching for the command. Nil uses system path.
		${12:#}returns ${13:0} # The return value of the command - this resource raises an exception if the return value does not match.
		${14:#}timeout ${15:nil} # How many seconds to let the command run before timing it out.
		${16:#}user ${17:nil} # A user name or user ID that we should change to before running this command.
		${18:#}umask ${19:nil} # Umask for files created by the command

		${20:#}${21:action :run} # Run this command (Default)
		${22:#}${0:action :nothing} # Do not run this command
	end

snippet link
	# Link resource
	link ${1:"/target/file"} do # The file name of the link
		${2:#}to ${3} # The real file you want to link to
		${4:#}link_type ${5:symbolic} # Either :symbolic or :hard
		${6:#}owner ${7} # The owner of the symlink
		${8:#}group ${9} # The group of the symlink

		${10:#}${11:action :create} # Create a link (Default)
		${12:#}${0:action :delete} # Delete a link
	end

snippet package
	# Package resource
	package ${1:"package_name"} do # Name of the package to install
		${2:#}version ${3:nil} # The version of the package to install/upgrade
		${4:#}response_file ${5:nil} # An optional response file - used to pre-seed packages (note: the file is fetched by Remote File)
		${6:#}source ${7} # Used to provide an optional package source for providers that use a local file (rubygems, dpkg and rpm)
		${8:#}options ${9:nil} # Add additional options to the underlying package command
		${10:#}gem_binary ${11:gem} # A gem_package attribut to specify a gem binary. Useful for installing ruby 1.9 gems while running chef in ruby 1.8

		${12:#}${13:action :install} # Install a package - if version is provided, install that specific version (Default)
		${14:#}${15:action :upgrade} # Upgrade a package - if version is provided, upgrade to that specific version
		${16:#}${17:action :remove} # Remove a package
		${18:#}${0:action :purge} # Purge a package (this usually entails removing configuration files as well as the package itself)
	end

snippet service
	# Service resource
	service ${1:"service_name"} do # Name of the service
		${2:#}enabled ${3:nil} # Whether the service is enabled at boot time
		${4:#}running ${5:nil} # Make sure the service is running. Start if stopped
		${6:#}pattern ${7} # Pattern to look for in the process table
		${8:#}start_command ${9:nil} # Command used to start this service
		${10:#}stop_command ${11:nil} # Command used to stop this service
		${12:#}status_command ${13:nil} # Command used to check the service run status
		${14:#}restart_command ${15:nil} # Command used to restart this service
		${16:#}reload_command ${17:nil} # Command used to tell this service to reload its configuration
		${18:#}supports ${19:false} # Features this service supports, ie :restart, :reload, :status

		${20:#}${21:action :enable} # Enable this service
		${22:#}${23:action :disable} # Disable this service
		${24:#}${25:action :nothing} # Don't do anything with this service (Default)
		${26:#}${27:action :start} # Start this service
		${28:#}${29:action :stop} # Stop this service
		${30:#}${31:action :restart} # Restart this service
		${32:#}${0:action :reload} # Reload the configuration for this service
	end

snippet file
	# File resource
	file ${1:"/path/to/file"} do # Path to the file
		${2:#}backup ${3:5} # How many backups of this file to keep. Set to false if you want no backups.
		${4:#}owner ${5} # The owner for the file
		${6:#}group ${7} # The group owner of the file (string or id)
		${8:#}mode ${9} # The octal mode of the file (4-digit format)
		${10:#}content ${11:nil} # A string to write to the file. This will replace any previous content if set

		${12:#}${13:action :create} # Create this file (Default)
		${14:#}${15:action :delete} # Delete this file
		${16:#}${0:action :touch} # Touch this file (update the mtime/atime)
	end

snippet directory
	# Directory resource
	directory ${1:"/path/to/dir"} do # The path to the directory
		${2:#}group ${3} # The group owner of the directory (string or id)
		${4:#}mode ${5} # The octal mode of the directory, eg 0755
		${6:#}owner ${7} # The owner for the directory
		${10:#}recursive ${11:false} # When deleting the directory, delete it recursively. When creating the directory, create recursively (ie, mkdir -p)

		${12:#}${13:action :create} # Create this directory (Default)
		${14:#}${0:action :delete} # Delete this directory
	end

snippet template
	# Template resource
	template ${1:"/path/to/file"} do # Path to the file
		${2:#}cookbook ${3:nil} # Specify the cookbook where the template is located, default is current cookbook
		${4:#}source ${5:nil} # Template source file. Found in templates/default for the cookbook
		${6:#}variables ${7} # Variables to use in the template
		${8:#}local ${9:false} # Is the template already present on the node?
		${10:#}backup ${11:5} # How many backups of this file to keep. Set to false if you want no backups.
		${12:#}owner ${13} # The owner for the file
		${14:#}group ${15} # The group owner of the file (string or id)
		${16:#}mode ${17} # The octal mode of the file (4-digit format)
		${18:#}content ${19:nil} # A string to write to the file. This will replace any previous content if set

		${20:#}${21:action :create} # Create the file (Default)
		${22:#}${23:action :delete} # Delete this file
		${24:#}${0:action :touch} # Touch this file (update the mtime/atime)
	end

snippet svn
	# SCM Resource, Chef::Provider::Subversion
	svn ${1:"/destination/path"} do # Path to clone/checkout/export the source to
		${2:#}repository ${3} # URI of the repository
		${4:#}revision ${5:"HEAD"} # revision to checkout. can be symbolic, like "HEAD" or an SCM specific revision id
		${6:#}reference ${7} # (Git only) alias for revision
		${8:#}user ${9:nil} # System user to own the checked out code
		${10:#}group ${11:nil} # System group to own the checked out code
		${12:#}svn_username ${13} # (Subversion only) Username for Subversion operations
		${14:#}svn_password ${15} # (Subversion only) Password for Subversion operations
		${16:#}svn_arguments ${17} # (Subversion only) Extra arguments passed to the subversion command

		${18:#}${19:action :sync} # Update the source to the specified revision, or get a new checkout (Default)
		${20:#}${21:action :checkout} # Checkout the source. Does nothing if a checkout is available
		${22:#}${0:action :export} # Export the source, excluding or removing any version control artifacts
	end

snippet git
	# SCM Resource, Chef::Provider::Git
	git ${1:"/destination/path"} do # Path to clone/checkout/export the source to
		${2:#}repository ${3} # URI of the repository
		${4:#}revision ${5:"HEAD"} # revision to checkout. can be symbolic, like "HEAD" or an SCM specific revision id
		${6:#}reference ${7} # (Git only) alias for revision
		${8:#}user ${9:nil} # System user to own the checked out code
		${10:#}group ${11:nil} # System group to own the checked out code
		${12:#}depth ${13:nil} # (Git only) Number of past revisions to include in Git shallow clone
		${14:#}enable_submodules ${15:"false"} # (Git only) performs a submodule init and submodule update
		${16:#}remote ${17:"origin"} # (Git only) remote repository to use for syncing an existing clone
		${18:#}ssh_wrapper ${19} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.

		${20:#}${21:action :sync} # Update the source to the specified revision, or get a new clone (Default)
		${22:#}${23:action :checkout} # Clone the source. Does nothing if a checkout is available
		${24:#}${0:action :export} # Export the source, excluding or removing any version control artifacts
	end

snippet deploy
	# Deploy resource
	deploy ${1:"/deploy/dir/"} do # Path to deploy to
		${2:#}deploy_to ${3} # The "meta root" for your application.
		${4:#}repository ${5} # URI of the repository
		${6:#}repo ${7} # alias for repository
		${8:#}revision ${9:"HEAD"} # revision to checkout. can be symbolic, like "HEAD" or an SCM specific revision id
		${10:#}branch ${11} # alias for revision
		${12:#}user ${13:nil} # System user to run the deploy as
		${14:#}group ${15:nil} # System group to run the deploy as
		${16:#}svn_username ${17} # (Subversion only) Username for Subversion operations}
		${18:#}svn_password ${19} # (Subversion only) Password for Subversion operations}
		${20:#}svn_arguments ${21} # (Subversion only) Extra arguments passed to the subversion command}
		${22:#}shallow_clone ${23:nil} # (Git only) boolean, true sets clone depth to 5
		${24:#}enable_submodules ${25:false} # (Git only) performs a submodule init and submodule update
		${26:#}remote ${27:"origin"} # (Git only) remote repository to use for syncing an existing clone
		${28:#}ssh_wrapper ${29} # (Git only) path to a wrapper script for running SSH with git. GIT_SSH environment variable is set to this.
		${30:#}git_ssh_wrapper ${31} # alias for ssh_wrapper
		${32:#}scm_provider ${33:Chef::Provider::Git} # SCM Provider to use.
		${34:#}repository_cache ${35: "cached-copy"} # Name of the subdirectory where the pristine copy of your app's source is kept
		${36:#}environment ${37} # A hash of the form {"ENV_VARIABLE"=>"VALUE"}}
		${38:#}purge_before_symlink ${39:%w(log tmp/pids public/system)} # An array of paths, relative to app root, to be removed from a checkout before symlinking
		${40:#}create_dirs_before_symlink ${41:%w(tmp public config)} # Directories to create before symlinking. Runs after purge_before_symlink
		${42:#}symlinks ${43:"system" => "public/system", "pids" => "tmp/pids", "log" => "log"} # A hash that maps files in the shared directory to their paths in the current release
		${44:#}symlink_before_migrate ${45:"config/database.yml" => "config/database.yml"} # A hash that maps files in the shared directory into the current release. Runs before migration
		${46:#}migrate ${47:false} # Should the migration command be executed? (true or false)
		${48:#}migration_command ${49} # A string containing a shell command to execute to run the migration
		${50:#}restart_command ${51:nil} # A code block to evaluate or a string containing a shell command
		${52:#}before_migrate ${53:"deploy/before_migrate.rb"} # A block or path to a file containing chef code to run before migrating
		${54:#}before_symlink ${55:"deploy/before_symlink.rb"} # A block or path to a file containing chef code to run before symlinking
		${56:#}before_restart ${57:"deploy/before_restart.rb"} # A block or path to a file containing chef code to run before restarting
		${58:#}after_restart ${59:"deploy/after_restart.rb"} # A block or path to a file containing chef code to run after restarting

		${60:#}${61::deploy} # Deploy the application (Default)
		${62:#}${63::force_deploy} # For the revision deploy strategy, this removes any existing release of the same code version and re-deploys in its place
		${64:#}${0::rollback} # Rollback the application to the previous release
	end
./snippets/clojure.snippets	[[[1
87
snippet comm
	(comment
		${0})
snippet condp
	(condp ${1:pred} ${2:expr}
		${0})
snippet def
	(def ${0})
snippet defm
	(defmethod ${1:multifn} "${2:doc-string}" ${3:dispatch-val} [${4:args}]
		${0:code})
snippet defmm
	(defmulti ${1:name} "${2:doc-string}" ${0:dispatch-fn})
snippet defma
	(defmacro ${1:name} "${2:doc-string}" ${0:dispatch-fn})
snippet defn
	(defn ${1:name} "${2:doc-string}" [${3:arg-list}]
		${0:code})
snippet defp
	(defprotocol ${1:name}
		${0:code})
snippet defr
	(defrecord ${1:name} [${2:fields}]
		${3:protocol}
		${0:code})
snippet deft
	(deftest ${1:name}
		(is (= ${0:assertion})))
snippet is
	(is (= ${1} ${0}))
snippet defty
	(deftype ${1:Name} [${2:fields}]
		${3:Protocol}
		${0:code})
snippet doseq
	(doseq [${1:elem} ${2:coll}]
		${0:code})
snippet fn
	(fn [${1:arg-list}] ${0:code})
snippet if
	(if ${1:test-expr}
		${2:then-expr}
		${0:else-expr})
snippet if-let
	(if-let [${1:result} ${2:test-expr}]
		(${3:then-expr} $1)
		(${0:else-expr}))
snippet imp
	(:import [${1:package}])
		& {:keys [${1:keys}] :or {${0:defaults}}}
snippet let
	(let [${1:name} ${2:expr}]
		${0:code})
snippet letfn
	(letfn [(${1:name}) [${2:args}]
		${0:code})])
snippet map
	(map ${1:func} ${0:coll})
snippet mapl
	(map #(${1:lambda}) ${0:coll})
snippet met
	(${1:name} [${2:this} ${3:args}]
		${0:code})
snippet ns
	(ns ${0:name})
snippet dotimes
	(dotimes [_ 10]
		(time
			(dotimes [_ ${1:times}]
				${0:code})))
snippet pmethod
	(${1:name} [${2:this} ${0:args}])
snippet refer
	(:refer-clojure :exclude [${0}])
snippet require
	(:require [${1:namespace} :as [${0}]])
snippet use
	(:use [${1:namespace} :only [${0}]])
snippet print
	(println ${0})
snippet reduce
	(reduce ${1:(fn [p n] ${3})} ${2})
snippet when
	(when ${1:test} $0)
snippet when-let
	(when-let [${1:result} ${2:test}]
		$0)
./snippets/cmake.snippets	[[[1
83
snippet init
	cmake_minimum_required(VERSION ${1:2.8.2})
	project(${2:ProjectName})

	find_package(${3:library})

	include_directories(${$3_INCLUDE_DIRS})

	add_subdirectory(${0:src})

	add_executable($2)

	target_link_libraries($2 ${$3_LIBRARIES})

snippet proj
	project(${0:Name})

snippet min
	cmake_minimum_required(VERSION ${0:2.8.2})

snippet include
	include_directories(${${0:include_dir}})

snippet find
	find_package(${1:library} ${0:REQUIRED})

snippet glob
	file(glob ${1:srcs} *.${0:cpp})

snippet subdir
	add_subdirectory(${0:src})

snippet lib
	add_library(${1:lib} ${${0:srcs}})

snippet link
	target_link_libraries(${1:bin} ${0:somelib})

snippet bin
	add_executable(${1:bin})

snippet set
	set(${1:var} ${0:val})

snippet dep
	add_dependencies(${1:target}
		${0:dep}
	)

snippet Ext_url
	include(ExternalProject)
	ExternalProject_Add(${1:googletest}
	  URL ${2:http://googletest.googlecode.com/files/gtest-1.7.0.zip}
	  URL_HASH SHA1=${3:f85f6d2481e2c6c4a18539e391aa4ea8ab0394af}
	  SOURCE_DIR "${4:${CMAKE_BINARY_DIR}/gtest-src}"
	  BINARY_DIR "${0:${CMAKE_BINARY_DIR}/gtest-build}"
	  CONFIGURE_COMMAND ""
	  BUILD_COMMAND     ""
	  INSTALL_COMMAND   ""
	  TEST_COMMAND      ""
	)

snippet Ext_git
	include(ExternalProject)
	ExternalProject_Add(${1:googletest}
	  GIT_REPOSITORY    ${2:https://github.com/google/googletest.git}
	  GIT_TAG           ${3:master}
	  SOURCE_DIR        "${4:${CMAKE_BINARY_DIR}/googletest-src}"
	  BINARY_DIR        "${0:${CMAKE_BINARY_DIR}/googletest-build}"
	  CONFIGURE_COMMAND ""
	  BUILD_COMMAND     ""
	  INSTALL_COMMAND   ""
	  TEST_COMMAND      ""
	)

snippet props
	set_target_properties(${1:target}
		${2:properties} ${3:compile_flags}
		${0:"-O3 -Wall -pedantic"}
	)

snippet test
	add_test(${1:ATestName} ${0:testCommand --options})
./snippets/codeigniter.snippets	[[[1
171
# Based on nebjak/snipmate.vim/snippets/php.snippets

# Controller
snippet ci_controller
	<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

	class ${1:ClassName} extends CI_Controller
	{
		function __construct()
		{
			parent::__construct();
			${2:// code...}
		}

		function ${3:index}()
		{
			${4:// code...}
		}
	}
# Model
snippet ci_model
	<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

	class ${1:ClassName_model} extends CI_Model
	{
		function __construct()
		{
			parent::__construct();
			${2:// code...}
		}
	} 
snippet ci_model_crudl
	<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

	class ${1:ClassName_model} extends CI_Model
	{
		private $table = '${2:table_name}';

		function __construct()
		{
			parent::__construct();
			${3:// code...}
		}

		public function create($data)
		{
			if($this->db->insert($this->table, $data))
				return true;
			else
				return false;
		}

		public function read($id)
		{
			return $this->db->get_where($this->table, array('id', $id))->result();
		}

		public function update($id, $data)
		{
			if($this->db->update($this->table, $data, array('id' => $id)))
				return true;
			else
				return false;
		}

		public function delete($id)
		{
			if(is_array($id))
			{
				$this->db->trans_start();
				foreach($id as $elem)
					$this->db->delete($this->table, array('id' => $elem));
				$this->db->trans_complete();
			}
			else
			{
				if($this->db->delete($this->table, array('id' => $id)))
					return true;
				else
					return false;
			}
		}

		public function listRows($limit = null, $offset = 0)
		{
			if(!is_null($limit))
				$this->db->limit($limit, $offset);
			return $this->db->get($this->table)->result();
		}
	}
# Load view
snippet ci_load-view
	$this->load->view("${1:view_name}", $${2:data});${3}
# DB Class snippets
snippet ci_db-insert
	$this->db->insert("${1:table}", $${2:data});${3}
snippet ci_db-select
	$this->db->select("${1:id, ...}");${2}
snippet ci_db-from
	$this->db->from("${1:table}");${2}
snippet ci_db-join
	$this->db->join("${1:table}", "$2", "${3:type}");${4}
snippet ci_db-where
	$this->db->where("${1:key}", "${2:value}");${3}
snippet ci_db-or_where
	$this->db->or_where("${1:key}", "${2:value}");${3}
snippet ci_db-get
	$this->db->get("${1:table}", ${2:limit}, ${3:offset});${4}
snippet ci_db-delete
	$this->db->delete("${1:table}", "${2:where}");${3}
snippet ci_db-update
	$this->db->update("${1:table}", $${2:set}, $${3:where});${4}
# Input Class snippets
snippet ci_input-post
	$this->input->post("${1:index}");${2}
snippet ci_input-get
	$this->input->get("${1:index}");${2}
snippet ci_input-cookie
	$this->input->cookie("${1:index}");${2}
snippet ci_input-server
	$this->input->server("${1:index}");${2}
snippet ci_input-user_agent
	$this->input->user_agent();${1}
snippet ci_input-is_ajax_request
	$this->input->is_ajax_request();${1}
snippet ci_input-is_cli_request
	$this->input->is_cli_request();${1}
# Form Validation Class and Form Helper snippets
snippet ci_form_validation-set_rules
	$this->form_validation->set_rules("${1:field}", "${2:label}", "${3:trim|required}");${4}
snippet ci_form_open
	form_open("${1:action}");${2}
snippet ci_form_open_multipart
	form_open_multipart("${1:action}");${2}
snippet ci_form_hidden
	form_hidden("${1:name}", "${2:value}");${3}
snippet ci_form_input
	form_input("${1:name}", "${2:value}");${3}
snippet ci_form_password
	form_password("${1:name}", "${2:value}");${3}
snippet ci_form_upload
	form_upload("${1:name}", "${2:value}");${3}
snippet ci_form_textarea
	form_textarea("${1:name}", "${2:value}");${3}
snippet ci_form_dropdown
	form_dropdown("${1:name}", $${2:options}, $${3:selected);${4}
snippet ci_form_checkbox
	form_checkbox("${1:name}", "${2:value}");${3}
snippet ci_form_radio
	form_radio("${1:name}", "${2:value}");${3}
snippet ci_form_submit
	form_submit("${1:name}", "${2:value}");${3}
snippet ci_form_reset
	form_reset("${1:name}", "${2:value}");${3}
snippet ci_form_button
	form_button("${1:name}", "${2:value}");${3}
snippet ci_form_label
	form_label("${1:label text}", "${2:id}");${3}
snippet ci_form_close
	form_close();${1}
snippet ci_validation_errors
	validation_errors();${1}
# Session Class snippets
snippet ci_session_userdata
	$this->session->userdata("${1:item}");${2}
snippet ci_session_set_userdata
	$this->session->set_userdata($${1:array});${2}
snippet ci_session_flashdata
	$this->session->flashdata("${1:item}");${2}
snippet ci_session_set_flashdata
	$this->session->set_flashdata("${1:item}", "${2:value}");${3}
./snippets/coffee/angular_coffee.snippets	[[[1
116
## Global Snippets
# Define a new Angular Controller;
# You can change the controller name and parameters
snippet ngc
	${1:controllerName} = (${2:scope}, ${3:injectables}) ->
		${4}
# angular.foreach loop
snippet ngfor
	angular.forEach ${1:iterateOver}, (value, key) ->
		${2}
## Module Based Snippets
# A new angular module without a config function
snippet ngm
	angular.module '${1:moduleName}', [${2:moduleDependencies}]
	${3}
# A new angular module without a config function and a variable assignment
snippet ngma
	${1:moduleName} = angular.module '$1', [${2:moduleDeps}]
	${3}
# A new angular module with a config function
snippet ngmc
	${1:moduleName} = angular.module('$1', [${2:moduleDeps}], (${3:configDeps}) ->
		${4}
	)
# A factory in a module
snippet ngmfa
	factory '${1:factoryName}', (${2:dependencies}) ->
		${3}
# Define an Angular Module Service to be attached to a previously defined module
# You can change the service name and service injectables
snippet ngms
	service '${1:serviceName}', (${2:injectables}) ->
		${3}
# Define an Angular Module Filter to be attached to a previously defined module
# You can change the filter name
snippet ngmfi
	filter '${1:filterName}', (${2:injectables}) ->
		(input, ${3:args}) ->
			${4}
## Route Based Snippets
# Defines a when condition of an AngularJS route
snippet ngrw
	$routeProvider.when '${1:url}',
		templateUrl: '${2:templateUrl}'
		controller: '${3:controller}'
	${4}
# Defines a when condition of an AngularJS route with the resolve block
snippet ngrwr
	$routeProvider.when '${1:url}',
		templateUrl: '${2:templateUrl}'
		controller: '${3:controller}'
		resolve:
			${4}
	${5}
# Defines an otherwise condition of an AngularJS route
snippet ngro
	$routeProvider.otherwise redirectTo: '${1:url}'
	${2}
## Scope Related Snippets
# Define a new $scope'd function (usually inside an AngularJS Controller)
# You can change the function name and arguments
snippet $f
	$scope.${1:functionName} = (${2:args}) ->
		${3}
# Defines a new $scope'd variable inside an AngularJS controller
snippet $v
	$scope.${1:variable} = ${2:value}
	${3}
# Defines a new $scope'd variable inside an AngularJS controller and assigns a value from a constructor arguments
snippet $va
	$scope.${1:variable} = ${2:variable}
	${3}
# Define a $watch for an expression
# You can change the expression to be watched
snippet $w
	$scope.$watch '${1:watchExpr}', (newValue, oldValue) ->
		${2}
# Define a $on for a $broadcast/$emit on the $scope inside an Angular Controller
# You can change the event name to listen on
snippet $on
	$scope.$on '${1:eventName}', (event, ${2:args}) ->
		${3}
# Define a $broadcast for a $scope inside an Angular Controller / Angular Controller Function
# You can change the event name and optional event arguments
snippet $b
	$scope.$broadcast '${1:eventName}', ${2:eventArgs}
	${3}
# Define an $emit for a $scope inside an Angular Controller / Angular Controller Function
# You can change the event name and optional event arguments
snippet $e
	$scope.$emit '${1:eventName}', ${2:eventArgs}
	${3}
## Directive related snippets
# A compile function
snippet ngdcf
	compile = (tElement, tAttrs, transclude) ->
		(scope, element, attrs) ->
			${1}
# A linking function in a directive
snippet ngdlf
	(scope, element, attrs${1:ctrl}) ->
		${2}
# A directive with a compile function
snippet ngdc
	directive '${1:directiveName}', factory = (${2:injectables}) ->
		directiveDefinitionObject =
			${3:directiveAttrs}
			compile: compile = (tElement, tAttrs, transclude) ->
				(scope, element, attrs) ->
		directiveDefinitionObject
# A directive with a linking function only
snippet ngdl
	.directive('${1:directiveName}', (${2:directiveDeps}) ->
		(scope, element, attrs${3:ctrl}) ->
			${4}
	)
./snippets/coffee/coffee.snippets	[[[1
101
# Closure loop
snippet forindo
	for ${1:name} in ${2:array}
		do ($1) ->
			$0
# Array comprehension
snippet fora
	for ${1:name} in ${2:array}
		$0
# Object comprehension
snippet foro
	for ${1:key}, ${2:value} of ${3:object}
		$0
# Range comprehension (inclusive)
snippet forr
	for ${1:name} in [${2:start}..${3:finish}]
		$0
snippet forrb
	for ${1:name} in [${2:start}..${3:finish}] by ${4:step}
		$0
# Range comprehension (exclusive)
snippet forrex
	for ${1:name} in [${2:start}...${3:finish}]
		$0
snippet forrexb
	for ${1:name} in [${2:start}...${3:finish}] by ${4:step}
		$0
# Function
snippet fun
	(${1:args}) ->
		$0
# Function (bound)
snippet bfun
	(${1:args}) =>
		$0
# Class
snippet cla class ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${0}
snippet cla class .. constructor: ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		constructor: (${2:args}) ->
			${3}

		${0}
snippet cla class .. extends ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		${0}
snippet cla class .. extends .. constructor: ..
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		constructor: (${3:args}) ->
			${4}

		${0}
# If
snippet if
	if $1
		${0:${VISUAL}}
# If __ Else
snippet ife
	if $1
		${2:${VISUAL}}
	else
		${0}
# Else if
snippet eif
	else if $1
		${0:${VISUAL}}
# Ternary If
snippet ifte Ternary
	if $1 then $2 else $0
# Unless
snippet unl Unless
	$1 unless $0
# Switch
snippet swi
	switch ${1:object}
		when ${2:value}
			$0

# Log
snippet log
	console.log ${0}
# Try __ Catch
snippet try
	try
		${1:${VISUAL}}
	catch ${2:error}
		${0}
# Require
snippet req
	${2:$1} = require '${1:sys}'
# Export
snippet exp
	${0:root} = exports ? this

snippet jsonp
	JSON.parse ${0:jstr}
# JSON.stringify
snippet jsons
	JSON.stringify ${0:object}
./snippets/coffee/jquery_coffee.snippets	[[[1
524
snippet add
	${1:obj}.add('${2:selector expression}')
snippet addClass
	${1:obj}.addClass('${2:class name}')
snippet after
	${1:obj}.after('${2:Some text <b>and bold!</b>}')
snippet ajax
	$.ajax
	  url: "${1:mydomain.com/url}"
	  type: "${2:POST}"
	  dataType: "${3:xml/html/script/json}"
	  data: ${4:data}
	  complete: (jqXHR, textStatus) ->
		${5:// callback}
	  success: (data, textStatus, jqXHR) ->
		${6:// success callback}
	  error: (jqXHR, textStatus, errorThrown) ->
		${0:// error callback}
snippet ajaxcomplete
	${1:obj}.ajaxComplete (${1:e}, xhr, settings) ->
		${0:// callback}
snippet ajaxerror
	${1:obj}.ajaxError (${1:e}, xhr, settings, thrownError) ->
		${2:// error callback}
	${0}
snippet ajaxget
	$.get '${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		(data, textStatus, jqXHR) ->
			${0:// success callback}
snippet ajaxpost
	$.post '${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		(data, textStatus, jqXHR) ->
			${0:// success callback}
snippet ajaxprefilter
	$.ajaxPrefilter (${1:options}, ${2:originalOptions}, jqXHR) ->
		${0: // Modify options, control originalOptions, store jqXHR, etc}
snippet ajaxsend
	${1:obj}.ajaxSend (${1:request, settings}) ->
		${2:// error callback}
	${0}
snippet ajaxsetup
	$.ajaxSetup({
		url: "${1:mydomain.com/url}",
		type: "${2:POST}",
		dataType: "${3:xml/html/script/json}",
		data: $.param( $("${4:Element or Expression}") ),
		complete: (jqXHR, textStatus) ->
			${5:// callback}
		,
		success: (data, textStatus, jqXHR) ->
			${6:// success callback}
		,
		error: (jqXHR, textStatus, errorThrown) ->
			${0:// error callback}
	})
snippet ajaxstart
	$.ajaxStart ->
		${1:// handler for when an AJAX call is started and no other AJAX calls are in progress}
	${0}
snippet ajaxstop
	$.ajaxStop ->
		${1:// handler for when all AJAX calls have been completed}
	${0}
snippet ajaxsuccess
	$.ajaxSuccess (${1:e}, xhr, settings) ->
		${2:// handler for when any AJAX call is successfully completed}
	${0}
snippet andself
	${1:obj}.andSelf()
snippet animate
	${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})
snippet append
	${1:obj}.append('${2:Some text <b>and bold!</b>}')
snippet appendTo
	${1:obj}.appendTo('${2:selector expression}')
snippet attr
	${1:obj}.attr('${2:attribute}', '${3:value}')
snippet attrm
	${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})
snippet before
	${1:obj}.before('${2:Some text <b>and bold!</b>}')
snippet bind
	${1:obj}.bind('${2:event name}', (${3:e}) ->
		${0:// event handler}
snippet blur
	${1:obj}.blur (${2:e}) ->
		${0:// event handler}
snippet C
	$.Callbacks()
snippet Cadd
	${1:callbacks}.add(${2:callbacks})
snippet Cdis
	${1:callbacks}.disable()
snippet Cempty
	${1:callbacks}.empty()
snippet Cfire
	${1:callbacks}.fire(${2:args})
snippet Cfired
	${1:callbacks}.fired()
snippet Cfirew
	${1:callbacks}.fireWith(${2:this}, ${3:args})
snippet Chas
	${1:callbacks}.has(${2:callback})
snippet Clock
	${1:callbacks}.lock()
snippet Clocked
	${1:callbacks}.locked()
snippet Crem
	${1:callbacks}.remove(${2:callbacks})
snippet change
	${1:obj}.change (${2:e}) ->
		${0:// event handler}
snippet children
	${1:obj}.children('${2:selector expression}')
snippet clearq
	${1:obj}.clearQueue(${2:'queue name'})
snippet click
	${1:obj}.click (${2:e}) ->
		${0:// event handler}
snippet clone
	${1:obj}.clone()
snippet contains
	$.contains(${1:container}, ${0:contents})
snippet css
	${1:obj}.css('${2:attribute}', '${3:value}')
snippet csshooks
	$.cssHooks['${1:CSS prop}'] = {
		get: (elem, computed, extra) ->
			${2: // handle getting the CSS property}
		set: (elem, value) ->
			${0: // handle setting the CSS value}
	}
snippet cssm
	${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})
snippet D
	$.Deferred()
snippet Dalways
	${1:deferred}.always(${2:callbacks})
snippet Ddone
	${1:deferred}.done(${2:callbacks})
snippet Dfail
	${1:deferred}.fail(${2:callbacks})
snippet Disrej
	${1:deferred}.isRejected()
snippet Disres
	${1:deferred}.isResolved()
snippet Dnotify
	${1:deferred}.notify(${2:args})
snippet Dnotifyw
	${1:deferred}.notifyWith(${2:this}, ${3:args})
snippet Dpipe
	${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})
snippet Dprog
	${1:deferred}.progress(${2:callbacks})
snippet Dprom
	${1:deferred}.promise(${2:target})
snippet Drej
	${1:deferred}.reject(${2:args})
snippet Drejw
	${1:deferred}.rejectWith(${2:this}, ${3:args})
snippet Dres
	${1:deferred}.resolve(${2:args})
snippet Dresw
	${1:deferred}.resolveWith(${2:this}, ${3:args})
snippet Dstate
	${1:deferred}.state()
snippet Dthen
	${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})
snippet Dwhen
	$.when(${1:deferreds})
snippet data
	${1:obj}.data(${2:obj})
snippet dataa
	$.data('${1:selector expression}', '${2:key}'${3:, 'value'})
snippet dblclick
	${1:obj}.dblclick (${2:e}) ->
		${0:// event handler}
snippet delay
	${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})
snippet dele
	${1:obj}.delegate '${2:selector expression}', '${3:event name}', (${4:e}) ->
		${0:// event handler}
snippet deq
	${1:obj}.dequeue(${2:'queue name'})
snippet deqq
	$.dequeue('${1:selector expression}'${2:, 'queue name'})
snippet detach
	${1:obj}.detach('${2:selector expression}')
snippet die
	${1:obj}.die(${2:event}, ${3:handler})
snippet each
	${1:obj}.each (index) ->
		${0:this.innerHTML = this + " is the element, " + index + " is the position"}
snippet el
	$('<${1}/>'${2:, {}})
snippet eltrim
	$.trim('${1:string}')
snippet empty
	${1:obj}.empty()
snippet end
	${1:obj}.end()
snippet eq
	${1:obj}.eq(${2:element index})
snippet error
	${1:obj}.error (${2:e}) ->
		${0:// event handler}
snippet eventsmap
	{
		:f${0}
	}
snippet extend
	$.extend(${1:true, }${2:target}, ${3:obj})
snippet fadein
	${1:obj}.fadeIn('${2:slow/400/fast}')
snippet fadeinc
	${1:obj}.fadeIn 'slow/400/fast', ->
		${0:// callback}
snippet fadeout
	${1:obj}.fadeOut('${2:slow/400/fast}')
snippet fadeoutc
	${1:obj}.fadeOut 'slow/400/fast', ->
		${0:// callback}
snippet fadeto
	${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})
snippet fadetoc
	${1:obj}.fadeTo 'slow/400/fast', ${2:0.5}, ->
		${0:// callback}
snippet filter
	${1:obj}.filter('${2:selector expression}')
snippet filtert
	${1:obj}.filter (${2:index}) ->
		${3}
snippet find
	${1:obj}.find('${2:selector expression}')
snippet focus
	${1:obj}.focus (${2:e}) ->
		${0:// event handler}
snippet focusin
	${1:obj}.focusIn (${2:e}) ->
		${0:// event handler}
snippet focusout
	${1:obj}.focusOut (${2:e}) ->
		${0:// event handler}
snippet get
	${1:obj}.get(${2:element index})
snippet getjson
	$.getJSON '${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		(data, textStatus, jqXHR) ->
			${0:// success callback}
snippet getscript
	$.getScript '${1:mydomain.com/url}', (script, textStatus, jqXHR) ->
		${0:// callback}
snippet grep
	$.grep(${1:array}, (item, index) >
		${2}
	${0:, true})
snippet hasc
	${1:obj}.hasClass('${2:className}')
snippet hasd
	$.hasData('${0:selector expression}')
snippet height
	${1:obj}.height(${2:integer})
snippet hide
	${1:obj}.hide('${2:slow/400/fast}')
snippet hidec
	${1:obj}.hide '${2:slow/400/fast}', ->
		${0:// callback}
snippet hover
	${1:obj}.hover (${2:e}) ->
		${3:// event handler}
	, ($2) ->
		${4:// event handler}
snippet html
	${1:obj}.html('${2:Some text <b>and bold!</b>}')
snippet inarr
	$.inArray(${1:value}, ${0:array})
snippet insa
	${1:obj}.insertAfter('${2:selector expression}')
snippet insb
	${1:obj}.insertBefore('${2:selector expression}')
snippet is
	${1:obj}.is('${2:selector expression}')
snippet isarr
	$.isArray(${1:obj})
snippet isempty
	$.isEmptyObject(${1:obj})
snippet isfunc
	$.isFunction(${1:obj})
snippet isnum
	$.isNumeric(${1:value})
snippet isobj
	$.isPlainObject(${1:obj})
snippet iswin
	$.isWindow(${1:obj})
snippet isxml
	$.isXMLDoc(${1:node})
snippet jj
	$('${1:selector}')
snippet kdown
	${1:obj}.keydown (${2:e}) ->
		${0:// event handler}
snippet kpress
	${1:obj}.keypress (${2:e}) ->
		${0:// event handler}
snippet kup
	${1:obj}.keyup (${2:e}) ->
		${0:// event handler}
snippet last
	${1:obj}.last('${1:selector expression}')
snippet live
	${1:obj}.live '${2:events}', (${3:e}) ->
		${0:// event handler}
snippet load
	${1:obj}.load (${2:e}) ->
		${0:// event handler}
snippet loadf
	${1:obj}.load('${2:mydomain.com/url}',
		${2:{ param1: value1 },}
		(responseText, textStatus, xhr) ->
			${0:// success callback}
	})
snippet makearray
	$.makeArray(${0:obj})
snippet map
	${1:obj}.map (${2:index}, ${3:element}) ->
		${0:// callback}
snippet mapp
	$.map ${1:arrayOrObject}, (${2:value}, ${3:indexOrKey}) ->
		${0:// callback}
snippet merge
	$.merge(${1:target}, ${0:original})
snippet mdown
	${1:obj}.mousedown (${2:e}) ->
		${0:// event handler}
snippet menter
	${1:obj}.mouseenter (${2:e}) ->
		${0:// event handler}
snippet mleave
	${1:obj}.mouseleave (${2:e}) ->
		${0:// event handler}
snippet mmove
	${1:obj}.mousemove (${2:e}) ->
		${0:// event handler}
snippet mout
	${1:obj}.mouseout (${2:e}) ->
		${0:// event handler}
snippet mover
	${1:obj}.mouseover (${2:e}) ->
		${0:// event handler}
snippet mup
	${1:obj}.mouseup (${2:e}) ->
		${0:// event handler}
snippet next
	${1:obj}.next('${2:selector expression}')
snippet nexta
	${1:obj}.nextAll('${2:selector expression}')
snippet nextu
	${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})
snippet not
	${1:obj}.not('${2:selector expression}')
snippet off
	${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})
snippet offset
	${1:obj}.offset()
snippet offsetp
	${1:obj}.offsetParent()
snippet on
	${1:obj}.on '${2:events}', '${3:selector expression}', (${4:e}) ->
		${0:// event handler}
snippet one
	${1:obj}.one '${2:event name}', (${3:e}) ->
		${0:// event handler}
snippet outerh
	${1:obj}.outerHeight()
snippet outerw
	${1:obj}.outerWidth()
snippet param
	$.param(${1:obj})
snippet parent
	${1:obj}.parent('${2:selector expression}')
snippet parents
	${1:obj}.parents('${2:selector expression}')
snippet parentsu
	${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})
snippet parsejson
	$.parseJSON(${1:data})
snippet parsexml
	$.parseXML(${1:data})
snippet pos
	${1:obj}.position()
snippet prepend
	${1:obj}.prepend('${2:Some text <b>and bold!</b>}')
snippet prependto
	${1:obj}.prependTo('${2:selector expression}')
snippet prev
	${1:obj}.prev('${2:selector expression}')
snippet preva
	${1:obj}.prevAll('${2:selector expression}')
snippet prevu
	${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})
snippet promise
	${1:obj}.promise(${2:'fx'}, ${3:target})
snippet prop
	${1:obj}.prop('${2:property name}')
snippet proxy
	$.proxy(${1:function}, ${2:this})
snippet pushstack
	${1:obj}.pushStack(${2:elements})
snippet queue
	${1:obj}.queue(${2:name}${3:, newQueue})
snippet queuee
	$.queue(${1:element}${2:, name}${3:, newQueue})
snippet ready
	$(() ->
		${0}
	)
snippet rem
	${1:obj}.remove()
snippet rema
	${1:obj}.removeAttr('${2:attribute name}')
snippet remc
	${1:obj}.removeClass('${2:class name}')
snippet remd
	${1:obj}.removeData('${2:key name}')
snippet remdd
	$.removeData(${1:element}${2:, 'key name}')
snippet remp
	${1:obj}.removeProp('${2:property name}')
snippet repa
	${1:obj}.replaceAll(${2:target})
snippet repw
	${1:obj}.replaceWith(${2:content})
snippet reset
	${1:obj}.reset (${2:e}) ->
		${0:// event handler}
snippet resize
	${1:obj}.resize (${2:e}) ->
		${0:// event handler}
snippet scroll
	${1:obj}.scroll (${2:e}) ->
		${0:// event handler}
snippet scrolll
	${1:obj}.scrollLeft(${2:value})
snippet scrollt
	${1:obj}.scrollTop(${2:value})
snippet sdown
	${1:obj}.slideDown('${2:slow/400/fast}')
snippet sdownc
	${1:obj}.slideDown('${2:slow/400/fast}', ->
		${0:// callback}
snippet select
	${1:obj}.select (${2:e}) ->
		${0:// event handler}
snippet serialize
	${1:obj}.serialize()
snippet serializea
	${1:obj}.serializeArray()
snippet show
	${1:obj}.show('${2:slow/400/fast}')
snippet showc
	${1:obj}.show '${2:slow/400/fast}', ->
		${0:// callback}
snippet sib
	${1:obj}.siblings('${2:selector expression}')
snippet size
	${1:obj}.size()
snippet slice
	${1:obj}.slice(${2:start}${3:, end})
snippet stoggle
	${1:obj}.slideToggle('${2:slow/400/fast}')
snippet stop
	${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})
snippet submit
	${1:obj}.submit (${2:e}) ->
		${0:// event handler}
snippet sup
	${1:obj}.slideUp('${2:slow/400/fast}')
snippet supc
	${1:obj}.slideUp '${2:slow/400/fast}', ->
		${0:// callback}
snippet text
	${1:obj}.text(${2:'some text'})
snippet this
	$(this)
snippet toarr
	${0:obj}.toArray()
snippet tog
	${1:obj}.toggle  (${2:e}) ->
		${3:// event handler}
	, ($2) ->
		${4:// event handler}
	${0}
snippet togclass
	${1:obj}.toggleClass('${2:class name}')
snippet togsh
	${1:obj}.toggle('${2:slow/400/fast}')
snippet trig
	${1:obj}.trigger('${2:event name}')
snippet trigh
	${1:obj}.triggerHandler('${2:event name}')
snippet $trim
	$.trim(${1:str})
snippet $type
	$.type(${1:obj})
snippet unbind
	${1:obj}.unbind('${2:event name}')
snippet undele
	${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})
snippet uniq
	$.unique(${1:array})
snippet unload
	${1:obj}.unload (${2:e}) ->
		${0:// event handler}
snippet unwrap
	${1:obj}.unwrap()
snippet val
	${1:obj}.val('${2:text}')
snippet width
	${1:obj}.width(${2:integer})
snippet wrap
	${1:obj}.wrap('${2:&ltdiv class="extra-wrapper"&gt&lt/div&gt}')
./snippets/coffee/requirejs_coffee.snippets	[[[1
11
snippet def
	define ["${1:#dependencies1}"], (${2:#dependencies2}) ->
		${0:TARGET}

snippet defn
	define "${1:#name}", ["${2:#dependencies1}"], (${3:#dependencies2}) ->
		${0:TARGET}

snippet reqjs
	require ["${1:#dependencies1}"], (${2:#dependencies2}) ->
		${0:TARGET}
./snippets/cpp.snippets	[[[1
253
extends c

## Main
# main()
snippet mainn
	int main()
	{
		${0}
		return 0;
	}
##
## Preprocessor
# #include <...>
snippet incc
	#include <${1:iostream}>
snippet binc
	#include <boost/${1:shared_ptr}.hpp>
##
## STL Collections
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## STL smart pointers
# std::shared_ptr
snippet msp
	std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
snippet amsp
	auto ${1} = std::make_shared<${2:T}>(${3});
# std::unique_ptr
snippet mup
	std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
snippet amup
	auto ${1} = std::make_unique<${2:T}>(${3});
##
## Access Modifiers
# private
snippet pri
	private
# protected
snippet pro
	protected
# public
snippet pub
	public
# friend
snippet fr
	friend
# mutable
snippet mu
	mutable
##
## Class
# class
snippet cl
	/*! \class $1
	 *  \brief ${3:Brief class description}
	 *
	 *  ${4:Detailed description}
	 */
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1(${2});
		virtual ~$1();

	protected:
		m_${5}; /*!< ${6:Member description} */
	};
# member function implementation
snippet mfun
	${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
		${0}
	}
# member function implementation without parameters
snippet dmfun0
	/*! \brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 *
	 * \return ${6:Return parameter description}
	 */
	${3:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}() {
		${0}
	}
# member function implementation with one parameter
snippet dmfun1
	/*! \brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 *
	 * \param $4 ${8:Parameter description}
	 * \return ${9:Return parameter description}
	 */
	${5:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter}) {
		${0}
	}
# member function implementation with two parameter
snippet dmfun2
	/*! \brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 *
	 * \param $4 ${10:Parameter description}
	 * \param $6 ${11:Parameter description}
	 * \return ${12:Return parameter description}
	 */
	${7:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3:Type} ${4:Parameter},${5:Type} ${6:Parameter}) {
		${0}
	}
# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} {
		${0}
	} /* namespace $1 */
snippet ans
	namespace {
		${0}
	}
##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
##
## Casts
# static
snippet sca
	static_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dca
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rca
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cca
	const_cast<${1:unsigned}>(${2:expr})${3}
## Iteration
# for i
snippet fori
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
		${4}
	}

# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet iter
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}

# auto iterator
snippet itera
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};
# snippets exception
snippet try
	try {

	}catch(${1}) {

	}
# auto function
snippet af auto function
	auto ${1:name}(${2}) -> ${3:void}
	{
		${0}
	};
# Range-v3 transform
snippet transform "ranges::views::transform"
	${1:${2:std::}${3:ranges::}views::}transform($4)
# Range-v3 transform
snippet filter "ranges::views::filter"
	${1:${2:std::}${3:ranges::}views::}filter($4)
# Range-v3 ranges::
snippet r "ranges::"
	ranges::
# Range-v3 ranges::views::
snippet rv "ranges::views::"
	ranges::views::
# Range-v3 ranges::actions::
snippet ra "ranges::actions::"
	ranges::actions::
# STL std::ranges::
snippet sr "std::ranges::"
	std::ranges::
# STL std::views::
snippet sv "std::views::"
	std::views::
./snippets/crystal.snippets	[[[1
82
snippet req require
	require "${1}"
snippet case
	case $1
	when $2
		${0}
	end
snippet when
	when $1
		${0}
snippet def
	def ${1:method_name}
		${0}
	end
snippet pdef
	private def ${1:method_name}
		${0}
	end
snippet if
	if $1
		${0:${VISUAL}}
	end
snippet ife
	if $1
		${2:${VISUAL}}
	else
		${0}
	end
snippet wh
	while $1
		${0:${VISUAL}}
	end
snippet cla class .. end
	class ${1:`substitute(vim_snippets#Filename(), "\(_\|^\)\(.\)", "\u\2", "g")`}
		${0}
	end
snippet mod class .. end
	module ${1:`substitute(vim_snippets#Filename(), "\(_\|^\)\(.\)", "\u\2", "g")`}
		${0}
	end
snippet r
	getter ${0:name}
snippet r!
	getter! ${0:name}
snippet r?
	getter? ${0:name}
snippet w
	setter ${0:name}
snippet w!
	setter! ${0:name}
snippet w?
	setter? ${0:name}
snippet rw
	property ${0:name}
snippet rw!
	property! ${0:name}
snippet rw?
	property? ${0:name}
snippet defs
	def self.${1:class_method_name}
		${0}
	end
snippet defi
	def initialize(${1})
		${0}
	end
snippet do
	do
		${0:${VISUAL}}
	end
snippet dov
	do |${1:v}|
		${2}
	end
snippet desc
	describe ${1:`substitute(substitute(vim_snippets#Filename(), "_spec$", "", ""), "\(_\|^\)\(.\)", "\u\2", "g")`} do
		${0}
	end
snippet it
	it "${1}" do
		${0}
	end
./snippets/cs.snippets	[[[1
531
# cs.snippets
# ===========
#
# Standard C-Sharp snippets for snipmate.
#
# Largely ported over from Visual Studio 2010 snippets plus
# a few snippets from Resharper plus a few widely known snippets.
#
# Most snippets on elements (i.e. classes, properties)
# follow suffix conventions. The order of suffixes to a snippet
# is fixed.
#
# Snippet Suffix Order
# --------------------
# 1. Access Modifiers
# 2. Class Modifiers
#
# Access Modifier Suffix Table
# ----------------------------
# + = public
# & = internal
# | = protected
# - = private
#
# Example: `cls&` expands to `internal class $1`.
# Access modifiers might be doubled to indicate
# different modifiers for get/set on properties.
# Example: `pb+-` expands to `public bool $1 { get; private set; }`
#
# Class Modifier Table
# --------------------
# ^ = static
# % = abstract
#
# Example: `cls|%` expands to `protected abstract class $1`
#
# On method and property snippets, you can directly set
# one of the common types int, string and bool, if desired,
# just by appending the type modifier.
#
# Type Modifier Table
# -------------------
# i = integer
# s = string
# b = bool
#
# Example: `pi+&` expands to `public int $1 { get; internal set; }`
#
# I'll most propably add more stuff in here like
# * List/Array constructio
# * Mostly used generics
# * Linq
# * Funcs, Actions, Predicates
# * Lambda
# * Events
#
# Feedback is welcome!
#
# Main
snippet sim
	${1:public} static int Main(string[] args)
	{
		${0}
		return 0;
	}
snippet simc
	public class Application
	{
		${1:public} static int Main(string[] args)
		{
			${0}
			return 0;
		}
	}
snippet svm
	${1:public} static void Main(string[] args)
	{
		${0}
	}
# if condition
snippet if
	if (${1:true})
	{
		${0:${VISUAL}}
	}
snippet el
	else
	{
		${0:${VISUAL}}
	}
snippet ifs
	if (${1})
		${0:${VISUAL}}
# ternary conditional
snippet t
	${1} ? ${2} : ${0}
snippet ?
	${1} ? ${2} : ${0}
# do while loop
snippet do
	do
	{
		${0:${VISUAL}}
	} while (${1:true});
# while loop
snippet wh
	while (${1:true})
	{
		${0:${VISUAL}}
	}
# for loop
snippet for
	for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++})
	{
		${0}
	}
snippet forr
	for (int ${1:i} = ${2:length}; $1 >= 0; $1--)
	{
		${0}
	}
# foreach
snippet fore
	foreach (${1:var} ${2:entry} in ${3})
	{
		${0}
	}
snippet foreach
	foreach (${1:var} ${2:entry} in ${3})
	{
		${0}
	}
snippet each
	foreach (${1:var} ${2:entry} in ${3})
	{
		${0}
	}
# interfaces
snippet interface
	public interface ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet if+
	public interface ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
# class bodies
snippet class
	public class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls
	${2:public} class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls+
	public class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls+^
	public static class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls&
	internal class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls&^
	internal static class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls|
	protected class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
snippet cls|%
	protected abstract class ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
# constructor
snippet ctor
	public ${1:`vim_snippets#Filename()`}()
	{
		${0}
	}
# properties - auto properties by default.
# default type is int with layout get / set.
snippet prop
	${1:public} ${2:int} ${3} { get; set; }
snippet p
	${1:public} ${2:int} ${3} { get; set; }
snippet p+
	public ${1:int} ${2} { get; set; }
snippet p+&
	public ${1:int} ${2} { get; internal set; }
snippet p+|
	public ${1:int} ${2} { get; protected set; }
snippet p+-
	public ${1:int} ${2} { get; private set; }
snippet p&
	internal ${1:int} ${2} { get; set; }
snippet p&|
	internal ${1:int} ${2} { get; protected set; }
snippet p&-
	internal ${1:int} ${2} { get; private set; }
snippet p|
	protected ${1:int} ${2} { get; set; }
snippet p|-
	protected ${1:int} ${2} { get; private set; }
snippet p-
	private ${1:int} ${2} { get; set; }
# property - bool
snippet pi
	${1:public} int ${2} { get; set; }
snippet pi+
	public int ${1} { get; set; }
snippet pi+&
	public int ${1} { get; internal set; }
snippet pi+|
	public int ${1} { get; protected set; }
snippet pi+-
	public int ${1} { get; private set; }
snippet pi&
	internal int ${1} { get; set; }
snippet pi&|
	internal int ${1} { get; protected set; }
snippet pi&-
	internal int ${1} { get; private set; }
snippet pi|
	protected int ${1} { get; set; }
snippet pi|-
	protected int ${1} { get; private set; }
snippet pi-
	private int ${1} { get; set; }
# property - bool
snippet pb
	${1:public} bool ${2} { get; set; }
snippet pb+
	public bool ${1} { get; set; }
snippet pb+&
	public bool ${1} { get; internal set; }
snippet pb+|
	public bool ${1} { get; protected set; }
snippet pb+-
	public bool ${1} { get; private set; }
snippet pb&
	internal bool ${1} { get; set; }
snippet pb&|
	internal bool ${1} { get; protected set; }
snippet pb&-
	internal bool ${1} { get; private set; }
snippet pb|
	protected bool ${1} { get; set; }
snippet pb|-
	protected bool ${1} { get; private set; }
snippet pb-
	private bool ${1} { get; set; }
# property - string
snippet ps
	${1:public} string ${2} { get; set; }
snippet ps+
	public string ${1} { get; set; }
snippet ps+&
	public string ${1} { get; internal set; }
snippet ps+|
	public string ${1} { get; protected set; }
snippet ps+-
	public string ${1} { get; private set; }
snippet ps&
	internal string ${1} { get; set; }
snippet ps&|
	internal string ${1} { get; protected set; }
snippet ps&-
	internal string ${1} { get; private set; }
snippet ps|
	protected string ${1} { get; set; }
snippet ps|-
	protected string ${1} { get; private set; }
snippet ps-
	private string ${1} { get; set; }
# members - void
snippet m
	${1:public} ${2:void} ${3}(${4})
	{
		${0}
	}
snippet m+
	public ${1:void} ${2}(${3})
	{
		${0}
	}
snippet m&
	internal ${1:void} ${2}(${3})
	{
		${0}
	}
snippet m|
	protected ${1:void} ${2}(${3})
	{
		${0}
	}
snippet m-
	private ${1:void} ${2}(${3})
	{
		${0}
	}
# members - int
snippet mi
	${1:public} int ${2}(${3})
	{
		${0:return 0;}
	}
snippet mi+
	public int ${1}(${2})
	{
		${0:return 0;}
	}
snippet mi&
	internal int ${1}(${2})
	{
		${0:return 0;}
	}
snippet mi|
	protected int ${1}(${2})
	{
		${0:return 0;}
	}
snippet mi-
	private int ${1}(${2})
	{
		${0:return 0;}
	}
# members - bool
snippet mb
	${1:public} bool ${2}(${3})
	{
		${0:return false;}
	}
snippet mb+
	public bool ${1}(${2})
	{
		${0:return false;}
	}
snippet mb&
	internal bool ${1}(${2})
	{
		${0:return false;}
	}
snippet mb|
	protected bool ${1}(${2})
	{
		${0:return false;}
	}
snippet mb-
	private bool ${1}(${2})
	{
		${0:return false;}
	}
# members - string
snippet ms
	${1:public} string ${2}(${3})
	{
		${0:return "";}
	}
snippet ms+
	public string ${1}(${2})
	{
		${0:return "";}
	}
snippet ms&
	internal string ${1}(${2})
	{
		${0:return "";}
	}
snippet ms|
	protected string ${1:}(${2:})
	{
		${0:return "";}
	}
snippet ms-
	private string ${1}(${2})
	{
		${0:return "";}
	}
# structure
snippet struct
	public struct ${1:`vim_snippets#Filename()`}
	{
		${0}
	}
# enumeration
snippet enum
	enum ${1}
	{
		${0}
	}

snippet enum+
	public enum ${1}
	{
		${0}
	}
# preprocessor directives
snippet #if
	#if
		${0}
	#endif
# inline xml documentation
snippet ///
	/// <summary>
	/// ${0}
	/// </summary>
snippet <p
	<param name="${1}">${2:$1}</param>
snippet <ex
	<exception cref="${1:System.Exception}">${2}</exception>
snippet <r
	<returns>${1}</returns>
snippet <s
	<see cref="${1}"/>
snippet <rem
	<remarks>${1}</remarks>
snippet <c
	<code>${1}</code>

snippet cw
	Console.WriteLine(${1});

# equals override
snippet eq
	public override bool Equals(object obj)
	{
		if (obj == null || GetType() != obj.GetType())
		{
			return false;
		}
		${0:throw new NotImplementedException();}
		return base.Equals(obj);
	}
# exception
snippet exc
	public class ${1:MyException} : ${2:Exception}
	{
		public $1() { }
		public $1(string message) : base(message) { }
		public $1(string message, Exception inner) : base(message, inner) { }
		protected $1(
			System.Runtime.Serialization.SerializationInfo info,
			System.Runtime.Serialization.StreamingContext context)
				: base(info, context) { }
	}
# indexer
snippet index
	public ${1:object} this[${2:int} index]
	{
		get { ${0} }
		set { ${0} }
	}
# eventhandler
snippet inv
	EventHandler temp = ${1:MyEvent};
	if (${2:temp} != null)
	{
		$2();
	}
# lock
snippet lock
	lock (${1:this})
	{
		${0}
	}
# namespace
snippet namespace
	namespace ${1:MyNamespace}
	{
		${0}
	}
# property
snippet propr
	public ${1:int} ${2:MyProperty} { get; set; }
snippet propf
	private ${1:int} ${2:myVar};
	public $1 ${3:MyProperty}
	{
		get { return $2; }
		set { $2 = value; }
	}
snippet propg
	public ${1:int} ${2:MyProperty} { get; private set; }
# switch
snippet switch
	switch (${1:switch_on})
	{
		${0}
		default:
	}
# try
snippet try
	try
	{
		${0:${VISUAL}}
	}
	catch (${1:System.Exception})
	{
		throw;
	}
snippet tryf
	try
	{
		${0:${VISUAL}}
	}
	finally
	{
		${1}
	}
# using
snippet usi
	using (${1:resource})
	{
		${0}
	}
./snippets/css.snippets	[[[1
1263
snippet . "selector { }"
	${1} {
		${2:${VISUAL}}
	}${0}
snippet ! "!important"
	 !important
snippet bdi:m+
	-moz-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}
snippet bdi:m
	-moz-border-image: ${1};${0}
snippet bdrz:m
	-moz-border-radius: ${1};${0}
snippet bxsh:m+
	-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}
snippet bxsh:m
	-moz-box-shadow: ${1};${0}
snippet bdi:w+
	-webkit-border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}
snippet bdi:w
	-webkit-border-image: ${1};${0}
snippet bdrz:w
	-webkit-border-radius: ${1};${0}
snippet bxsh:w+
	-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}
snippet bxsh:w
	-webkit-box-shadow: ${1};${0}
snippet @f
	@font-face {
		font-family: ${1};
		src: url(${2});
	}${0}
snippet @i
	@import url(${1});${0}
snippet @m "@media mediatype { }"
	@media ${1:print} {
		${2:${VISUAL}}
	}${0}
snippet ac
	align-content: ${1:stretch};
snippet ac:s
	align-content: start;
snippet ac:e
	align-content: end;
snippet ac:c
	align-content: center;
snippet ac:fs
	align-content: flex-start;
snippet ac:fe
	align-content: flex-end;
snippet ac:sb
	align-content: space-between;
snippet ac:sa
	align-content: space-around;
snippet ac:se
	align-content: space-evenly;
snippet ac:st
	align-content: stretch;
snippet ac:b
	align-content: baseline;
snippet ac:fb
	align-content: first baseline;
snippet ac:lb
	align-content: last baseline;
snippet ai
	align-items: ${1:stretch};
snippet ai:s
	align-items: start;
snippet ai:e
	align-items: end;
snippet ai:c
	align-items: center;
snippet ai:fs
	align-items: flex-start;
snippet ai:fe
	align-items: flex-end;
snippet ai:st
	align-items: stretch;
snippet ai:b
	align-items: baseline;
snippet ai:fb
	align-items: first baseline;
snippet ai:lb
	align-items: last baseline;
snippet as
	align-self: ${1:stretch};
snippet as:s
	align-self: start;
snippet as:e
	align-self: end;
snippet as:c
	align-self: center;
snippet as:st
	align-self: stretch;
snippet as:fs
	align-self: flex-start;
snippet as:fe
	align-self: flex-end;
snippet as:b
	align-self: baseline;
snippet as:fb
	align-self: first baseline;
snippet as:lb
	align-self: last baseline;
snippet bg+
	background: #${1:fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};${0}
snippet bga
	background-attachment: ${1};${0}
snippet bga:f
	background-attachment: fixed;
snippet bga:s
	background-attachment: scroll;
snippet bgbk
	background-break: ${1};${0}
snippet bgbk:bb
	background-break: bounding-box;
snippet bgbk:c
	background-break: continuous;
snippet bgbk:eb
	background-break: each-box;
snippet bgcp
	background-clip: ${1};${0}
snippet bgcp:bb
	background-clip: border-box;
snippet bgcp:cb
	background-clip: content-box;
snippet bgcp:nc
	background-clip: no-clip;
snippet bgcp:pb
	background-clip: padding-box;
snippet bgc
	background-color: #${1:fff};${0}
snippet bgc:t
	background-color: transparent;
snippet bgi
	background-image: url(${1});${0}
snippet bgi:n
	background-image: none;
snippet bgo
	background-origin: ${1};${0}
snippet bgo:bb
	background-origin: border-box;
snippet bgo:cb
	background-origin: content-box;
snippet bgo:pb
	background-origin: padding-box;
snippet bgpx
	background-position-x: ${1};${0}
snippet bgpy
	background-position-y: ${1};${0}
snippet bgp
	background-position: ${1:0} ${2:0};${0}
snippet bgr
	background-repeat: ${1};${0}
snippet bgr:n
	background-repeat: no-repeat;
snippet bgr:x
	background-repeat: repeat-x;
snippet bgr:y
	background-repeat: repeat-y;
snippet bgr:r
	background-repeat: repeat;
snippet bgz
	background-size: ${1};${0}
snippet bgz:a
	background-size: auto;
snippet bgz:ct
	background-size: contain;
snippet bgz:cv
	background-size: cover;
snippet bg
	background: ${1};${0}
snippet bg:ie
	filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}');
snippet bg:n
	background: none;
snippet bd+
	border: ${1:1px} ${2:solid} #${3:000};${0}
snippet bdb+
	border-bottom: ${1:1px} ${2:solid} #${3:000};${0}
snippet bdbc
	border-bottom-color: #${1:000};${0}
snippet bdbi
	border-bottom-image: url(${1});${0}
snippet bdbi:n
	border-bottom-image: none;
snippet bdbli
	border-bottom-left-image: url(${1});${0}
snippet bdbli:c
	border-bottom-left-image: continue;
snippet bdbli:n
	border-bottom-left-image: none;
snippet bdblrz
	border-bottom-left-radius: ${1};${0}
snippet bdbri
	border-bottom-right-image: url(${1});${0}
snippet bdbri:c
	border-bottom-right-image: continue;
snippet bdbri:n
	border-bottom-right-image: none;
snippet bdbrrz
	border-bottom-right-radius: ${1};${0}
snippet bdbs
	border-bottom-style: ${1};${0}
snippet bdbs:n
	border-bottom-style: none;
snippet bdbw
	border-bottom-width: ${1};${0}
snippet bdb
	border-bottom: ${1};${0}
snippet bdb:n
	border-bottom: none;
snippet bdbk
	border-break: ${1};${0}
snippet bdbk:c
	border-break: close;
snippet bdcl
	border-collapse: ${1};${0}
snippet bdcl:c
	border-collapse: collapse;
snippet bdcl:s
	border-collapse: separate;
snippet bdc
	border-color: #${1:000};${0}
snippet bdci
	border-corner-image: url(${1});${0}
snippet bdci:c
	border-corner-image: continue;
snippet bdci:n
	border-corner-image: none;
snippet bdf
	border-fit: ${1};${0}
snippet bdf:c
	border-fit: clip;
snippet bdf:of
	border-fit: overwrite;
snippet bdf:ow
	border-fit: overwrite;
snippet bdf:r
	border-fit: repeat;
snippet bdf:sc
	border-fit: scale;
snippet bdf:sp
	border-fit: space;
snippet bdf:st
	border-fit: stretch;
snippet bdi
	border-image: url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${7:stretch};${0}
snippet bdi:n
	border-image: none;
snippet bdl+
	border-left: ${1:1px} ${2:solid} #${3:000};${0}
snippet bdlc
	border-left-color: #${1:000};${0}
snippet bdli
	border-left-image: url(${1});${0}
snippet bdli:n
	border-left-image: none;
snippet bdls
	border-left-style: ${1};${0}
snippet bdls:n
	border-left-style: none;
snippet bdlw
	border-left-width: ${1};${0}
snippet bdl
	border-left: ${1};${0}
snippet bdl:n
	border-left: none;
snippet bdlt
	border-length: ${1};${0}
snippet bdlt:a
	border-length: auto;
snippet bdrz
	border-radius: ${1};${0}
snippet bdr+
	border-right: ${1:1px} ${2:solid} #${3:000};${0}
snippet bdrc
	border-right-color: #${1:000};${0}
snippet bdri
	border-right-image: url(${1});${0}
snippet bdri:n
	border-right-image: none;
snippet bdrs
	border-right-style: ${1};${0}
snippet bdrs:n
	border-right-style: none;
snippet bdrw
	border-right-width: ${1};${0}
snippet bdr
	border-right: ${1};${0}
snippet bdr:n
	border-right: none;
snippet bdsp
	border-spacing: ${1};${0}
snippet bds
	border-style: ${1};${0}
snippet bds:ds
	border-style: dashed;
snippet bds:dtds
	border-style: dot-dash;
snippet bds:dtdtds
	border-style: dot-dot-dash;
snippet bds:dt
	border-style: dotted;
snippet bds:db
	border-style: double;
snippet bds:g
	border-style: groove;
snippet bds:h
	border-style: hidden;
snippet bds:i
	border-style: inset;
snippet bds:n
	border-style: none;
snippet bds:o
	border-style: outset;
snippet bds:r
	border-style: ridge;
snippet bds:s
	border-style: solid;
snippet bds:w
	border-style: wave;
snippet bdt+
	border-top: ${1:1px} ${2:solid} #${3:000};${0}
snippet bdtc
	border-top-color: #${1:000};${0}
snippet bdti
	border-top-image: url(${1});${0}
snippet bdti:n
	border-top-image: none;
snippet bdtli
	border-top-left-image: url(${1});${0}
snippet bdtli:c
	border-corner-image: continue;
snippet bdtli:n
	border-corner-image: none;
snippet bdtlrz
	border-top-left-radius: ${1};${0}
snippet bdtri
	border-top-right-image: url(${1});${0}
snippet bdtri:c
	border-top-right-image: continue;
snippet bdtri:n
	border-top-right-image: none;
snippet bdtrrz
	border-top-right-radius: ${1};${0}
snippet bdts
	border-top-style: ${1};${0}
snippet bdts:n
	border-top-style: none;
snippet bdtw
	border-top-width: ${1};${0}
snippet bdt
	border-top: ${1};${0}
snippet bdt:n
	border-top: none;
snippet bdw
	border-width: ${1};${0}
snippet bd
	border: ${1};${0}
snippet bd:n
	border: none;
snippet b
	bottom: ${1};${0}
snippet b:a
	bottom: auto;
snippet bxsh+
	box-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}
snippet bxsh
	box-shadow: ${1};${0}
snippet bxsh:n
	box-shadow: none;
snippet bxz
	box-sizing: ${1};${0}
snippet bxz:bb
	box-sizing: border-box;
snippet bxz:cb
	box-sizing: content-box;
snippet cps
	caption-side: ${1};${0}
snippet cps:b
	caption-side: bottom;
snippet cps:t
	caption-side: top;
snippet cl
	clear: ${1};${0}
snippet cl:b
	clear: both;
snippet cl:l
	clear: left;
snippet cl:n
	clear: none;
snippet cl:r
	clear: right;
snippet cp
	clip: ${1};${0}
snippet cp:a
	clip: auto;
snippet cp:r
	clip: rect(${1:0} ${2:0} ${3:0} ${4:0});${0}
snippet c
	color: #${1:000};${0}
snippet ct
	content: ${1};${0}
snippet ct:a
	content: attr(${1});${0}
snippet ct:cq
	content: close-quote;
snippet ct:c
	content: counter(${1});${0}
snippet ct:cs
	content: counters(${1});${0}
snippet ct:ncq
	content: no-close-quote;
snippet ct:noq
	content: no-open-quote;
snippet ct:n
	content: normal;
snippet ct:oq
	content: open-quote;
snippet coi
	counter-increment: ${1};${0}
snippet cor
	counter-reset: ${1};${0}
snippet cur
	cursor: ${1};${0}
snippet cur:a
	cursor: auto;
snippet cur:c
	cursor: crosshair;
snippet cur:d
	cursor: default;
snippet cur:ha
	cursor: hand;
snippet cur:he
	cursor: help;
snippet cur:m
	cursor: move;
snippet cur:p
	cursor: pointer;
snippet cur:t
	cursor: text;
snippet d
	display: ${1};${0}
snippet d:mib
	display: -moz-inline-box;
snippet d:mis
	display: -moz-inline-stack;
snippet d:b
	display: block;
snippet d:cp
	display: compact;
snippet d:g
	display: grid;
snippet d:f
	display: flex;
snippet d:ib
	display: inline-block;
snippet d:itb
	display: inline-table;
snippet d:i
	display: inline;
snippet d:li
	display: list-item;
snippet d:n
	display: none;
snippet d:ri
	display: run-in;
snippet d:tbcp
	display: table-caption;
snippet d:tbc
	display: table-cell;
snippet d:tbclg
	display: table-column-group;
snippet d:tbcl
	display: table-column;
snippet d:tbfg
	display: table-footer-group;
snippet d:tbhg
	display: table-header-group;
snippet d:tbrg
	display: table-row-group;
snippet d:tbr
	display: table-row;
snippet d:tb
	display: table;
snippet ec
	empty-cells: ${1};${0}
snippet ec:h
	empty-cells: hide;
snippet ec:s
	empty-cells: show;
snippet exp
	expression()
snippet fx
	flex: ${1:0} ${2:1} ${0:auto};
snippet fxb
	flex-basis: ${0:auto};
snippet fxb:a
	flex-basis: auto;
snippet fxd
	flex-direction: ${0:row};
snippet fxd:c
	flex-direction: column;
snippet fxd:cr
	flex-direction: column-reverse;
snippet fxd:r
	flex-direction: row;
snippet fxd:rr
	flex-direction: row-reverse;
snippet fxf
	flex-flow: ${1:row} ${0:nowrap};
snippet fxg
	flex-grow: ${0:0};
snippet fxs
	flex-shrink: ${0:1};
snippet fxw
	flex-wrap: ${0:nowrap};
snippet fxw:n
	flex-wrap: nowrap;
snippet fxw:w
	flex-wrap: wrap;
snippet fxw:wr
	flex-wrap: wrap-reverse;
snippet fl
	float: ${1};${0}
snippet fl:l
	float: left;
snippet fl:n
	float: none;
snippet fl:r
	float: right;
snippet f+
	font: ${1:1em} ${2:Arial},${3:sans-serif};${0}
snippet fef
	font-effect: ${1};${0}
snippet fef:eb
	font-effect: emboss;
snippet fef:eg
	font-effect: engrave;
snippet fef:n
	font-effect: none;
snippet fef:o
	font-effect: outline;
snippet femp
	font-emphasize-position: ${1};${0}
snippet femp:a
	font-emphasize-position: after;
snippet femp:b
	font-emphasize-position: before;
snippet fems
	font-emphasize-style: ${1};${0}
snippet fems:ac
	font-emphasize-style: accent;
snippet fems:c
	font-emphasize-style: circle;
snippet fems:ds
	font-emphasize-style: disc;
snippet fems:dt
	font-emphasize-style: dot;
snippet fems:n
	font-emphasize-style: none;
snippet fem
	font-emphasize: ${1};${0}
snippet ff
	font-family: ${1};${0}
snippet ff:c
	font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive;
snippet ff:f
	font-family: ${0:Capitals,Impact},fantasy;
snippet ff:m
	font-family: ${0:Monaco,'Courier New'},monospace;
snippet ff:ss
	font-family: ${0:Helvetica,Arial},sans-serif;
snippet ff:s
	font-family: ${0:Georgia,'Times New Roman'},serif;
snippet fza
	font-size-adjust: ${1};${0}
snippet fza:n
	font-size-adjust: none;
snippet fz
	font-size: ${1};${0}
snippet fsm
	font-smooth: ${1};${0}
snippet fsm:aw
	font-smooth: always;
snippet fsm:a
	font-smooth: auto;
snippet fsm:n
	font-smooth: never;
snippet fst
	font-stretch: ${1};${0}
snippet fst:c
	font-stretch: condensed;
snippet fst:e
	font-stretch: expanded;
snippet fst:ec
	font-stretch: extra-condensed;
snippet fst:ee
	font-stretch: extra-expanded;
snippet fst:n
	font-stretch: normal;
snippet fst:sc
	font-stretch: semi-condensed;
snippet fst:se
	font-stretch: semi-expanded;
snippet fst:uc
	font-stretch: ultra-condensed;
snippet fst:ue
	font-stretch: ultra-expanded;
snippet fs
	font-style: ${1};${0}
snippet fs:i
	font-style: italic;
snippet fs:n
	font-style: normal;
snippet fs:o
	font-style: oblique;
snippet fv
	font-variant: ${1};${0}
snippet fv:n
	font-variant: normal;
snippet fv:sc
	font-variant: small-caps;
snippet fw
	font-weight: ${1};${0}
snippet fw:b
	font-weight: bold;
snippet fw:br
	font-weight: bolder;
snippet fw:lr
	font-weight: lighter;
snippet fw:n
	font-weight: normal;
snippet f
	font: ${1};${0}
snippet g
	grid: ${1};
snippet gaf
	grid-auto-flow: ${1:row};
snippet gaf+
	grid-auto-flow: ${1:row} ${2:dense};
snippet gaf:r
	grid-auto-flow: row;
snippet gaf:c
	grid-auto-flow: column;
snippet gaf:d
	grid-auto-flow: dense;
snippet gaf:rd
	grid-auto-flow: row dense;
snippet gaf:cd
	grid-auto-flow: column dense;
snippet gar
	grid-auto-rows: ${1};
snippet gar:a
	grid-auto-rows: auto
snippet gar:mac
	grid-auto-rows: max-content;
snippet gar:mic
	grid-auto-rows: min-content;
snippet gac
	grid-auto-columns: ${1};
snippet gac:a
	grid-auto-columns: auto
snippet gac:mac
	grid-auto-columns: max-content;
snippet gac:mic
	grid-auto-columns: min-content;
snippet gt
	grid-template: ${1};
snippet gt+
	grid-template: ${1} / ${2};
snippet gtr
	grid-template-rows: ${1};
snippet gtc
	grid-template-columns: ${1};
snippet gta
	grid-template-areas: ${1};
snippet gg
	grid-gap: ${1};
snippet gg+
	grid-gap: ${1} ${2};
snippet gg:0
	grid-gap: 0;
snippet grg
	grid-row-gap: ${1};
snippet grg:0
	grid-row-gap: 0;
snippet gcg
	grid-column-gap: ${1};
snippet gcg:0
	grid-column-gap: 0;
snippet gr
	grid-row: ${1} / ${2};
snippet grs
	grid-row-start: ${1};
snippet gre
	grid-row-end: ${1};
snippet gc
	grid-column: ${1} / ${2};
snippet gcs
	grid-column-start: ${1};
snippet gce
	grid-column-end: ${1};
snippet h
	height: ${1};${0}
snippet h:a
	height: auto;
snippet jc
	justify-content: ${1};
snippet jc:s
	justify-content: start;
snippet jc:e
	justify-content: end;
snippet jc:c
	justify-content: center;
snippet jc:fs
	justify-content: flex-start;
snippet jc:fe
	justify-content: flex-end;
snippet jc:sb
	justify-content: space-between;
snippet jc:sa
	justify-content: space-around;
snippet jc:se
	justify-content: space-evenly;
snippet jc:st
	justify-content: stretch;
snippet jc:l
	justify-content: left;
snippet jc:r
	justify-content: right;
snippet ji
	justify-items: ${1:stretch};
snippet ji:s
	justify-items: start;
snippet ji:e
	justify-items: end;
snippet ji:c
	justify-items: center;
snippet ji:st
	justify-items: stretch;
snippet js
	justify-self: ${1:stretch};
snippet js:s
	justify-self: start;
snippet js:e
	justify-self: end;
snippet js:c
	justify-self: center;
snippet js:st
	justify-self: stretch;
snippet l
	left: ${1};${0}
snippet l:a
	left: auto;
snippet lts
	letter-spacing: ${1};${0}
snippet lh
	line-height: ${1};${0}
snippet lisi
	list-style-image: url(${1});${0}
snippet lisi:n
	list-style-image: none;
snippet lisp
	list-style-position: ${1};${0}
snippet lisp:i
	list-style-position: inside;
snippet lisp:o
	list-style-position: outside;
snippet list
	list-style-type: ${1};${0}
snippet list:c
	list-style-type: circle;
snippet list:dclz
	list-style-type: decimal-leading-zero;
snippet list:dc
	list-style-type: decimal;
snippet list:d
	list-style-type: disc;
snippet list:lr
	list-style-type: lower-roman;
snippet list:n
	list-style-type: none;
snippet list:s
	list-style-type: square;
snippet list:ur
	list-style-type: upper-roman;
snippet lis
	list-style: ${1};${0}
snippet lis:n
	list-style: none;
snippet mb
	margin-bottom: ${1};${0}
snippet mb:a
	margin-bottom: auto;
snippet ml
	margin-left: ${1};${0}
snippet ml:a
	margin-left: auto;
snippet mr
	margin-right: ${1};${0}
snippet mr:a
	margin-right: auto;
snippet mt
	margin-top: ${1};${0}
snippet mt:a
	margin-top: auto;
snippet m
	margin: ${1};${0}
snippet m:4
	margin: ${1:0} ${2:0} ${3:0} ${4:0};${0}
snippet m:3
	margin: ${1:0} ${2:0} ${3:0};${0}
snippet m:2
	margin: ${1:0} ${2:0};${0}
snippet m:0
	margin: 0;
snippet m:a
	margin: auto;
snippet mah
	max-height: ${1};${0}
snippet mah:n
	max-height: none;
snippet maw
	max-width: ${1};${0}
snippet maw:n
	max-width: none;
snippet mih
	min-height: ${1};${0}
snippet miw
	min-width: ${1};${0}
snippet op
	opacity: ${1};${0}
snippet op:ie
	filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${1:100});${0}
snippet op:ms
	-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})';
snippet orp
	orphans: ${1};${0}
snippet or
	order: ${0:0};
snippet o+
	outline: ${1:1px} ${2:solid} #${3:000};${0}
snippet oc
	outline-color: ${1:#000};${0}
snippet oc:i
	outline-color: invert;
snippet oo
	outline-offset: ${1};${0}
snippet os
	outline-style: ${1};${0}
snippet ow
	outline-width: ${1};${0}
snippet o
	outline: ${1};${0}
snippet o:n
	outline: none;
snippet ovs
	overflow-style: ${1};${0}
snippet ovs:a
	overflow-style: auto;
snippet ovs:mq
	overflow-style: marquee;
snippet ovs:mv
	overflow-style: move;
snippet ovs:p
	overflow-style: panner;
snippet ovs:s
	overflow-style: scrollbar;
snippet ovx
	overflow-x: ${1};${0}
snippet ovx:a
	overflow-x: auto;
snippet ovx:h
	overflow-x: hidden;
snippet ovx:s
	overflow-x: scroll;
snippet ovx:v
	overflow-x: visible;
snippet ovy
	overflow-y: ${1};${0}
snippet ovy:a
	overflow-y: auto;
snippet ovy:h
	overflow-y: hidden;
snippet ovy:s
	overflow-y: scroll;
snippet ovy:v
	overflow-y: visible;
snippet ov
	overflow: ${1};${0}
snippet ov:a
	overflow: auto;
snippet ov:h
	overflow: hidden;
snippet ov:s
	overflow: scroll;
snippet ov:v
	overflow: visible;
snippet pb
	padding-bottom: ${1};${0}
snippet pl
	padding-left: ${1};${0}
snippet pr
	padding-right: ${1};${0}
snippet pt
	padding-top: ${1};${0}
snippet p
	padding: ${1};${0}
snippet p:4
	padding: ${1:0} ${2:0} ${3:0} ${4:0};${0}
snippet p:3
	padding: ${1:0} ${2:0} ${3:0};${0}
snippet p:2
	padding: ${1:0} ${2:0};${0}
snippet p:0
	padding: 0;
snippet pc
	place-content: ${1};
snippet pc+
	place-content: ${1} ${2};
snippet pc:s
	place-content: start;
snippet pc:e
	place-content: end;
snippet pc:c
	place-content: center;
snippet pc:fs
	place-content: flex-start;
snippet pc:fe
	place-content: flex-end;
snippet pc:sb
	place-content: space-between;
snippet pc:sa
	place-content: space-around;
snippet pc:se
	place-content: space-evenly;
snippet pc:st
	place-content: stretch;
snippet pgba
	page-break-after: ${1};${0}
snippet pgba:aw
	page-break-after: always;
snippet pgba:a
	page-break-after: auto;
snippet pgba:l
	page-break-after: left;
snippet pgba:r
	page-break-after: right;
snippet pgbb
	page-break-before: ${1};${0}
snippet pgbb:aw
	page-break-before: always;
snippet pgbb:a
	page-break-before: auto;
snippet pgbb:l
	page-break-before: left;
snippet pgbb:r
	page-break-before: right;
snippet pgbi
	page-break-inside: ${1};${0}
snippet pgbi:a
	page-break-inside: auto;
snippet pgbi:av
	page-break-inside: avoid;
snippet pi
	place-items: ${1:stretch};
snippet pi+
	place-items: ${1:stretch} ${2:stretch};
snippet pi:s
	place-items: start;
snippet pi:e
	place-items: end;
snippet pi:c
	place-items: center;
snippet pi:st
	place-items: stretch;
snippet pos
	position: ${1};${0}
snippet pos:a
	position: absolute;
snippet pos:f
	position: fixed;
snippet pos:r
	position: relative;
snippet pos:s
	position: static;
snippet ps
	place-self: ${1:stretch};
snippet ps+
	place-self: ${1:stretch} ${2:stretch};
snippet ps:s
	place-self: start;
snippet ps:e
	place-self: end;
snippet ps:c
	place-self: center;
snippet ps:st
	place-self: stretch;
snippet q
	quotes: ${1};${0}
snippet q:en
	quotes: '\201C' '\201D' '\2018' '\2019';
snippet q:n
	quotes: none;
snippet q:ru
	quotes: '\00AB' '\00BB' '\201E' '\201C';
snippet rz
	resize: ${1};${0}
snippet rz:b
	resize: both;
snippet rz:h
	resize: horizontal;
snippet rz:n
	resize: none;
snippet rz:v
	resize: vertical;
snippet r
	right: ${1};${0}
snippet r:a
	right: auto;
snippet tbl
	table-layout: ${1};${0}
snippet tbl:a
	table-layout: auto;
snippet tbl:f
	table-layout: fixed;
snippet tal
	text-align-last: ${1};${0}
snippet tal:a
	text-align-last: auto;
snippet tal:c
	text-align-last: center;
snippet tal:l
	text-align-last: left;
snippet tal:r
	text-align-last: right;
snippet ta
	text-align: ${1};${0}
snippet ta:c
	text-align: center;
snippet ta:l
	text-align: left;
snippet ta:r
	text-align: right;
snippet td
	text-decoration: ${1};${0}
snippet td:l
	text-decoration: line-through;
snippet td:n
	text-decoration: none;
snippet td:o
	text-decoration: overline;
snippet td:u
	text-decoration: underline;
snippet te
	text-emphasis: ${1};${0}
snippet te:ac
	text-emphasis: accent;
snippet te:a
	text-emphasis: after;
snippet te:b
	text-emphasis: before;
snippet te:c
	text-emphasis: circle;
snippet te:ds
	text-emphasis: disc;
snippet te:dt
	text-emphasis: dot;
snippet te:n
	text-emphasis: none;
snippet th
	text-height: ${1};${0}
snippet th:a
	text-height: auto;
snippet th:f
	text-height: font-size;
snippet th:m
	text-height: max-size;
snippet th:t
	text-height: text-size;
snippet ti
	text-indent: ${1};${0}
snippet ti:-
	text-indent: -9999px;
snippet tj
	text-justify: ${1};${0}
snippet tj:a
	text-justify: auto;
snippet tj:d
	text-justify: distribute;
snippet tj:ic
	text-justify: inter-cluster;
snippet tj:ii
	text-justify: inter-ideograph;
snippet tj:iw
	text-justify: inter-word;
snippet tj:k
	text-justify: kashida;
snippet tj:t
	text-justify: tibetan;
snippet to+
	text-outline: ${1:0} ${2:0} #${3:000};${0}
snippet to
	text-outline: ${1};${0}
snippet to:n
	text-outline: none;
snippet tr
	text-replace: ${1};${0}
snippet tr:n
	text-replace: none;
snippet tsh+
	text-shadow: ${1:0} ${2:0} ${3:0} #${4:000};${0}
snippet tsh
	text-shadow: ${1};${0}
snippet tsh:n
	text-shadow: none;
snippet tt
	text-transform: ${1};${0}
snippet tt:c
	text-transform: capitalize;
snippet tt:l
	text-transform: lowercase;
snippet tt:n
	text-transform: none;
snippet tt:u
	text-transform: uppercase;
snippet tw
	text-wrap: ${1};${0}
snippet tw:no
	text-wrap: none;
snippet tw:n
	text-wrap: normal;
snippet tw:s
	text-wrap: suppress;
snippet tw:u
	text-wrap: unrestricted;
snippet t
	top: ${1};${0}
snippet t:a
	top: auto;
snippet va
	vertical-align: ${1};${0}
snippet va:bl
	vertical-align: baseline;
snippet va:b
	vertical-align: bottom;
snippet va:m
	vertical-align: middle;
snippet va:sub
	vertical-align: sub;
snippet va:sup
	vertical-align: super;
snippet va:tb
	vertical-align: text-bottom;
snippet va:tt
	vertical-align: text-top;
snippet va:t
	vertical-align: top;
snippet v
	visibility: ${1};${0}
snippet v:c
	visibility: collapse;
snippet v:h
	visibility: hidden;
snippet v:v
	visibility: visible;
snippet whsc
	white-space-collapse: ${1};${0}
snippet whsc:ba
	white-space-collapse: break-all;
snippet whsc:bs
	white-space-collapse: break-strict;
snippet whsc:k
	white-space-collapse: keep-all;
snippet whsc:l
	white-space-collapse: loose;
snippet whsc:n
	white-space-collapse: normal;
snippet whs
	white-space: ${1};${0}
snippet whs:n
	white-space: normal;
snippet whs:nw
	white-space: nowrap;
snippet whs:pl
	white-space: pre-line;
snippet whs:pw
	white-space: pre-wrap;
snippet whs:p
	white-space: pre;
snippet wid
	widows: ${1};${0}
snippet w
	width: ${1};${0}
snippet w:a
	width: auto;
snippet wob
	word-break: ${1};${0}
snippet wob:ba
	word-break: break-all;
snippet wob:bs
	word-break: break-strict;
snippet wob:k
	word-break: keep-all;
snippet wob:l
	word-break: loose;
snippet wob:n
	word-break: normal;
snippet wos
	word-spacing: ${1};${0}
snippet wow
	word-wrap: ${1};${0}
snippet wow:no
	word-wrap: none;
snippet wow:n
	word-wrap: normal;
snippet wow:s
	word-wrap: suppress;
snippet wow:u
	word-wrap: unrestricted;
snippet z
	z-index: ${1};${0}
snippet z:a
	z-index: auto;
snippet zoo
	zoom: 1;
snippet :h
	:hover
snippet :fc
	:first-child
snippet :lc
	:last-child
snippet :nc
	:nth-child(${0})
snippet :nlc
	:nth-last-child(${0})
snippet :oc
	:only-child
snippet :a
	:after
snippet :b
	:before
snippet ::a
	::after
snippet ::b
	::before
snippet var
	var(${0:${VISUAL}});
snippet vard
	var(${0}, ${1:${VISUAL});
snippet host 
	:host {
		${1:${VISUAL}}
	}
snippet host(
	:host(${1}) {
		${2:${VISUAL}}
	}
snippet part {
	::part(${1})
		${2:${VISUAL}}
	}
./snippets/cuda.snippets	[[[1
59
extends cpp

snippet kern "Kernel definition"
	__global__ void ${1:kernel}(${2:void}) {
		${0:// TODO: Implement}
	}

snippet dev "Device function definition"
	__device__ ${1:int} ${2:foo}(${3:void}) {
		${0:// TODO: Implement}
		return 0;
	}
	
snippet call "Kernel call"
	${1:kernel}<<<${2:args}>>>(${3});${0}

snippet sync "Synchonize threads"
	__syncthreads();

snippet tid "Thread Index"
	threadIdx.${0}

snippet bid "Block Index"
	blockIdx.${0}

snippet bdim "Block Dimension"
	blockDim.${0}

snippet ii "Get current index (1D)"
	int ${1:index} = threadIdx.${2:x} + blockIdx.$2 * blockDim.$2;

snippet ix "Get current X index (1D)"
	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;

snippet iy "Get current Y index (1D)"
	int ${1:y} = threadIdx.y + blockIdx.y * blockDim.y;

snippet iz "Get current Z index (1D)"
	int ${1:z} = threadIdx.z + blockIdx.z * blockDim.z;

snippet ixy "Get current X,Y index (2D)"
	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;

snippet ixz "Get current X,Z index (2D)"
	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;

snippet iyz "Get current Y,Z index (2D)"
	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;
	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;

snippet ixyz "Get current X,Y,Z index (3D)"
	int ${1:x} = threadIdx.x + blockIdx.x * blockDim.x;
	int ${2:y} = threadIdx.y + blockIdx.y * blockDim.y;
	int ${3:z} = threadIdx.z + blockIdx.z * blockDim.z;

snippet share "Shared memory declaration"
	__shared__ ${1:int} ${2:memo}[${3:SIZE}];${0}
./snippets/d.snippets	[[[1
338
### Import
snippet imp
	import 
snippet pimp
	public import
### My favorite modules
snippet io
	std.stdio
snippet traits
	std.traits
snippet conv
	std.conv
snippet arr
	std.array
snippet algo
	std.algorithm
snippet theusual
	import std.stdio, std.string, std.array;
	import std.traits, std.conv, std.algorithm;
	import std.math, std.regex;
### Control Structures
snippet for
	for(int ${1:i} = 0; $1 < ${2:count}; $1++) {
		${0}
	}
snippet fe
	foreach(${1:elem}; ${2:range}) {
		${0}
	}
snippet fei
	foreach(${1:i}, ${2:elem}; ${3:range}) {
		${0}	
	} 
snippet fer
	foreach_reverse(${1:elem}; ${2:range}) {
		${0}	
	} 
snippet feri
	foreach_reverse(${1:i}, ${2:elem}; ${3:range}) {
		${0}  
	}
snippet sce
	scope(exit) ${1:f.close();}
snippet scs
	scope(success) ${1}
snippet scf
	scope(failure) ${1}
snippet el
	else {
		${1}	
	}
snippet eif
	else if(${1}) {
		${0}
	}
snippet if
	if(${1}) {
		${0}
	}
snippet ife
	if(${1}) {
		${2}	
	} else {
		${3}	
	}
snippet ifee
	if(${1}) {
		${2}	
	} else if(${3}) {
		${4}
	} else {
		${5}
	}
snippet sw
	switch(${1}) {
		${0}
	}
snippet cs
	case ${1:0}:
		${2}
		break;
snippet def
	default:
		${0}
snippet fsw
	final switch(${1}) {
		${0}
	}
snippet try
	try {
		${1:${VISUAL}}
	} catch(${2:Exception} ${3:e}) {
		${4}
	}
snippet tcf
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
		${3}
	} finally {
		${4}
	}
snippet wh
	while(${1:cond}) {
		${0:${VISUAL}}
	}
snippet dowh
	do {
		${1}
	} while(${2});
snippet sif
	static if(${1:cond}) {
		${2}
	}
snippet sife
	static if(${1}) {
		${2}
	} else {
		${3}
	}
snippet sifee
	static if(${1}) {
		${2}
	} else static if(${3}) {
		${4}
	} else {
		${5}
	}
snippet seif
	else static if(${1}) {
		${2}
	} 
snippet ?
	(${1: a > b}) ? ${2:a} : ${3:b}; 
snippet with
	with(${1:exp}) {
		${2}
	} ${0}	
### Functions
snippet fun
	${1:auto} ${2:func}(${3:params}) {
		${0}
	}
snippet contr
	in {
		${1}
	} out {
		${2}
	} body {
		${0}
	}
snippet l
	(${1:x}) => ${2:x}${0:;}
snippet funl
	function (${1:int x}) => ${2}${3:;}
snippet del
	delegate (${1:int x}) => ${2}${3:;} 
### Templates
snippet temp 
	template ${1:`vim_snippets#Filename("$2", "untitled")`}(${2:T}) {
		${0}
	}
snippet tempif
	template ${1:`vim_snippets#Filename("$2", "untitled")`}(${2:T}) if(${3:isSomeString!}$2) {
		${0}	
	}
snippet opApply
	int opApply(Dg)(Dg dg) if(ParameterTypeTuble!Dg.length == 2) {
		${0}
	}
snippet psn
	pure @safe nothrow
snippet safe
	@safe
snippet trusted
	@trusted
snippet	system
	@system
### OOPs
snippet cl
	class${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
snippet str
	struct${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
snippet uni
	union${1:(T)} ${2:`vim_snippets#Filename("$3", "untitled")`} {
		${0}	
	}
snippet inter
	interface I${1:`vim_snippets#Filename("$2", "untitled")`} {
		${0}
	}
snippet enum
	enum ${1} {
		${0}
	}
snippet pu
	public
snippet pr
	private
snippet po
	protected
snippet ctor
	this(${1}) {
		${0}
	} 
snippet dtor
	~this(${1}) {
		${0}
	}
### Type Witchery
snippet al
	alias ${1:b} = ${2:a};
	${0}
snippet alth
	alias ${1:value} this;
	${0}
### The Commonplace
snippet main
	void main() {
		${0}
	}
snippet maina
	void main(string[] args) {
		${0}
	}
snippet mod
	module ${1:main};${0}
snippet var
	${1:auto} ${2:var} = ${0:1};
snippet new
	${1:auto} ${2:var} = new ${3:Object}(${4});
	${0}
snippet file
	auto ${1:f} = File(${2:"useful_info.xml"}, ${3:"rw"});
	${0}
snippet map
	map!(${1:f})(${2:xs});
	${0}
snippet filter
	filter!(${1:p})(${2:xs});
	${0}
snippet reduce
	reduce!(${1:f})(${2:xs});
	${0}
snippet find
	find!(${1:p})($2:xs);
	${0}
snippet aa
	${1:int}[${2:string}] ${3:dict} = ${0};
### Misc
snippet #!
	#!/usr/bin/env rdmd
snippet bang
	#!/usr/bin/env rdmd
snippet rdmd
	#!/usr/bin/env rdmd
snippet isstr
	isSomeString!${1:S}
snippet isnum
	isNumeric!${1:N}
snippet tos
	to!string(${1:x});
	${0}
snippet toi
	to!int(${1:str});
	${0}
snippet tod
	to!double(${1:str});
	${0}
snippet un
	unittest {
		${0}
	}
snippet ver
	version(${1:Posix}) {
		${0}
	}
snippet de
	debug {
		${0}
	}
snippet sst
	shared static this(${1}) {
		${0}
	}
snippet td
	// Typedef is deprecated. Use alias instead.
	typedef
snippet ino
	inout
snippet imm
	immutable
snippet fin
	final
snippet con
	const
snippet psi
	private static immutable ${1:int} ${2:Constant} = ${3:1};
	${0}
snippet prag
	pragma(${1})
snippet pms
	pragma(msg, ${1:Warning});
snippet asm
	asm {
		${1}
	}
snippet mixin
	mixin(${1:`writeln("Hello, World!");`});
snippet over
	override
snippet ret
	return ${1};
snippet FILE
	__FILE__
snippet MOD
	__MODULE__
snippet LINE
	__LINE__
snippet FUN
	__FUNCTION__
snippet PF
	__PRETTY_FUNCTION__
snippet cast
	cast(${1:T})(${2:val});
snippet /*
	/*
	 * ${1}
	*/
### Fun stuff
snippet idk
	// I don't know how this works. Don't touch it.
snippet idfk
	// Don't FUCKING touch this.
./snippets/dart-flutter.snippets	[[[1
93
# Snippets for dart in flutter project, to use add the following to your .vimrc
# `autocmd BufRead,BufNewFile,BufEnter *.dart UltiSnipsAddFiletypes dart-flutter`
# Flutter stateless widget
snippet stless
	class $1 extends StatelessWidget {
		const $1({super.key});

		@override
		Widget build(BuildContext context) {
			return Container(
				$2
			);
		}
	}

# Flutter stateful widget
snippet stful
	class $1 extends StatefulWidget {
		const $1({super.key});

		@override
		State<$1> createState() => _$1State();
	}

	class _$1State extends State<$1> {
		@override
		Widget build(BuildContext context) {
			return Container(
				$2
			);
		}
	}

# Flutter widget with AnimationController
snippet stanim
	class $1 extends StatefulWidget {
		const $1({super.key});

		@override
		State<$1> createState() => _$1State();
	}

	class _$1State extends State<$1>
			with SingleTickerProviderStateMixin {
		AnimationController _controller;

		@override
		void initState() {
			super.initState();
			_controller = AnimationController(vsync: this);
		}

		@override
		void dispose() {
			super.dispose();
			_controller.dispose();
		}

		@override
		Widget build(BuildContext context) {
			return Container(
				$2
			);
		}
	}

# Flutter scaffold application
snippet fsa
	void main() {
		runApp(
			MaterialApp(
				title: 'Flutter Demo',
				theme: ThemeData(
					primarySwatch: Colors.blue,
				),
				debugShowCheckedModeBanner: false,
				home: const HomePage(),
			),
		);
	}

	class HomePage extends StatelessWidget {
		const HomePage({Key? key}) : super(key: key);

		@override
		Widget build(BuildContext context) {
			return Scaffold(
				appBar: AppBar(
					title: const Text('Home Page'),
				),
			);
		}
	}
./snippets/dart.snippets	[[[1
83
snippet lib
	library ${1};
	${0}
snippet im
	import 'package:${1}/${2}.dart';
	${0}
snippet rgx
	new RegExp(r'${1}')
snippet var
	var ${1} = ${2};
snippet main
	main() {
	  ${0}
	}
snippet st
	static ${0}
snippet fi
	final ${0}
snippet re
	return ${0}
snippet br
	break;
snippet th
	throw ${0}
snippet cl
	class ${1:`vim_snippets#Filename("", "untitled")`} ${0}
snippet in
	interface ${1:`vim_snippets#Filename("", "untitled")`} ${0}
snippet imp
	implements ${0}
snippet ext
	extends ${0}
snippet if
	if (${1:true}) {
	  ${0}
	}
snippet ife
	if (${1:true}) {
	  ${2}
	} else {
	  ${0}
	}
snippet el
	else
snippet sw
	switch (${1}) {
	  ${0}
	}
snippet cs
	case ${1}:
	  ${0}
snippet de
	default:
	  ${0}
snippet for
	for (var ${2:i} = 0, len = ${1:things}.length; $2 < len; ${3:++}$2) {
	  ${0:$1[$2]}
	}
snippet fore
	for (final ${2:item} in ${1:itemList}) {
	  ${0}
	}
snippet wh
	while ($1) {
	  ${0}
	}
snippet dowh
	do {
	  ${0}
	} while ($0);
snippet as
	assert($0);
snippet try
	try {
	  ${0:${VISUAL}}
	} catch (${1:Exception e}) {
	}
snippet tryf
	try {
	  ${0:${VISUAL}}
	} catch (${1:Exception e}) {
	} finally {
	}
./snippets/diff.snippets	[[[1
11
# DEP-3 (http://dep.debian.net/deps/dep3/) style patch header
snippet header DEP-3 style header
	Description: ${1}
	Origin: ${2:vendor|upstream|other}, ${3:url of the original patch}
	Bug: ${4:url in upstream bugtracker}
	Forwarded: ${5:no|not-needed|url}
	Author: ${6:`g:snips_author`}
	Reviewed-by: ${7:name and email}
	Last-Update: ${8:`strftime("%Y-%m-%d")`}
	Applied-Upstream: ${0:upstream version|url|commit}

./snippets/django.snippets	[[[1
112
# Model Fields

# Note: Optional arguments are using defaults that match what Django will use
# as a default, e.g. with max_length fields.  Doing this as a form of self
# documentation and to make it easy to know whether you should override the
# default or not.

# Note: Optional arguments that are booleans will use the opposite since you
# can either not specify them, or override them, e.g. auto_now_add=False.

snippet auto
	${1:FIELDNAME} = models.AutoField(${0})
snippet bigint
	${1:FIELDNAME} = models.BigIntegerField(${0})
snippet binary
	${1:FIELDNAME} = models.BinaryField(${0})
snippet bool
	${1:FIELDNAME} = models.BooleanField(${0:default=True})
snippet char
	${1:FIELDNAME} = models.CharField(max_length=${2}${0:, blank=True})
snippet comma
	${1:FIELDNAME} = models.CommaSeparatedIntegerField(max_length=${2}${0:, blank=True})
snippet date
	${1:FIELDNAME} = models.DateField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})
snippet datetime
	${1:FIELDNAME} = models.DateTimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})
snippet decimal
	${1:FIELDNAME} = models.DecimalField(max_digits=${2}, decimal_places=${0})
snippet email
	${1:FIELDNAME} = models.EmailField(max_length=${2:75}${0:, blank=True})
snippet file
	${1:FIELDNAME} = models.FileField(upload_to=${2:path/for/upload}${0:, max_length=100})
snippet filepath
	${1:FIELDNAME} = models.FilePathField(path=${2:"/abs/path/to/dir"}${3:, max_length=100}${4:, match="*.ext"}${5:, recursive=True}${0:, blank=True, })
snippet float
	${1:FIELDNAME} = models.FloatField(${0})
snippet image
	${1:FIELDNAME} = models.ImageField(upload_to=${2:path/for/upload}${3:, height_field=height, width_field=width}${0:, max_length=100})
snippet int
	${1:FIELDNAME} = models.IntegerField(${0})
snippet ip
	${1:FIELDNAME} = models.IPAddressField(${0})
snippet nullbool
	${1:FIELDNAME} = models.NullBooleanField(${0})
snippet posint
	${1:FIELDNAME} = models.PositiveIntegerField(${0})
snippet possmallint
	${1:FIELDNAME} = models.PositiveSmallIntegerField(${0})
snippet slug
	${1:FIELDNAME} = models.SlugField(max_length=${2:50}${0:, blank=True})
snippet smallint
	${1:FIELDNAME} = models.SmallIntegerField(${0})
snippet text
	${1:FIELDNAME} = models.TextField(${0:blank=True})
snippet time
	${1:FIELDNAME} = models.TimeField(${2:auto_now_add=True, auto_now=True}${0:, blank=True, null=True})
snippet url
	${1:FIELDNAME} = models.URLField(${2:verify_exists=False}${3:, max_length=200}${0:, blank=True})
snippet xml
	${1:FIELDNAME} = models.XMLField(schema_path=${2:None}${0:, blank=True})
# Relational Fields
snippet fk
	${1:FIELDNAME} = models.ForeignKey(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${0:, to_field=''})
snippet m2m
	${1:FIELDNAME} = models.ManyToManyField(${2:OtherModel}${3:, related_name=''}${4:, limit_choices_to=}${5:, symmetrical=False}${6:, through=''}${0:, db_table=''})
snippet o2o
	${1:FIELDNAME} = models.OneToOneField(${2:OtherModel}${3:, parent_link=True}${4:, related_name=''}${5:, limit_choices_to=}${0:, to_field=''})

# Code Skeletons

snippet form
	class ${1:FormName}(forms.Form):
		"""${2:docstring}"""
		${0}

snippet model
	class ${1:ModelName}(models.Model):
		"""${2:docstring}"""
		${3}

		class Meta:
			${4}

		def __unicode__(self):
			${5}

		def save(self, *args, **kwargs):
			${6}

		@models.permalink
		def get_absolute_url(self):
			return ('${7:view_or_url_name}' ${0})

snippet modeladmin
	class ${1:ModelName}Admin(admin.ModelAdmin):
		${0}

	admin.site.register($1, $1Admin)

snippet tabularinline
	class ${0:ModelName}Inline(admin.TabularInline):
		model = $1

snippet stackedinline
	class ${0:ModelName}Inline(admin.StackedInline):
		model = $1

snippet r2r
	return render_to_response('${1:template.html}', {
			${2}
		}${0:, context_instance=RequestContext(request)}
	)
./snippets/dosini.snippets	[[[1
12
snippet ec
	; http://editorconfig.org

	root = true

	[*]
	indent_style = ${1:space_or_tab}
	indent_size = ${2:indent_size}
	end_of_line = lf
	charset = utf-8
	trim_trailing_whitespace = true
	insert_final_newline = true
./snippets/eelixir.snippets	[[[1
71
extends html

snippet % <% %>
	<% ${0} %>
snippet = <%= %>
	<%= ${0} %>
snippet # <%# %>
	<%# ${0} %>
snippet end
	<% end %>
snippet for
	<%= for ${1:item} <- ${2:items} ${3:@conn} do %>
		${0}
	<% end %>
snippet if
	<%= if ${1} do %>
		${0:${VISUAL}}
	<% end %>
snippet ife
	<%= if ${1} do %>
		${2:${VISUAL}}
	<% else %>
		${0}
	<% end %>
snippet cond
	<%= cond do %>
		<% ${1} -> %>
			${2:${VISUAL}}

		<% true -> %>
			${0}
	<% end %>
snippet unless
	<%= unless ${1} do %>
		${0:${VISUAL}}
	<% end %>
snippet ft form_tag
	<%= form_tag(${1:"/users"}, method: ${2::post}) %>
		${0}
	</form>

snippet sl select
	<%= select ${1:f}, :${2:field}, ${3:[{"key", "value"}]}, prompt: ${4:"Prompt"} %>

snippet sb submit
	<%= submit ${1:"Submit"} %>

snippet rb radio_button
	<%= radio_button ${1:f}, :${2:field},  ${3:"value"} %>


snippet et error_tag
	<%= error_tag ${1:f}, :${2:field} %>
snippet ti text_input
	<%= text_input ${1:f}, :${2:field} %>
snippet la label
	<%= label ${1:f}, :${2:field}, "${3:Label}" %>
snippet pi password_input
	<%= password_input ${1:f}, :${2:password} %>
snippet render
	<%= render "${1:index}.html", ${2:var: @var} %>
snippet lin link
	<%= link "${1:Submit}", to: ${2:"/users"}, method: ${3::delete} %>
snippet ff form_for
	<%= form_for @changeset, ${1:"/users"}, fn f -> %>
			${0}

		<%= submit "Submit" %>
	<% end %>
snippet pry
	<% require IEx; IEx.pry %>
./snippets/elixir.snippets	[[[1
297
snippet do
	do
		${0:${VISUAL}}
	end
snippet put IO.puts
	IO.puts("${0}")
snippet ins IO.inspect
	IO.inspect(${0})
snippet insl IO.inspect with label
	IO.inspect(${0}label: "${1:label}")
snippet if if .. do .. end
	if ${1} do
		${0:${VISUAL}}
	end
snippet if: if .. do: ..
	if $1, do: ${0}
snippet ife if .. do .. else .. end
	if $1 do
		${2:${VISUAL}}
	else
		${0}
	end
snippet ife: if .. do: .. else:
	if $1, do: ${2}, else: ${0}
snippet unless unless .. do .. end
	unless ${1} do
		${0:${VISUAL}}
	end
snippet unless: unless .. do: ..
	unless $1, do: ${0}
snippet unlesse unless .. do .. else .. end
	unless $1 do
		${2:${VISUAL}}
	else
		${0}
	end
snippet unlesse: unless .. do: .. else:
	unless $1, do: ${2}, else: ${0}
snippet cond
	cond do
		${1} ->
		${0:${VISUAL}}
	end
snippet case
	case ${1} do
		${2} ->
			${0}
	end
snippet for
	for ${1:item} <- ${2:items} do
		${0}
	end
snippet for:
	for ${1:item} <- ${2:items}, do: ${0}
snippet fori
	for ${1:item} <- ${2:items}, into: ${3} do
		${0}
	end
snippet wi
	with ${1:item} <- ${2:items} do
		${0}
	end
snippet wie
	with(
		${1:item} <- ${2:items}
	) do
		${3}
	else
		${4} ->
			${0}
	end
snippet sp
	@spec ${1:name}(${2:args}) :: ${3:returns}
snippet op
	@opaque ${1:type_name} :: ${2:type}
snippet ty
	@type ${1:type_name} :: ${2:type}
snippet typ
	@typep ${1:type_name} :: ${2:type}
snippet cb
	@callback ${1:name}(${2:args}) :: ${3:returns}
snippet df
	def ${1:name}, do: ${2}
snippet dfw
	def ${1:name}(${2:args}) when ${3:guard}, do:
snippet def
	def ${1:name} do
		${0}
	end
snippet defd
	@doc """
	${1:doc string}
	"""
	def ${2:name} do
		${0}
	end
snippet defs
	@spec ${1:name}(${2:arg types}) :: ${3:no_return}
	def $1(${4:args}) do
		${0}
	end
snippet defsd
	@doc """
	${1:doc string}
	"""
	@spec ${2:name}(${3:arg types}) :: ${4:no_return}
	def $2(${5:args}) do
		${0}
	end
snippet defw
	def ${1:name}(${2:args}) when ${3:guard} do
		${0}
	end
snippet defim
	defimpl ${1:protocol_name}, for: ${2:data_type} do
		${0}
	end
snippet defma
	defmacro ${1:name} do
		${0}
	end
snippet defmo
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet %M
	%__MODULE__{
		${1:key_name}: ${2:value}
	}
snippet enfk
	@enforce_keys [:${1:key_name}]
snippet dfp
	defp ${1:name}, do: ${2}
snippet dfpw
	defp ${1:name}(${2:args}) when ${3:guard}, do: ${4}
snippet defp
	defp ${1:name} do
		${0}
	end
snippet defpw
	defp ${1:name}(${2:args}) when ${3:guard} do
		${0}
	end
snippet defpr
	defprotocol ${1:name}, [${0:function}]
snippet defr
	defrecord ${1:record_name}, ${0:fields}
snippet doc
	@doc """
	${0}
	"""
snippet docs
	@doc ~S"""
	${0}
	"""
snippet docf
	@doc false
snippet im
	@impl true
snippet fn
	fn ${1:args} -> ${0} end
snippet mdoc
	@moduledoc """
	${0}
	"""
snippet mdocs
	@moduledoc ~S"""
	${0}
	"""
snippet mdocf
	@moduledoc false
snippet rec
	receive do
		${1} ->
			${0}
	end
snippet req
	require ${0:Logger}
snippet imp
	import ${0:module_name}
snippet ali
	alias ${0:module_name}
snippet test
	test "${1:test name}" do
		${0}
	end
snippet testc
	test "${1:test_name}", ctx do
		${0}
	end
snippet testa
	test "${1:test_name}", %{${2:arg: arg}} do
		${0}
	end
snippet des
	describe "${1:test group subject}" do
		${0}
	end
snippet destag
	@describetag :${1:describe tag}
snippet mtag
	@moduletag :${1:module tag}
snippet dt
	doctest ${1:filename}
snippet tp
	@tag :pending
snippet exunit
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		use ExUnit.Case, async: true

		${0}
	end
snippet setup
	setup do
		${1}
	end
snippet setupa
	setup_all do
		${1}
	end
snippet try try .. rescue .. end
	try do
		${1:${VISUAL}}
	rescue
		${2} -> ${0}
	end
snippet pry
	require IEx; IEx.pry
	${0}
snippet ppry
	|> (fn x -> require IEx; IEx.pry; x end).()${0}
snippet qu
	quote do
		${1}
	end
snippet beh
	@behaviour ${1:Mix.Task}
	${0}
snippet p
	|> ${0}
snippet >e pipe to each
	|> Enum.each(fn ${1} -> ${0} end)
snippet >m pipe to map
	|> Enum.map(fn ${1} -> ${0} end)
snippet >f pipe to filter
	|> Enum.filter(fn ${1} -> ${0} end)
snippet >r pipe to reduce
	|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)
snippet >i pipe to inspect
	|> IO.inspect()
snippet >il pipe to inspect with label
	|> IO.inspect(label: "${1:label}")
snippet cs
	@doc false
	def child_spec(${1:_opts}) do
		%{
			id: __MODULE__,
			start: {__MODULE__, :start_link, ${2:[]}},
			restart: ${3::permanent},
			shutdown: ${4:5000},
			type: ${5::worker}
		}
	end
snippet genserver basic genserver structure
	use GenServer

	@doc false
	def start_link(init_args) do
		GenServer.start_link(__MODULE__, init_args, name: __MODULE__)
	end

	@impl true
	def init(state) do
		{:ok, state}
	end
snippet super basic supervisor structure
	use Supervisor

	@doc false
	def start_link(init_args) do
		Supervisor.start_link(__MODULE__, init_args, name: __MODULE__)
	end

	@impl true
	def init(_init_args) do
		children = [${1}]
		Supervisor.init(children, strategy: :one_for_one)
	end
snippet impl
	@impl true
	def ${1:name} do
		${0}
	end
snippet wl word list
	~w(${0})
snippet al atom list
	~w(${0})a
./snippets/elm.snippets	[[[1
158
snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` exposing (${1})
	${0}
snippet imp
	import ${0:Http}
snippet impe
	import ${1:Html} exposing (${0:..})
snippet impae
	import ${1:Json.Encode} as ${2:Encode} exposing (${0:Value})
snippet fn
	${1:fn} : ${2:a} -> ${3:a}
	$1 ${4} =
		${0}
snippet fn1
	${1:fn} : ${2:a} -> ${3:a}
	$1 ${4} =
		${0}
snippet fn2
	${1:fn} : ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5} =
		${0}
snippet fn3
	${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6} =
		${0}
snippet fn0
	${1:fn} : ${2:a}
	$1 =
		${0}
snippet case
	case ${1} of
		${2} ->
			${0}
snippet -
	${1} ->
		${0}
snippet let
	let
		${1} =
			${2}
	in
		${0}
snippet if
	if ${1} then
		${2:${VISUAL}}
	else
		${0}
snippet ty
	type ${1:Msg}
		= ${0}
snippet tya
	type alias ${1:Model} =
		${0}
snippet test
	test "${1}" <| \_ -> $0
snippet desc
	describe "${1}" [ $0 ]
snippet doc
	{-| ${0}
	-}
snippet p
	|> ${0}
snippet program Elm 0.18 program
	import Html exposing (Html)


	type alias Model =
		{}


	type Msg
		= Noop


	main : Program Never Model Msg
	main =
		Html.program
			{ init = init
			, view = view
			, update = update
			, subscriptions = subscriptions
			}


	init : ( Model, Cmd Msg )
	init =
		{} ! []


	update : Msg -> Model -> ( Model, Cmd Msg )
	update msg model =
		case msg of
			Noop ->
				model ! []


	subscriptions : Model -> Sub Msg
	subscriptions model =
		Sub.none


	view : Model -> Html Msg
	view model =
		Html.text "Hello, sailor!"
snippet element
	module Main exposing (Model, Msg(..), init, main, subscriptions, update, view)

	import Browser
	import Html exposing (..)
	import Json.Encode


	main : Program Flags Model Msg
	main =
		Browser.element
			{ init = init
			, update = update
			, subscriptions = subscriptions
			, view = view
			}


	type alias Model =
		{}


	type alias Flags =
		Json.Encode.Value


	init : Flags -> ( Model, Cmd Msg )
	init flags_ =
		( {}
		, Cmd.none
		)


	type Msg
		= Noop


	update : Msg -> Model -> ( Model, Cmd Msg )
	update msg model =
		case msg of
			Noop ->
				( model
				, Cmd.none
				)


	subscriptions : Model -> Sub Msg
	subscriptions model =
		Sub.none


	view : Model -> Html Msg
	view model =
		h1 [] [ text "Hello, world!" ]
./snippets/erlang.snippets	[[[1
722
# module
snippet mod
	-module(${1:`vim_snippets#Filename()`}).
# module and export all
snippet modall
	-module(${1:`vim_snippets#Filename()`}).
	-compile([export_all]).

	start() ->
		${0}

	stop() ->
		ok.
snippet d
	erlang:display(${0}),
snippet dt
	erlang:display({${1}, ${0}}),
# define directive
snippet def
	-define(${1:macro}, $2).
# export directive
snippet exp
	-export([${1:function}/${0:arity}]).
# include directive
snippet inc
	-include("${1:file}").
# include_lib directive
snippet incl
	-include_lib("${1:lib}/include/${1}.hrl").${2}
# behavior directive
snippet beh
	-behaviour(${1:behaviour}).
snippet ifd
	-ifdef(${1:TEST}).
	${0}
	-endif.
snippet ifnd
	-ifndef(${1:TEST}).
	${0}
	-endif.
snippet undef
	-undef(${1:macro}).
# if expression
snippet if
	if
		${1:guard} ->
			$0
	end
# case expression
snippet case
	case ${1:expression} of
		${2:pattern} ->
			$0;
	end
# anonymous function
snippet fun
	fun (${1:Parameters}) -> $2 end
# try...catch
snippet try
	try
		${1:${VISUAL}}
	catch
		${2:_:_} -> ${0:got_some_exception}
	end
snippet rcv "Receive Expression"
	receive
	${1:	${2:pattern}${3: when ${4:guard}} ->
			$5
	${6:after
		${7:expression} ->
			$8
	end
# record directive
snippet rec
	-record(${1:record}, {${2:field}=${3:value}}).
# todo comment
snippet todo
	%% TODO: ${0}
## Snippets below (starting with '%') are in EDoc format.
## See http://www.erlang.org/doc/apps/edoc/chapter.html#id56887 for more details
# doc comment
snippet %d
	%% @doc ${0}
# end of doc comment
snippet %e
	%% @end
# specification comment
snippet %s
	%% @spec ${0}
# private function marker
snippet %p
	%% @private
# OTP application
snippet application
	-module(${1:`vim_snippets#Filename()`}).

	-behaviour(application).

	-export([start/2, stop/1]).

	start(_Type, _StartArgs) ->
		case ${0:root_supervisor}:start_link() of
			{ok, Pid} ->
				{ok, Pid};
			Other ->
				{error, Other}
		end.

	stop(_State) ->
		ok.
# OTP supervisor
snippet supervisor
	-module(${1:`vim_snippets#Filename()`}).

	-behaviour(supervisor).

	%% API
	-export([start_link/0]).

	%% Supervisor callbacks
	-export([init/1]).

	-define(SERVER, ?MODULE).

	start_link() ->
			supervisor:start_link({local, ?SERVER}, ?MODULE, []).

	init([]) ->
		Server = {${0:my_server}, {${2}, start_link, []},
			permanent, 2000, worker, [${2}]},
		Children = [Server],
		RestartStrategy = {one_for_one, 0, 1},
		{ok, {RestartStrategy, Children}}.
# OTP gen_server
snippet gen_server
	-module(${0:`vim_snippets#Filename()`}).

	-behaviour(gen_server).

	%% API
	-export([start_link/0]).

	%% gen_server callbacks
	-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

	-define(SERVER, ?MODULE).

	-record(state, {}).

	%%%===================================================================
	%%% API
	%%%===================================================================

	start_link() ->
		gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).

	%%%===================================================================
	%%% gen_server callbacks
	%%%===================================================================

	init([]) ->
		{ok, #state{}}.

	handle_call(_Request, _From, State) ->
		Reply = ok,
		{reply, Reply, State}.

	handle_cast(_Msg, State) ->
		{noreply, State}.

	handle_info(_Info, State) ->
		{noreply, State}.

	terminate(_Reason, _State) ->
		ok.

	code_change(_OldVsn, State, _Extra) ->
		{ok, State}.

	%%%===================================================================
	%%% Internal functions
	%%%===================================================================
# OTP gen_fsm
snippet gen_fsm
	-module(${0:`vim_snippets#Filename()`}).

	-behaviour(gen_fsm).

	%% API
	-export([start_link/0]).

	%% gen_fsm callbacks
	-export([init/1, state_name/2, state_name/3, handle_event/3, handle_sync_event/4,
		handle_info/3, terminate/3, code_change/4]).

	-record(state, {}).

	%%%===================================================================
	%%% API
	%%%===================================================================

	%%--------------------------------------------------------------------
	%% @doc
	%% Creates a gen_fsm process which calls Module:init/1 to
	%% initialize. To ensure a synchronized start-up procedure, this
	%% function does not return until Module:init/1 has returned.
	%%
	%% @spec start_link() -> {ok, Pid} | ignore | {error, Error}
	%% @end
	%%--------------------------------------------------------------------
	start_link() ->
		gen_fsm:start_link({local, ?MODULE}, ?MODULE, [], []).

	%%%===================================================================
	%%% gen_fsm callbacks
	%%%===================================================================

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever a gen_fsm is started using gen_fsm:start/[3,4] or
	%% gen_fsm:start_link/[3,4], this function is called by the new
	%% process to initialize.
	%%
	%% @spec init(Args) -> {ok, StateName, State} |
	%%                     {ok, StateName, State, Timeout} |
	%%                     ignore |
	%%                     {stop, StopReason}
	%% @end
	%%--------------------------------------------------------------------
	init([]) ->
		{ok, state_name, #state{}}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% There should be one instance of this function for each possible
	%% state name. Whenever a gen_fsm receives an event sent using
	%% gen_fsm:send_event/2, the instance of this function with the same
	%% name as the current state name StateName is called to handle
	%% the event. It is also called if a timeout occurs.
	%%
	%% @spec state_name(Event, State) ->
	%%                   {next_state, NextStateName, NextState} |
	%%                   {next_state, NextStateName, NextState, Timeout} |
	%%                   {stop, Reason, NewState}
	%% @end
	%%--------------------------------------------------------------------
	state_name(_Event, State) ->
		{next_state, state_name, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% There should be one instance of this function for each possible
	%% state name. Whenever a gen_fsm receives an event sent using
	%% gen_fsm:sync_send_event/[2,3], the instance of this function with
	%% the same name as the current state name StateName is called to
	%% handle the event.
	%%
	%% @spec state_name(Event, From, State) ->
	%%                   {next_state, NextStateName, NextState} |
	%%                   {next_state, NextStateName, NextState, Timeout} |
	%%                   {reply, Reply, NextStateName, NextState} |
	%%                   {reply, Reply, NextStateName, NextState, Timeout} |
	%%                   {stop, Reason, NewState} |
	%%                   {stop, Reason, Reply, NewState}
	%% @end
	%%--------------------------------------------------------------------
	state_name(_Event, _From, State) ->
		Reply = ok,
		{reply, Reply, state_name, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever a gen_fsm receives an event sent using
	%% gen_fsm:send_all_state_event/2, this function is called to handle
	%% the event.
	%%
	%% @spec handle_event(Event, StateName, State) ->
	%%                   {next_state, NextStateName, NextState} |
	%%                   {next_state, NextStateName, NextState, Timeout} |
	%%                   {stop, Reason, NewState}
	%% @end
	%%--------------------------------------------------------------------
	handle_event(_Event, StateName, State) ->
		{next_state, StateName, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever a gen_fsm receives an event sent using
	%% gen_fsm:sync_send_all_state_event/[2,3], this function is called
	%% to handle the event.
	%%
	%% @spec handle_sync_event(Event, From, StateName, State) ->
	%%                   {next_state, NextStateName, NextState} |
	%%                   {next_state, NextStateName, NextState, Timeout} |
	%%                   {reply, Reply, NextStateName, NextState} |
	%%                   {reply, Reply, NextStateName, NextState, Timeout} |
	%%                   {stop, Reason, NewState} |
	%%                   {stop, Reason, Reply, NewState}
	%% @end
	%%--------------------------------------------------------------------
	handle_sync_event(_Event, _From, StateName, State) ->
		Reply = ok,
		{reply, Reply, StateName, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% This function is called by a gen_fsm when it receives any
	%% message other than a synchronous or asynchronous event
	%% (or a system message).
	%%
	%% @spec handle_info(Info,StateName,State)->
	%%                   {next_state, NextStateName, NextState} |
	%%                   {next_state, NextStateName, NextState, Timeout} |
	%%                   {stop, Reason, NewState}
	%% @end
	%%--------------------------------------------------------------------
	handle_info(_Info, StateName, State) ->
		{next_state, StateName, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% This function is called by a gen_fsm when it is about to
	%% terminate. It should be the opposite of Module:init/1 and do any
	%% necessary cleaning up. When it returns, the gen_fsm terminates with
	%% Reason. The return value is ignored.
	%%
	%% @spec terminate(Reason, StateName, State) -> void()
	%% @end
	%%--------------------------------------------------------------------
	terminate(_Reason, _StateName, _State) ->
		ok.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Convert process state when code is changed
	%%
	%% @spec code_change(OldVsn, StateName, State, Extra) ->
	%%                   {ok, StateName, NewState}
	%% @end
	%%--------------------------------------------------------------------
	code_change(_OldVsn, StateName, State, _Extra) ->
		{ok, StateName, State}.

	%%%===================================================================
	%%% Internal functions
	%%%===================================================================
# OTP gen_event
snippet gen_event
	-module(${0:`vim_snippets#Filename()`}).

	-behaviour(gen_event).

	%% API
	-export([start_link/0,
		add_handler/2]).

	%% gen_event callbacks
	-export([init/1,
		handle_event/2,
		handle_call/2,
		handle_info/2,
		terminate/2,
		code_change/3]).

	-record(state, {}).

	%%%===================================================================
	%%% gen_event callbacks
	%%%===================================================================

	%%--------------------------------------------------------------------
	%% @doc
	%% Creates an event manager
	%%
	%% @spec start_link() -> {ok, Pid} | {error, Error}
	%% @end
	%%--------------------------------------------------------------------
	start_link() ->
		gen_event:start_link({local, ?MODULE}).

	%%--------------------------------------------------------------------
	%% @doc
	%% Adds an event handler
	%%
	%% @spec add_handler(Handler, Args) -> ok | {'EXIT', Reason} | term()
	%% @end
	%%--------------------------------------------------------------------
	add_handler(Handler, Args) ->
		gen_event:add_handler(?MODULE, Handler, Args).

	%%%===================================================================
	%%% gen_event callbacks
	%%%===================================================================

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever a new event handler is added to an event manager,
	%% this function is called to initialize the event handler.
	%%
	%% @spec init(Args) -> {ok, State}
	%% @end
	%%--------------------------------------------------------------------
	init([]) ->
		{ok, #state{}}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever an event manager receives an event sent using
	%% gen_event:notify/2 or gen_event:sync_notify/2, this function is
	%% called for each installed event handler to handle the event.
	%%
	%% @spec handle_event(Event, State) ->
	%%                          {ok, State} |
	%%                          {swap_handler, Args1, State1, Mod2, Args2} |
	%%                          remove_handler
	%% @end
	%%--------------------------------------------------------------------
	handle_event(_Event, State) ->
		{ok, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever an event manager receives a request sent using
	%% gen_event:call/3,4, this function is called for the specified
	%% event handler to handle the request.
	%%
	%% @spec handle_call(Request, State) ->
	%%                   {ok, Reply, State} |
	%%                   {swap_handler, Reply, Args1, State1, Mod2, Args2} |
	%%                   {remove_handler, Reply}
	%% @end
	%%--------------------------------------------------------------------
	handle_call(_Request, State) ->
		Reply = ok,
		{ok, Reply, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% This function is called for each installed event handler when
	%% an event manager receives any other message than an event or a
	%% synchronous request (or a system message).
	%%
	%% @spec handle_info(Info, State) ->
	%%                         {ok, State} |
	%%                         {swap_handler, Args1, State1, Mod2, Args2} |
	%%                         remove_handler
	%% @end
	%%--------------------------------------------------------------------
	handle_info(_Info, State) ->
		{ok, State}.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Whenever an event handler is deleted from an event manager, this
	%% function is called. It should be the opposite of Module:init/1 and
	%% do any necessary cleaning up.
	%%
	%% @spec terminate(Reason, State) -> void()
	%% @end
	%%--------------------------------------------------------------------
	terminate(_Reason, _State) ->
		ok.

	%%--------------------------------------------------------------------
	%% @private
	%% @doc
	%% Convert process state when code is changed
	%%
	%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
	%% @end
	%%--------------------------------------------------------------------
	code_change(_OldVsn, State, _Extra) ->
		{ok, State}.

	%%%===================================================================
	%%% Internal functions
	%%%===================================================================
# EUnit snippets
snippet eunit
	-module(${1:`vim_snippets#Filename()`}).
	-include_lib("eunit/include/eunit.hrl").

	${0}
snippet ieunit
	-ifdef(TEST).
	-include_lib("eunit/include/eunit.hrl").

	${0}

	-endif.
snippet itest
	-ifdef(TEST).

	${1}_test() ->
		${0}

	-endif.
snippet test
	${1}_test() ->
		${0}
snippet as
	?assert(${0})
snippet asn
	?assertNot(${0})
snippet aseq
	?assertEqual(${1}, ${0})
snippet asneq
	?assertNotEqual(${1}, ${0})
snippet asmat
	?assertMatch(${1:Pattern}, ${0:Expression})
snippet asnmat
	?assertNotMatch(${1:Pattern}, ${0:Expression})
snippet aserr
	?assertError(${1:Pattern}, ${0:Expression})
snippet asex
	?assertExit(${1:Pattern}, ${0:Expression})
snippet asexc
	?assertException(${1:Class}, ${2:Pattern}, ${0:Expression})
# common_test test_SUITE
snippet testsuite
	-module(${0:`vim_snippets#Filename()`}).

	-include_lib("common_test/include/ct.hrl").

	%% Test server callbacks
	-export([suite/0, all/0, groups/0,
		init_per_suite/1, end_per_suite/1,
		init_per_group/2, end_per_group/2,
		init_per_testcase/2, end_per_testcase/2]).

	%% Test cases
	-export([
		]).

	%%--------------------------------------------------------------------
	%% COMMON TEST CALLBACK FUNCTIONS
	%%--------------------------------------------------------------------

	%%--------------------------------------------------------------------
	%% Function: suite() -> Info
	%%
	%% Info = [tuple()]
	%%   List of key/value pairs.
	%%
	%% Description: Returns list of tuples to set default properties
	%%              for the suite.
	%%
	%% Note: The suite/0 function is only meant to be used to return
	%% default data values, not perform any other operations.
	%%--------------------------------------------------------------------
	suite() ->
	    [{timetrap,{minutes,10}}].

	%%--------------------------------------------------------------------
	%% Function: init_per_suite(Config0) ->
	%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
	%%
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding the test case configuration.
	%% Reason = term()
	%%   The reason for skipping the suite.
	%%
	%% Description: Initialization before the suite.
	%%
	%% Note: This function is free to add any key/value pairs to the Config
	%% variable, but should NOT alter/remove any existing entries.
	%%--------------------------------------------------------------------
	init_per_suite(Config) ->
	    Config.

	%%--------------------------------------------------------------------
	%% Function: end_per_suite(Config0) -> void() | {save_config,Config1}
	%%
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding the test case configuration.
	%%
	%% Description: Cleanup after the suite.
	%%--------------------------------------------------------------------
	end_per_suite(_Config) ->
	    ok.

	%%--------------------------------------------------------------------
	%% Function: init_per_group(GroupName, Config0) ->
	%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
	%%
	%% GroupName = atom()
	%%   Name of the test case group that is about to run.
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding configuration data for the group.
	%% Reason = term()
	%%   The reason for skipping all test cases and subgroups in the group.
	%%
	%% Description: Initialization before each test case group.
	%%--------------------------------------------------------------------
	init_per_group(_GroupName, Config) ->
	    Config.

	%%--------------------------------------------------------------------
	%% Function: end_per_group(GroupName, Config0) ->
	%%               void() | {save_config,Config1}
	%%
	%% GroupName = atom()
	%%   Name of the test case group that is finished.
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding configuration data for the group.
	%%
	%% Description: Cleanup after each test case group.
	%%--------------------------------------------------------------------
	end_per_group(_GroupName, _Config) ->
	    ok.

	%%--------------------------------------------------------------------
	%% Function: init_per_testcase(TestCase, Config0) ->
	%%               Config1 | {skip,Reason} | {skip_and_save,Reason,Config1}
	%%
	%% TestCase = atom()
	%%   Name of the test case that is about to run.
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding the test case configuration.
	%% Reason = term()
	%%   The reason for skipping the test case.
	%%
	%% Description: Initialization before each test case.
	%%
	%% Note: This function is free to add any key/value pairs to the Config
	%% variable, but should NOT alter/remove any existing entries.
	%%--------------------------------------------------------------------
	init_per_testcase(_TestCase, Config) ->
	    Config.

	%%--------------------------------------------------------------------
	%% Function: end_per_testcase(TestCase, Config0) ->
	%%               void() | {save_config,Config1} | {fail,Reason}
	%%
	%% TestCase = atom()
	%%   Name of the test case that is finished.
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding the test case configuration.
	%% Reason = term()
	%%   The reason for failing the test case.
	%%
	%% Description: Cleanup after each test case.
	%%--------------------------------------------------------------------
	end_per_testcase(_TestCase, _Config) ->
	    ok.

	%%--------------------------------------------------------------------
	%% Function: groups() -> [Group]
	%%
	%% Group = {GroupName,Properties,GroupsAndTestCases}
	%% GroupName = atom()
	%%   The name of the group.
	%% Properties = [parallel | sequence | Shuffle | {RepeatType,N}]
	%%   Group properties that may be combined.
	%% GroupsAndTestCases = [Group | {group,GroupName} | TestCase]
	%% TestCase = atom()
	%%   The name of a test case.
	%% Shuffle = shuffle | {shuffle,Seed}
	%%   To get cases executed in random order.
	%% Seed = {integer(),integer(),integer()}
	%% RepeatType = repeat | repeat_until_all_ok | repeat_until_all_fail |
	%%              repeat_until_any_ok | repeat_until_any_fail
	%%   To get execution of cases repeated.
	%% N = integer() | forever
	%%
	%% Description: Returns a list of test case group definitions.
	%%--------------------------------------------------------------------
	groups() ->
	    [].

	%%--------------------------------------------------------------------
	%% Function: all() -> GroupsAndTestCases | {skip,Reason}
	%%
	%% GroupsAndTestCases = [{group,GroupName} | TestCase]
	%% GroupName = atom()
	%%   Name of a test case group.
	%% TestCase = atom()
	%%   Name of a test case.
	%% Reason = term()
	%%   The reason for skipping all groups and test cases.
	%%
	%% Description: Returns the list of groups and test cases that
	%%              are to be executed.
	%%--------------------------------------------------------------------
	all() ->
	    [].


	%%--------------------------------------------------------------------
	%% TEST CASES
	%%--------------------------------------------------------------------

	%%--------------------------------------------------------------------
	%% Function: TestCase(Config0) ->
	%%               ok | exit() | {skip,Reason} | {comment,Comment} |
	%%               {save_config,Config1} | {skip_and_save,Reason,Config1}
	%%
	%% Config0 = Config1 = [tuple()]
	%%   A list of key/value pairs, holding the test case configuration.
	%% Reason = term()
	%%   The reason for skipping the test case.
	%% Comment = term()
	%%   A comment about the test case that will be printed in the html log.
	%%
	%% Description: Test case function. (The name of it must be specified in
	%%              the all/0 list or in a test case group for the test case
	%%              to be executed).
	%%--------------------------------------------------------------------

./snippets/eruby.snippets	[[[1
138
# .erb and .rhmtl files

# Includes html.snippets
extends html

# Rails *****************************
snippet rc
	<% ${0} %>
snippet rce
	<%= ${1} %>
snippet %
	<% ${0} %>
snippet =
	<%= ${1} %>
snippet end
	<% end %>
snippet ead
	<% ${1}.each do |${2}| %>
		${0}
	<% end %>
snippet for
	<% for ${2:item} in ${1} %>
		${0}
	<% end %>
snippet rp
	<%= render partial: '${0:item}' %>
snippet rpl
	<%= render partial: '${1:item}', locals: { :${2:name} => '${3:value}'${0} } %>
snippet rps
	<%= render partial: '${1:item}', status: ${0:500} %>
snippet rpc
	<%= render partial: '${1:item}', collection: ${0:items} %>
snippet lia
	<%= link_to '${1:link text...}', action: '${0:index}' %>
snippet liai
	<%= link_to '${1:link text...}', action: '${2:edit}', id: ${0:@item} %>
snippet lic
	<%= link_to '${1:link text...}', controller: '${0:items}' %>
snippet lica
	<%= link_to '${1:link text...}', controller: '${2:items}', action: '${0:index}' %>
snippet licai
	<%= link_to '${1:link text...}', controller: '${2:items}', action: '${3:edit}', id: ${0:@item} %>
snippet lib
	<%= link_to '${1:link text...}' do %>
	<% end %>
snippet yield
	<%= yield ${1::content_symbol} %>
snippet conf
	<% content_for :${1:head} do %>
		${0}
	<% end %>

snippet cs 
	<%= collection_select(:${1:object}, :${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>        
snippet ct
	<%= content_tag '${1:DIV}', ${2:content}${0:,options} %>
snippet ff
	<%= form_for @${1:model} do |f| %>
		${0}
	<% end %>
snippet ffi
	<%= ${1:f}.input :${0:attribute} %>
snippet ffcb
	<%= ${1:f}.check_box :${0:attribute} %>
snippet ffe
	<% error_messages_for :${1:model} %>

	<%= form_for @${2:model} do |f| %>
		${0}
	<% end %>
snippet ffff
	<%= ${1:f}.file_field :${0:attribute} %>
snippet ffhf
	<%= ${1:f}.hidden_field :${0:attribute} %>
snippet ffl
	<%= ${1:f}.label :${2:attribute}, '${0:$2}' %>
snippet ffpf
	<%= ${1:f}.password_field :${0:attribute} %>
snippet ffrb
	<%= ${1:f}.radio_button :${2:attribute}, :${0:tag_value} %>
snippet ffs
	<%= ${1:f}.submit "${0:submit}" %>
snippet ffta
	<%= ${1:f}.text_area :${0:attribute} %>
snippet fftf
	<%= ${1:f}.text_field :${0:attribute} %>
snippet fcs
	<%= ${1:f}.collection_select(:${2:method}, ${3:collection}, :${4:value_method}, :${5:text_method}, options = {${0:prompt: true}}) %>
snippet fields
	<%= fields_for :${1:model}, @$1 do |${2:f}| %>
		${0}
	<% end %>
snippet i18
	I18n.t('${1:type.key}')
snippet it
	<%= image_tag "${1}"${0} %>
snippet jit
	<%= javascript_include_tag ${0::all} %>
snippet jsit
	<%= javascript_include_tag "${0}" %>
snippet lim
	<%= link_to ${1:model}.${2:name}, ${3:$1}_path(${0:$1}) %>
snippet linp
	<%= link_to "${1:Link text...}", ${2:parent}_${3:child}_path(${4:@$2}, ${0:@$3}) %>
snippet linpp
	<%= link_to "${1:Link text...}", ${2:parent}_${3:child}_path(${0:@$2}) %>
snippet lip
	<%= link_to "${1:Link text...}", ${2:model}_path(${0:@$2}) %>
snippet lipp
	<%= link_to "${1:Link text...}", ${0:model}s_path %>
snippet lt
	<%= link_to "${1:name}", ${0:dest} %>
snippet ntc
	<%= number_to_currency(${1}) %>
snippet ofcfs
	<%= options_from_collection_for_select ${1:collection}, ${2:value_method}, ${3:text_method}, ${0:selected_value} %>
snippet ofs
	<%= options_for_select ${1:collection}, ${2:value_method} %>
snippet rf
	<%= render file: "${1:file}"${0} %>
snippet rt
	<%= render template: "${1:file}"${0} %>
snippet slt
	<%= stylesheet_link_tag ${1::all}, cache: ${0:true} %>
snippet sslt
	<%= stylesheet_link_tag "${0}" %>
snippet if
	<% if ${1} %>
		${0:${VISUAL}}
	<% end %>
snippet ife
	<% if ${1} %>
		${2}
	<% else %>
		${0}
	<% end %>
snippet pry
	<% require 'pry'; binding.pry %>
./snippets/falcon.snippets	[[[1
71
snippet #!
	#!/usr/bin/env falcon

# Import
snippet imp
	import ${0:module}

# Function
snippet fun
	function ${2:function_name}(${3})
		${0}
	end

# Class
snippet class
	class ${1:class_name}(${2:class_params})
		${0:/* members/methods */}
	end

# If
snippet if
	if $1
		${0}
	end

# If else
snippet ife
	if $1
		${0}
	else
	    ${1}
	end

# If else if
snippet eif
	elif $1
		${0}

# Switch case
snippet switch
	switch ${1:expression}
		case ${2:item}
		case ${0:item}
		default
	end

# Select
snippet select
	select ${1:variable}
		case ${2:TypeSpec}
		case ${0:TypeSpec}
		default
	end

# For/in Loop
snippet forin
	for ${1:element} in ${2:container}
		${0}
	end

# For/to Loop
snippet forto
	for ${1:lowerbound} to ${2:upperbound}
		${0}
	end

# While Loop
snippet wh
	while ${1:conidition}
		${0}
	end
./snippets/fortran.snippets	[[[1
103
snippet impl
	implicit none
		${0}
snippet prog
	program ${1:main}
		${0}
	end program $1
snippet mod
	module ${1:modulename}
		${0}
	end module $1
snippet proc
	procedure ${1:name}
		${0}
	end procedure $1
snippet iface
	interface ${1:name}
		${0}
	end interface $1
snippet doc
	! """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	! File: ${2:`vim_snippets#Filename('$1')`}
	! Author: `g:snips_author`
	! Email: `g:snips_email`
	! Github: `g:snips_github`
	! Description: $1
	! """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	${0}
snippet dox
	!> @brief ${1}
	!!
	!> ${2}
	!> @author `g:snips_author`
	${0}
snippet doxp
	!> @param[${1}]${0}
# Variables definitions
# Boolean
snippet bool
	logical :: ${0}
# Integer
snippet int
	integer :: ${0}
snippet real
	real :: ${0}
# Double Precision
snippet double
	double precision :: ${0}
# Char
snippet str
	character(len=${1:*}) :: ${0:}
# Types
snippet type
	type(${1:name})
		${0}
	end type
snippet const
	${1:type}, parameter :: $2 = ${0}
snippet arr
	${1:type}, ${2:allocatable, }dimension(${3::}) :: ${0}
snippet intent
	${1:type}, intent(inout) :: ${0}
# Array
snippet /
	(/ $1 /) ${2:,&} ${0}
snippet if
	if ($1) then
		${0}
	end if
snippet case
	select case (${1:expr})
		case ($2)
		case default
			$3
	end select ${0}
snippet do
	do ${1:i} = ${2:start}, ${3:end}, ${4:incr}
		${0}
	end do
snippet dow
	do while ($1)
		$2
	end do
snippet sub
	subroutine ${1:name}($2)
		${0}
	end subroutine $1
snippet func
	function ${1:name}($2) result($3)
		${0}
	end function $1
snippet pr
	write(*,*) ${0}
snippet dpr
	write(*,*) '$1 = ', $1
snippet read
	read(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}
snippet write
	write(unit = ${1:fp}, file = ${2:filename}, iostat = ${3:ierr}) ${0}
snippet open
	open(unit = ${1:fp}, file = ${2:filename}, status = ${3:unknown}, iostat = ${4:ierr}) ${0}
snippet close
	close(unit = ${1:fp}) ${0}
./snippets/freemarker.snippets	[[[1
74
extends html

# Freemarker version
snippet ver "${.version}"
	\${.version}
# Interpolation
snippet int "${interpolation}"
	\${${0:interpolation${VISUAL}}\}
# Interpolation with default string
snippet intd "${interpolation!"default_string"}"
	\${${0:interpolation${VISUAL}}!"${1:default_string}"\}
# Comment
snippet com "<#-- comment -->"
	<#-- ${0:comment${VISUAL}} -->
# Variable assignment on a single line
snippet ass "<#assign variable_name = value />"
	<#assign ${1:variable_name} = ${0:value${VISUAL}} />
# Variable assignments on multiple lines
snippet assm "<#assign <#-- multiple lines --> />"
	<#assign
		${1:variable_name} = ${0:value${VISUAL}}
	/>
# Local variable assignment on a single
snippet loc "<#local variable_name = value />"
	<#local ${1:variable_name} = ${0:value${VISUAL}} />
# Local variable assignments on multiple lines
snippet locm "<#local <#-- multiple lines --> />"
	<#local
		${1:variable_name} = ${0:value${VISUAL}}
	/>
# Include Freemarker file
snippet inc "<#include \"file.ftl\" />"
	<#include "${0:file.ftl${VISUAL}}" />
# If statement
snippet if "<#if condition>...</#if>"
	<#if ${1:true}>
		${0:${VISUAL}}
	</#if>
# If/else statement
snippet ife "<#if condition>...<#else>...</#if>"
	<#if ${1:true}>
		${0:${VISUAL}}
	<#else>
		${2}
	</#if>
# Iteration over a sequence
snippet lis "<#list sequence as element>...</#list>"
	<#list ${1:sequence} as ${2:element}>
		${0:${VISUAL}}
	</#list>
# Iteration over an hashmap
snippet lish "<#list hashmap?keys as element>...</#list>"
	<#list ${1:hashmap}?keys as ${2:key}>
		\${$2\}: \${$1[$2]\}${0:${VISUAL}}
	</#list>
# Macro statement
snippet mac "<#macro macro_name param1>...</#macro>"
	<#macro ${1:macro_name} ${2:param1}>
		${0:${VISUAL}}
	</#macro>
# Function statement
snippet fun "<#function function_name param1>...</#function>"
	<#function ${1:function_name} ${2:param1}>
		${0:${VISUAL}}
	</#function>
# Attempt statement (try-catch to prevent runtime exceptions)
snippet att "<#attempt>...<#recover></#attempt>"
	<#attempt>
		${0:${VISUAL}}
	<#recover>
	</#attempt>
# Then built-in for booleans
snippet ?th "?then(true, false)"
	?then(${1:true}, ${0:false${VISUAL}})
./snippets/fsharp.snippets	[[[1
80
snippet doc
	/// ${0}
snippet comment
	// ${0}
snippet let
	let ${1} = ${0}
snippet lit
	[<Literal>]
	let ${1} = ${0}
snippet rec
	type ${1} = { ${0} }
snippet arec
	{| ${0} |}
snippet fn
	let ${1} =
		${0}
snippet fnr
	let rec ${1} =
		${0}
snippet lam
	(fun ${1} -> ${0})
snippet mod
	module ${1} =
		${0}
snippet for
	for ${1} in ${2} do
		${0}
snippet if
	if ${1} then
		${2}
snippet ife
	if ${1} then
		${2}
	else
		${0}
snippet ifee
	if ${1} then
		${2}
	elif ${3} then
		${4}
	else
		${0}
snippet eif
	elif ${1} then
		${0}
snippet el
	else
		${0}
snippet try
	try
		${1}
	with ${0}
snippet match
	match ${1} with
	| ${2} -> ${0}
snippet |
	| ${1} -> ${0}
snippet p
	|> ${0}
snippet pr
	printfn "${1}" ${0}
snippet pri
	printfn \$"${0}"
snippet amap
	|> Array.map (fun ${1} -> ${0})
snippet lmap
	|> List.map (fun ${1} -> ${0})
snippet smap
	|> Seq.map (fun ${1} -> ${0})
snippet atap
	|> Array.map (fun x -> printfn "%A" x; x) // tap
snippet ltap
	|> List.map (fun x -> printfn "%A" x; x) // tap
snippet stap
	|> Seq.map (fun x -> printfn "%A" x; x) // tap
snippet main
	[<EntryPoint>]
	let main argv =
		${0}
		0
./snippets/gdscript.snippets	[[[1
125
snippet class
	class $1 extends ${2:Reference}
	\t$3


snippet pr
	print($1)


snippet ready
	func _ready():
	\t${1:pass}


snippet init
	func _init():
	\t${1:pass}


snippet process
	func _process(delta):
	\t${1:pass}


snippet input
	func _input(event):
	\t${1:pass}


snippet inpute
	func _input_event(event):
	\t${1:pass}


snippet draw
	func _draw():
	\t${1:pass}


snippet guii
	func _gui_input(event):
	\t${1:pass}


snippet for
	for $1 in $2:
	\t${3:pass}


snippet for
	for $1 in range(${2:start}{$3:,end}):
	\t${4:pass}


snippet if
	if ${1:condition}:
	\t${3:pass}
	elif ${2:condition}:
	\t${4:pass}
	else:
	\t${5:pass}


snippet if
	if ${1:condition}:
	\t${2:pass}
	else:
	\t${3:pass}


snippet if
	if ${1:condition}:
	\t${2:pass}


snippet while
	while ${1:condition}:
	\t${2:pass}


snippet func
	func ${1:method}(${2:args}):
	\t${3:pass}


snippet signal
	signal ${1:signalname}(${2:args})


snippet export
	export(${1:type}${2:,other_configs}) var ${3:name}${4: = default}${5: setget }


snippet var
	var ${1:name}${2: = default}${3: setget }


snippet onready
	onready var ${1:name} = get_node($2)


snippet is
	${1:instance} is ${2:class}


snippet in
	${1:element} in ${$2:array}


snippet gdscript
	extends ${1:BaseClass}

	# class member variables go here, for example:
	# var a = 2
	# var b = \textvar\

	func _ready():
	\t# Called every time the node is added to the scene.
	\t# Initialization here
	\tpass



# snippet pass  ##### do we really need this?
# 	pass
./snippets/gitcommit.snippets	[[[1
2
snippet co
	Co-authored-by: ${1} <${2}>
./snippets/gleam.snippets	[[[1
98
snippet fn "fn"
  fn ${1:function_name}(${2}) -> ${3:Nil} {
    ${0:${VISUAL:todo}}
  }

snippet pfn "pub fn"
  pub fn ${1:function_name}(${2}) -> ${3:Nil} {
    ${0:${VISUAL:todo}}
  }

snippet test "test fn"
  pub fn ${1:name}_test() {
    ${0}
  }

snippet af "anonymous fn"
  fn(${1}) { ${0:${VISUAL}} }

snippet let "let binding"
  let ${1} = ${0}

snippet l "let binding"
  let ${1} = ${0}

snippet as "assert binding"
  assert ${1} = ${0}

snippet tr "try binding"
  try ${1} = ${0}

snippet - "->"
  -> ${0}

snippet case "case expression"
  case ${1} {
    ${2} -> ${0}
  }

snippet ty "type"
  type ${1:Name} {
    ${0:$1}
  }

snippet pty "pub type"
  pub type ${1:Name} {
    ${0:$1}
  }

snippet tya "type alias"
  type ${1:Name} =
    ${0:$1}

snippet ptya "pub type alias"
  pub type ${1:Name} =
    ${0:$1}

snippet ext "external type"
  external type ${0}

snippet pext "pub external type"
  pub external type ${0}

snippet exfn "external fn"
  external fn ${1:function_name}(${2}) -> ${3}
    = "${4}" "${0}"

snippet pexfn "pub external fn"
  pub external fn ${1:function_name}(${2}) -> ${3}
    = "${4}" "${0}"

snippet im "import"
  import ${0:gleam/result}

snippet im. "import exposing"
  import ${1:gleam/result}.{${0}}

snippet p "|>"
  |> ${0}

snippet tup "tuple()"
  tuple(${0:${VISUAL}})

snippet bl "block"
  {
    ${0:${VISUAL}}
  }

snippet tf "fn(Type) -> Type"
  fn(${1}) -> ${0}

snippet seq "should.equal"
  should.equal(${0:${VISUAL}})

snippet strue "should.be_true"
  should.be_true(${0:${VISUAL}})

snippet sfalse "should.be_false"
  should.be_true(${0:${VISUAL}})
./snippets/go.snippets	[[[1
280
snippet v "shorthand variable declaration"
	${1} := ${2}

snippet vr "variable initialization"
	var ${1:t} ${0:string}

snippet var "variable declaration"
	var ${1} ${2} = ${3}

snippet vars "variables declaration"
	var (
		${1} ${2} = ${3}
	)

snippet ap "append"
	append(${1:slice}, ${0:value})

snippet bl "bool"
	bool

snippet bt "byte"
	byte

snippet br "break"
	break

snippet ch "channel"
	chan ${0:int}

snippet cs "case"
	case ${1:value}:
		${0:${VISUAL}}

snippet co "constants with iota"
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)

snippet cn "continue"
	continue

snippet df "defer"
	defer ${0:func}()

snippet dfr "defer recover"
	defer func() {
		if err := recover(); err != nil {
			${0:${VISUAL}}
		}
	}()

snippet im "import"
	import (
		"${1:package}"
	)

snippet in "interface"
	interface{}

snippet inf "full interface "
	interface ${1:name} {
		${2:/* methods */}
	}

snippet if "if condition"
	if $1 {
		${2:${VISUAL}}
	}


snippet ife "if else condition"
	if $1 {
		${2:${VISUAL}}
	} else {
		${0}
	}

snippet el "else"
	else {
		${0:${VISUAL}}
	}

snippet ir "if error not nil, return err"
	if err != nil {
		return err
	}
	${0}

snippet f "false"
	false

snippet ft "fallthrough"
	fallthrough

snippet fl "float"
	float32

snippet f3 "float32"
	float32

snippet f6 "float64"
	float64

snippet for "for loop"
	for ${1}{
		${0:${VISUAL}}
	}

snippet fori "for int loop"
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
		${0:${VISUAL}}
	}

snippet forr "for range loop"
	for ${1:e} := range ${2:collection} {
		${0:${VISUAL}}
	}

snippet fun "function"
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}
	${0}

snippet fum "method"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}

snippet fumh "http handler function on receiver"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
		${0:${VISUAL}}
	}

snippet lf "log printf"
	log.Printf("%${1:s}", ${2:var})

snippet lp "log println"
	log.Println("${1}")

snippet mk "make"
	make(${1:[]string}, ${0:0})

snippet mp "map"
	map[${1:string}]${0:int}

snippet main "func main()"
	func main() {
		${1}
	}
	${0}

snippet nw "new"
	new(${0:type})

snippet pa "package"
	package ${1:main}

snippet pn "panic"
	panic("${0:msg}")

snippet pf "fmt.Printf()"
	fmt.Printf("%${1:s}\n", ${2:var})

snippet pl "fmt.Println()"
	fmt.Println("${1:s}")

snippet rn "range"
	range ${0}

snippet rt "return"
	return ${0}

snippet rs "result"
	result

snippet sl "select"
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	default:
		${0}
	}

snippet sr "string"
	string

snippet st "struct"
	struct ${1:name} {
		${2:/* data */}
	}
	${0}

snippet sw "switch"
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}

snippet ps "fmt.Sprintf"
	fmt.Sprintf("%${1:s}", ${2:var})

snippet t "true"
	true

snippet g "goroutine named function"
	go ${1:funcName}(${0})

snippet ga "goroutine anonymous function"
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})

snippet test "test function"
	func Test${1:name}(t *testing.T) {
		${0:${VISUAL}}
	}

snippet testt "table test function"
	func Test${1:name}(t *testing.T) {
		tests := []struct {
			name string
		}{
			{
				name: "${2:test name}",
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				${0:${VISUAL}}
			})
		}
	}

snippet bench "benchmark function"
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}

snippet cl "composite literals"
	type ${1:name} struct {
		${2:attrName} ${3:attrType}
	}

snippet om "if key in a map"
	if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
		${4:/* code */}
	}


snippet gg "Grouped globals with anonymous struct"
	var ${1:var} = struct{
		${2:name} ${3:type}
	}{
		$2: ${4:value},
	}


snippet ja "Marshalable json alias"
	type ${1:parentType}Alias $1

	func (p *$1) MarshalJSON() ([]byte, error) {
		return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
	}


snippet errwr "Error handling with fmt.Errorf"
	if ${1}err != nil {
		return fmt.Errorf("${2} %w", err)
	}
./snippets/haml.snippets	[[[1
37
snippet t
	%table
		%tr
			%th
				${1:headers}
		%tr
			%td
				${0:headers}
snippet ul
	%ul
		%li
			${0:item}
		%li
snippet rp
	= render :partial => "${0:item}"
snippet rpc
	= render :partial => "${1:item}", :collection => ${0:@$1s}
snippet rpl
	= render :partial => "${1:item}", :locals => { :${2:$1} => ${0:@$1} }
snippet rpo
	= render :partial => "${1:item}", :object => ${0:@$1}
snippet lt
	= link_to ${1:name}, ${2:dest}
snippet mt
	= mail_to ${1:email_address}, ${2:name}
snippet mts
	= mail_to ${1:email_address}, ${2:name}, :subject => ${3}, :body => ${4}
snippet ife
	- if $1
		${2:${VISUAL}}
	- else
		${0}
snippet ifp
	- if $1.presence?
		${0:${VISUAL}}
snippet ntc
	= number_to_currency(${1})
./snippets/handlebars.snippets	[[[1
14
snippet if # {{#if value}} ... {{/if}}
	{{#if ${1:value}}}
	${0:${VISUAL}}
	{{/if}}
snippet ifn # {{#unless value}} ... {{/unless}}
	{{#unless ${1:value}}}
	${0:${VISUAL}}
	{{/unless}}
snippet ife # {{#if value}} ... {{else}} .. {{/if}}
	{{#if ${1:value}}}
	${2:${VISUAL}}
	{{else}}
	${3}
	{{/if}}
./snippets/haskell.snippets	[[[1
151
snippet lang
	{-# LANGUAGE ${0:OverloadedStrings} #-}
snippet haddock
	{-# OPTIONS_HADDOCK ${0:hide} #-}
snippet ghc
	{-# OPTIONS_GHC ${0:-fno-warn-unused-imports} #-}
snippet inline
	{-# INLINE ${0:name} #-}
snippet info
	-- |
	-- Module      :  ${1:`substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`}
	-- Copyright   :  ${2:Author} ${3:2011-2012}
	-- License     :  ${4:BSD3}
	--
	-- Maintainer  :  ${5:email@something.com}
	-- Stability   :  ${6:experimental}
	-- Portability :  ${7:unknown}
	--
	-- ${0:Description}
	--
snippet imp
	import ${0:Data.Text}
snippet import
	import ${0:Data.Text}
snippet import2
	import ${1:Data.Text} (${0:head})
snippet impq
	import qualified ${1:Data.Text} as ${0:T}
snippet importq
	import qualified ${1:Data.Text} as ${0:T}
snippet inst
	instance ${1:Monoid} ${2:Type} where
		${0}
snippet ty
	type ${1:Type} = ${0:Type}
snippet type
	type ${1:Type} = ${0:Type}
snippet da
	data ${1:Type} = ${2:$1} ${0:Int}
snippet data
	data ${1:Type} = ${2:$1} ${0:Int}
snippet newtype
	newtype ${1:Type} = ${2:$1} ${0:Int}
snippet class
	class ${1:Class} a where
		${0}
snippet module
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (
	) where
	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`

snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
		( ${1}
		) where

	`expand('%') =~ 'Main' ? "\nmain :: IO ()\nmain = undefined" : ""`
snippet main
	main :: IO ()
	main = ${0:undefined}
snippet const
	${1:name} :: ${2:a}
	$1 = ${0:undefined}
snippet fn
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
snippet fn0
	${1:fn} :: ${2:a}
	$1 = ${0:undefined}
snippet fn1
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4} = ${0:undefined}
snippet fn2
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5} = ${0:undefined}
snippet fn3
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6} = ${0:undefined}
snippet => "Type constraint"
	(${1:Class} ${2:a}) => $2
snippet ap
	${1:map} ${2:fn} ${0:list}
snippet \
	\\${1:x} -> ${0:expression}
snippet (\
	(\\${1:x} -> ${0:expression})
snippet <-
	${1:a} <- ${0:m a}
snippet ->
	${1:m a} -> ${0:a}
snippet tup
	(${1:a}, ${0:b})
snippet tup2
	(${1:a}, ${2:b}, ${0:c})
snippet tup3
	(${1:a}, ${2:b}, ${3:c}, ${0:d})
snippet rec
	${1:Record} { ${2:recFieldA} = ${3:undefined}
				, ${4:recFieldB} = ${0:undefined}
				}
snippet case
	case ${1:something} of
		${2} -> ${0}
snippet let
	let ${1} = ${2}
	in ${3}
snippet where
	where
		${1:fn} = ${0:undefined}
snippet spec
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.QuickCheck

	main :: IO ()
	main = hspec spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0
snippet specf
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')` (main, spec) where

	import Test.Hspec
	import Test.Hspec.Runner (configFastFail, defaultConfig, hspecWith)

	main :: IO ()
	main = hspecWith defaultConfig {configFastFail = True} spec

	spec :: Spec
	spec =
		describe "${1}" $ do
			it "${2}" $
				$0
snippet desc
	describe "${1}" $ do
		$0
snippet it
	it "${1}" $
		$0
snippet itp
	it "${1}" $ property $
		$0
snippet sb
	\`shouldBe\` $0
snippet doc
	{-| ${0}
	-}
./snippets/heex.snippets	[[[1
1
extends eelixir
./snippets/helm.snippets	[[[1
591
snippet service_sample_spec
	apiVersion: v1
	kind: Service
	metadata:
	{{- if .Values.$1.service.annotations }}
	  annotations:
	{{ toYaml .Values.$1.service.annotations | indent 4 }}
	{{- end }}
	  labels:
	{{- if .Values.$1.service.labels }}
	{{ toYaml .Values.$1.service.labels | indent 4 }}
	{{- end }}
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		component: "{{ .Values.$1.name }}"
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
	  name: {{ template "$2.$1.fullname" . }}
	spec:
	  clusterIP: "{{ .Values.$1.service.clusterIP }}"
	{{- if .Values.$1.service.externalIPs }}
	  externalIPs:
	{{ toYaml .Values.$1.service.externalIPs | indent 4 }}
	{{- end }}
	{{- if .Values.$1.service.loadBalancerIP }}
	  loadBalancerIP: "{{ .Values.$1.service.loadBalancerIP }}"
	{{- end }}
	{{- if .Values.$1.service.loadBalancerSourceRanges }}
	  loadBalancerSourceRanges:
	{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}
	{{- end }}
	  healthCheckNodePort: {{ .Values.$1.service.healthCheckNodePort }}
	  ports:
		- name: http
		  port: 80
		  protocol: TCP
		  targetPort: {{ .Values.$1.service.targetPorts.http }}
		  {{- if (and (eq .Values.$1.service.type "NodePort") (not (empty .Values.$1.service.nodePorts.http))) }}
		  nodePort: {{ .Values.$1.service.nodePorts.http }}
		  {{- end }}
		- name: https
		  port: 443
		  protocol: TCP
		  targetPort: {{ .Values.$1.service.targetPorts.https }}
		  {{- if (and (eq .Values.$1.service.type "NodePort") (not (empty .Values.$1.service.nodePorts.https))) }}
		  nodePort: {{ .Values.$1.service.nodePorts.https }}
		  {{- end }}
	  {{- range $key, $value := .Values.tcp }}
		- name: "{{ $key }}-tcp"
		  port: {{ $key }}
		  protocol: TCP
		  targetPort: "{{ $key }}-tcp"
	  {{- end }}
	  {{- range $key, $value := .Values.udp }}
		- name: "{{ $key }}-udp"
		  port: {{ $key }}
		  protocol: UDP
		  targetPort: "{{ $key }}-udp"
	  {{- end }}
	  selector:
		app: {{ template "${2:chartName}.name" . }}
		component: "{{ .Values.$1.name }}"
		release: {{ .Release.Name }}
	  type: "{{ .Values.${1:value_key}.service.type }}"

snippet service_spec
	apiVersion: v1
	kind: Service
	metadata:
	{{- if .Values.$1.service.annotations }}
	  annotations:
	{{ toYaml .Values.$1.service.annotations | indent 4 }}
	{{- end }}
	  labels:
	{{- if .Values.$1.service.labels }}
	{{ toYaml .Values.$1.service.labels | indent 4 }}
	{{- end }}
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		component: "{{ .Values.$1.name }}"
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
	  name: {{ template "${2:chartName}.${1:value_key}.fullname" . }}
	# spec
	${0}

snippet annotations_spec
	{{- if .Values.$1.service.annotations }}
	  annotations:
	{{ toYaml .Values.${1:value_key}.service.annotations | indent 4 }}
	{{- end }}
	${0}

snippet labels_spec
	 labels:
	{{- if .Values.$1.service.labels }}
	{{ toYaml .Values.$1.service.labels | indent 4 }}
	{{- end }}
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		component: "{{ .Values.$1.name }}"
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
	  name: {{ template "${2:chartName}.${1:value_key}.fullname" . }}
	${0}

snippet service_spec
	spec:
	  type: "{{ .Values.$1.service.type }}"
	  clusterIP: "{{ .Values.$1.service.clusterIP }}"
	{{- if .Values.$1.service.externalIPs }}
	  externalIPs:
	{{ toYaml .Values.$1.service.externalIPs | indent 4 }}
	{{- end }}
	{{- if .Values.$1.service.loadBalancerIP }}
	  loadBalancerIP: "{{ .Values.$1.service.loadBalancerIP }}"
	{{- end }}
	{{- if .Values.$1.service.loadBalancerSourceRanges }}
	  loadBalancerSourceRanges:
	{{ toYaml .Values.$1.service.loadBalancerSourceRanges | indent 4 }}
	{{- end }}
	{{- if and (semverCompare ">=1.7-0" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.externalTrafficPolicy) }}
	  externalTrafficPolicy: "{{ .Values.$1.service.externalTrafficPolicy }}"
	{{- end }}
	{{- if and (semverCompare ">=1.7-0" .Capabilities.KubeVersion.GitVersion) (.Values.$1.service.healthCheckNodePort) }}
	  healthCheckNodePort: {{ .Values.${1:value_key}.service.healthCheckNodePort }}
	{{- end }}
	${0}

snippet ports_spec
	ports:
	${0}

snippet portHTTP_spec
	- name: http
	  port: 80
	  protocol: TCP
	  targetPort: {{ .Values.$1.service.targetPorts.http }}
	  {{- if (and (eq .Values.$1.service.type "NodePort") (not (empty .Values.$1.service.nodePorts.http))) }}
	  nodePort: {{ .Values.${1:value_key}.service.nodePorts.http }}
	  {{- end }}
	  ${0}

snippet portHTTPS_spec
	- name: https
	  port: 443
	  protocol: TCP
	  targetPort: {{ .Values.$1.service.targetPorts.https }}
	  {{- if (and (eq .Values.$1.service.type "NodePort") (not (empty .Values.$1.service.nodePorts.https))) }}
	  nodePort: {{ .Values.${1:value_key}.service.nodePorts.https }}
	  {{- end }}
	  ${0}

snippet portTCP_spec
	{{- range $key, $value := .Values.tcp }}
	  - name: "{{ $key }}-tcp"
		port: {{ $key }}
		protocol: TCP
		targetPort: "{{ $key }}-tcp"
	{{- end }}
	${0}

snippet portUDP_spec
	{{- range $key, $value := .Values.udp }}
	  - name: "{{ $key }}-udp"
		port: {{ $key }}
		protocol: UDP
		targetPort: "{{ $key }}-udp"
	{{- end }}
	${0}


snippet selector_spec
	selector:
	  app: {{ template "${2:chartName}.name" . }}
	  component: "{{ .Values.${1:value_key}.name }}"
	  release: {{ .Release.Name }}
	  ${0}


snippet deploy_sample_spec
	{{- if .Values.$1.enabled }}
	apiVersion: extensions/v1beta1
	kind: Deployment
	metadata:
	  labels:
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		component: "{{ .Values.$1.name }}"
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
	  name: {{ template "$2.$1.fullname" . }}
	spec:
	  replicas: {{ .Values.$1.replicaCount }}
	  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}
	  template:
		metadata:
		{{- if .Values.$1.podAnnotations }}
		  annotations:
	{{ toYaml .Values.$1.podAnnotations | indent 8 }}
		{{- end }}
		  labels:
			app: {{ template "$2.name" . }}
			component: "{{ .Values.$1.name }}"
			release: {{ .Release.Name }}
			{{- if .Values.$1.podLabels }}
	{{ toYaml .Values.$1.podLabels | indent 8 }}
			{{- end }}
		spec:
		  {{- if .Values.imagePullSecrets }}
		  imagePullSecrets:
	{{ toYaml .Values.imagePullSecrets | indent 8 }}
		  {{- end }}
		  containers:
			- name: {{ template "${2:chartName}.name" . }}-{{ .Values.$1.name }}
			  image: "{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}"
			  imagePullPolicy: "{{ .Values.$1.image.pullPolicy }}"
			  args:
			  {{- range $key, $value := .Values.$1.extraArgs }}
				{{- if $value }}
				- --{{ $key }}={{ $value }}
				{{- else }}
				- --{{ $key }}
				{{- end }}
			  {{- end }}
			  livenessProbe:
				httpGet:
				  path: /healthz
				  port: 8080
				  scheme: HTTP
				initialDelaySeconds: 30
				timeoutSeconds: 5
			  ports:
				- name: http
				  containerPort: 8080
				  protocol: TCP
			  resources:
	{{ toYaml .Values.$1.resources | indent 12 }}
		{{- if .Values.$1.nodeSelector }}
		  nodeSelector:
	{{ toYaml .Values.$1.nodeSelector | indent 8 }}
		{{- end }}
		{{- if .Values.$1.tolerations }}
		  tolerations:
	{{ toYaml .Values.$1.tolerations | indent 8 }}
		{{- end }}
		{{- if .Values.$1.affinity }}
		  affinity:
	{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}
		{{- end }}
		  terminationGracePeriodSeconds: 60
	{{- end }}



snippet deploy_spec
	{{- if .Values.$1.enabled }}
	apiVersion: extensions/v1beta1
	kind: Deployment
	metadata:
	  labels:
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		component: "{{ .Values.$1.name }}"
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
	  name: {{ template "${2:chartName}.${1:value_key}.fullname" . }}
	# spec
		# containers_spec
		# livenessProbe_spec
		# PersistentVolumeClaim_spec
		# initContainers_spec
		# resources_spec
		# nodeselector_spec
		# tolerations_spec
		# affinity_spec
	${0}

snippet spec_spec
	spec:
	  replicas: {{ .Values.$1.replicaCount }}
	  revisionHistoryLimit: {{ .Values.revisionHistoryLimit }}
	  template:
		metadata:
		{{- if .Values.$1.podAnnotations }}
		  annotations:
	{{ toYaml .Values.$1.podAnnotations | indent 8 }}
		{{- end }}
		  labels:
			app: {{ template "${2:chartName}.name" . }}
			component: "{{ .Values.$1.name }}"
			release: {{ .Release.Name }}
			{{- if .Values.$1.podLabels }}
	{{ toYaml .Values.${1:value_key}.podLabels | indent 8 }}
			{{- end }}
		spec:
		  {{- if .Values.imagePullSecrets }}
		  imagePullSecrets:
	{{ toYaml .Values.imagePullSecrets | indent 8 }}
		  {{- end }}
		  ${0}

snippet imagePullSecrets_spec
		  {{- if .Values.imagePullSecrets }}
		  imagePullSecrets:
	{{ toYaml .Values.imagePullSecrets | indent 8 }}
		  {{- end }}
	${0}

snippet imagePullPolicy_spec
	imagePullPolicy: ${1:imagePullPolicy}
	${0}

snippet containers_spec
	containers:
	  - name: {{ template "${2:chartName}.name" . }}-{{ .Values.$1.name }}
		image: "{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}"
		imagePullPolicy: "{{ .Values.${1:value_key}.image.pullPolicy }}"
	${0}
snippet args_spec
	args:
	{{- range $key, $value := .Values.${1:value_key}.extraArgs }}
	  {{- if $value }}
	  - --{{ $key }}={{ $value }}
	  {{- else }}
	  - --{{ $key }}
	  {{- end }}
	{{- end }}
	${0}
snippet livenessProbe_spec
	livenessProbe:
	  httpGet:
		path: /healthz
		port: 8080
		scheme: HTTP
	  initialDelaySeconds: 30
	  timeoutSeconds: 5
	${0}
snippet readinessProbe_spec
	readinessProbe:
	  httpGet:
		path: /go/api/v1/health
		port: 8153
	  initialDelaySeconds: {{ .Values.$1.healthCheck.initialDelaySeconds }}
	  periodSeconds: {{ .Values.$1.healthCheck.periodSeconds }}
	  failureThreshold: {{ .Values.$1.healthCheck.failureThreshold }}
	${0}
snippet resources_spec
	resources:
	{{ toYaml .Values.${1:value_key}.resources | indent 12 }}
	${0}
snippet nodeselector_spec
	{{- if .Values.$1.nodeSelector }}
	  nodeSelector:
	{{ toYaml .Values.${1:value_key}.nodeSelector | indent 8 }}
	{{- end }}
	${0}
snippet tolerations_spec
	{{- if .Values.$1.tolerations }}
	  tolerations:
	{{ toYaml .Values.${1:value_key}.tolerations | indent 8 }}
	{{- end }}
	${0}
snippet affinity_spec
	{{- if .Values.$1.affinity }}
	  affinity:
	{{ toYaml .Values.${1:value_key}.affinity | indent 8 }}
	{{- end }}
	  terminationGracePeriodSeconds: 60
	{{- end }}
	${0}

snippet PersistentVolumeClaim_spec
	kind: PersistentVolumeClaim
	apiVersion: v1
	metadata:
	  name: {{ template "${2}.$1.fullname" . }}
	  labels:
		app: {{ template "${2:chartName}.name" . }}
		chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
		release: "{{ .Release.Name }}"
		heritage: "{{ .Release.Service }}"
	spec:
	  accessModes:
		- {{ .Values.$1.persistence.accessMode | quote }}
	  resources:
		requests:
		  storage: {{ .Values.$1.persistence.size | quote }}
	{{- if .Values.$1.persistence.storageClass }}
	{{- if (eq "-" .Values.$1.persistence.storageClass) }}
	  storageClassName: ""
	{{- else }}
	  storageClassName: "{{ .Values.${1:value_key}.persistence.storageClass }}"
	{{- end }}
	{{- end }}
	{{- end }}
	{{- end }}
	${0}

snippet configMap_spec
	{{- if .Values.artifactory.enabled -}}
	  apiVersion: v1
	  kind: ConfigMap
	  metadata:
		name: {{ template "${2:chartName}.fullname" . }}-${1:value_key}-config
		labels:
		  app: {{ template "${2}.name" . }}
		  chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		  heritage: {{ .Release.Service }}
		  release: {{ .Release.Name }}
	  data:
		${3:nameOfConfigFile}.conf: |
		  # data goes here
	{{- end -}}
	${0}

snippet initContainers_spec
	{{- if .Values.$1.initContainers }}
		  initContainers:
		  - name: wait-workers
			image: "{{ .Values.$1.image.repository }}:{{ .Values.$1.image.tag }}"
			imagePullPolicy: {{ .Values.${1:value_key}.image.pullPolicy }}
			# env
			command:
			  - sh
			  - -c
			  - |
				until printf "." && nc -z -w 2 {{ template "${2:chartName}.fullname" . }} {{ .Values.postgresql.service.port }}; do
					sleep 2;
				done;

				echo 'PostgreSQL OK ✓'
			# args
	{{- end }}
	${0}

snippet pvc_spec
	kind: PersistentVolumeClaim
	apiVersion: v1
	metadata:
	  name: {{ template "$2.fullname" . }}
	  labels:
		chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
		release: "{{ .Release.Name }}"
		heritage: "{{ .Release.Service }}"
		app: {{ template "${2:chartName}.fullname" . }}
	spec:
	  accessModes:
		- {{ .Values.persistence.accessMode | quote }}
	  resources:
		requests:
		  storage: {{ .Values.persistence.size | quote }}
	{{- if .Values.persistence.storageClass }}
	{{- if (eq "-" .Values.persistence.storageClass) }}
	  storageClassName: ""
	{{- else }}
	  storageClassName: "{{ .Values.persistence.storageClass }}"
	{{- end }}
	{{- end }}
	{{- end }}
	${0}

snippet pv_nfs_spec
	apiVersion: v1
	kind: PersistentVolume
	metadata:
	  name: {{ template "$2.fullname" . }}-data-pv
	  labels:
		app: {{ template "$2.name" . }}
		chart: {{ .Chart.Name }}-{{ .Chart.Version }}
		heritage: {{ .Release.Service }}
		release: {{ .Release.Name }}
		id: {{ template "${2:chartName}.name" . }}-data-pv
		type: nfs-volume
	spec:
	  capacity:
		storage: {{ .Values.$1.persistence.nfs.capacity }}
	  accessModes:
	  - ReadWriteOnce
	  persistentVolumeReclaimPolicy: Retain
	  nfs:
		server: {{ .Values.$1.persistence.nfs.ip }}
		path: "{{ .Values.${1:value_key}.persistence.nfs.haDataMount }}"
		readOnly: false
	${0}

snippet pvc_hostpath_spec
	{{- if and .Values.persistence.enabled .Values.persistence.$1.hostPath (not
	.Values.persistence.$1.existingClaim) -}}
	apiVersion: v1
	kind: PersistentVolume
	metadata:
	  name: {{ template "${2:chartName}.fullname" . }}-$1
	spec:
	  accessModes:
		- {{ .Values.persistence.$1.accessMode | quote }}
	  capacity:
		storage: {{ .Values.persistence.$1.size | quote }}
	  hostPath:
		path: {{ .Values.persistence.${1:value_key}.hostPath | quote }}
	{{- end -}}
	${0}

snippet deploy_values
	$1:
	  name: ${1:value_key}
	  image:
		repository: 
		tag: 
		pullPolicy: IfNotPresent
	  hostNetwork: false
	  dnsPolicy: ClusterFirst
	  daemonset:
		useHostPort: false
	  podLabels: {}
	  scope:
		enabled: false
		namespace: ""   # defaults to .Release.Namespace
	  extraArgs: {}
	  extraEnvs: []
	  kind: Deployment
	  updateStrategy: {}
	  minReadySeconds: 0
	  tolerations: []
	  affinity: {}
	  nodeSelector: {}
	  podAnnotations: {}
	  replicaCount: 1
	  minAvailable: 1
	  resources: {}
	  autoscaling:
		enabled: false
	  extraContainers: {}
	  extraVolumeMounts: {}
	  extraVolumes: {}
	  extraInitContainers: []
	  lifecycle: {}
	revisionHistoryLimit: 10
	${0}

snippet rbac_values
	${1:value_key}:
	rbac:
	  create: true
	serviceAccount:
	  create: true
	  name:
	imagePullSecrets: []
	${0}

snippet service_values
	${1:value_key}:
	  service:
		annotations: {}
		labels: {}
		clusterIP: ""
		externalIPs: []
		loadBalancerIP: ""
		loadBalancerSourceRanges: []
		externalTrafficPolicy: ""
		healthCheckNodePort: 0
		targetPorts:
		  http: http
		  https: https
		type: LoadBalancer
		nodePorts:
		  http: ""
		  https: ""
	${0}

snippet readinessProbe_values
	${1:value_key}:
	  readinessProbe:
		failureThreshold: 3
		initialDelaySeconds: 10
		periodSeconds: 10
		successThreshold: 1
		timeoutSeconds: 1
		port: 10254
	${0}

snippet livenessProbe_values
	${1:value_key}:
	  livenessProbe:
		failureThreshold: 3
		initialDelaySeconds: 10
		periodSeconds: 10
		successThreshold: 1
		timeoutSeconds: 1
		port: 10254
	${0}
./snippets/html.snippets	[[[1
858
# Some useful Unicode entities
# Non-Breaking Space
snippet nbs
	&nbsp;
# ←
snippet left
	&#x2190;
# →
snippet right
	&#x2192;
# ↑
snippet up
	&#x2191;
# ↓
snippet down
	&#x2193;
# ↩
snippet return
	&#x21A9;
# ⇤
snippet backtab
	&#x21E4;
# ⇥
snippet tab
	&#x21E5;
# ⇧
snippet shift
	&#x21E7;
# ⌃
snippet ctrl
	&#x2303;
# ⌅
snippet enter
	&#x2305;
# ⌘
snippet cmd
	&#x2318;
# ⌥
snippet option
	&#x2325;
# ⌦
snippet delete
	&#x2326;
# ⌫
snippet backspace
	&#x232B;
# ⎋
snippet esc
	&#x238B;
# comment
snippet //
	<!-- ${1} -->${0}
# HTML Doctype 4.01 Strict
snippet docts
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	"http://www.w3.org/TR/html4/strict.dtd">
# HTML Doctype 4.01 Transitional
snippet doct
	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
# HTML Doctype 5
snippet doct5
	<!DOCTYPE HTML>
# XHTML Doctype 1.0 Frameset
snippet docxf
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
# XHTML Doctype 1.0 Strict
snippet docxs
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
# XHTML Doctype 1.0 Transitional
snippet docxt
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
# XHTML Doctype 1.1
snippet docx
	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
	"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
# Attributes
snippet attr
	${1:attribute}="${0:property}"
snippet attr+
	${1:attribute}="${2:property}" attr+
snippet .
	class="${1}"
snippet #
	id="${1}"
snippet alt
	alt="${1}"
snippet charset
	charset="${1:utf-8}"
snippet data
	data-${1}="${2:$1}"
snippet for
	for="${1}"
snippet height
	height="${1}"
snippet href
	href="${1:#}"
snippet lang
	lang="${1:en}"
snippet media
	media="${1}"
snippet name
	name="${1}"
snippet rel
	rel="${1}"
snippet scope
	scope="${1:row}"
snippet src
	src="${1}"
snippet title=
	title="${1}"
snippet type
	type="${1}"
snippet value
	value="${1}"
snippet width
	width="${1}"
# Elements
snippet a
	<a href="${1:#}">${0:$1}</a>
snippet a.
	<a class="${1}" href="${2:#}">${0:$1}</a>
snippet a#
	<a id="${1}" href="${2:#}">${0:$1}</a>
snippet a:ext
	<a href="http://${1:example.com}">${0:$1}</a>
snippet a:mail
	<a href="mailto:${1:joe@example.com}?subject=${2:feedback}">${0:email me}</a>
snippet ac
	<a href="`@+`">${0:`@+`}</a>
snippet abbr
	<abbr title="${1}">${0}</abbr>
snippet address
	<address>
		${0}
	</address>
snippet area
	<area shape="${1:rect}" coords="${2}" href="${3}" alt="${0}">
snippet area+
	<area shape="${1:rect}" coords="${2}" href="${3}" alt="${4}">
	area+
snippet area:c
	<area shape="circle" coords="${1}" href="${2}" alt="${0}">
snippet area:d
	<area shape="default" coords="${1}" href="${2}" alt="${0}">
snippet area:p
	<area shape="poly" coords="${1}" href="${2}" alt="${0}">
snippet area:r
	<area shape="rect" coords="${1}" href="${2}" alt="${0}">
snippet article
	<article>
		${0}
	</article>
snippet article.
	<article class="${1}">
		${0}
	</article>
snippet article#
	<article id="${1}">
		${0}
	</article>
snippet aside
	<aside>
		${0}
	</aside>
snippet aside.
	<aside class="${1}">
		${0}
	</aside>
snippet aside#
	<aside id="${1}">
		${0}
	</aside>
snippet audio
	<audio src="${1}">${0}</audio>
snippet b
	<b>${0}</b>
snippet base
	<base href="${1}" target="${0}">
snippet bdi
	<bdi>${0}</bdo>
snippet bdo
	<bdo dir="${1}">${0}</bdo>
snippet bdo:l
	<bdo dir="ltr">${0}</bdo>
snippet bdo:r
	<bdo dir="rtl">${0}</bdo>
snippet blockquote
	<blockquote>
		${0}
	</blockquote>
snippet body
	<body>
		${0}
	</body>
snippet br
	<br>
snippet button
	<button type="${1:submit}">${0}</button>
snippet button.
	<button class="${1:button}" type="${2:submit}">${0}</button>
snippet button#
	<button id="${1}" type="${2:submit}">${0}</button>
snippet button:s
	<button type="submit">${0}</button>
snippet button:r
	<button type="reset">${0}</button>
snippet canvas
	<canvas>
		${0}
	</canvas>
snippet caption
	<caption>${0}</caption>
snippet cite
	<cite>${0}</cite>
snippet code
	<code>${0}</code>
snippet col
	<col>
snippet colgroup
	<colgroup>
		${0}
	</colgroup>
snippet colgroup+
	<colgroup>
		<col>
		col+${0}
	</colgroup>
snippet command
	<command type="command" label="${1}" icon="${0}">
snippet command:c
	<command type="checkbox" label="${1}" icon="${0}">
snippet command:r
	<command type="radio" radiogroup="${1}" label="${2}" icon="${0}">
snippet datagrid
	<datagrid>
		${0}
	</datagrid>
snippet datalist
	<datalist>
		${0}
	</datalist>
snippet datatemplate
	<datatemplate>
		${0}
	</datatemplate>
snippet dd
	<dd>${0}</dd>
snippet dd.
	<dd class="${1}">${0}</dd>
snippet dd#
	<dd id="${1}">${0}</dd>
snippet del
	<del>${0}</del>
snippet details
	<details>${0}</details>
snippet dfn
	<dfn>${0}</dfn>
snippet dialog
	<dialog>
		${0}
	</dialog>
snippet div
	<div>
		${0}
	</div>
snippet div.
	<div class="${1}">
		${0}
	</div>
snippet div#
	<div id="${1}">
		${0}
	</div>
snippet dl
	<dl>
		${0}
	</dl>
snippet dl.
	<dl class="${1}">
		${0}
	</dl>
snippet dl#
	<dl id="${1}">
		${0}
	</dl>
snippet dl+
	<dl>
		<dt>${1}</dt>
		<dd>${2}</dd>
		dt+${0}
	</dl>
snippet dt
	<dt>${0}</dt>
snippet dt.
	<dt class="${1}">${0}</dt>
snippet dt#
	<dt id="${1}">${0}</dt>
snippet dt+
	<dt>${1}</dt>
	<dd>${2}</dd>
	dt+${0}
snippet em
	<em>${0}</em>
snippet embed
	<embed src="${1}" type="${0}">
snippet fieldset
	<fieldset>
		${0}
	</fieldset>
snippet fieldset.
	<fieldset class="${1}">
		${0}
	</fieldset>
snippet fieldset#
	<fieldset id="${1}">
		${0}
	</fieldset>
snippet fieldset+
	<fieldset>
		<legend><span>${1}</span></legend>
		${2}
	</fieldset>
	fieldset+${0}
snippet figcaption
	<figcaption>${0}</figcaption>
snippet figure
	<figure>${0}</figure>
snippet figure#
	<figure id="${1}">
		${0}
	</figure>
snippet figure.
	<figure class="${1}">
		${0}
	</figure>
snippet footer
	<footer>
		${0}
	</footer>
snippet footer.
	<footer class="${1}">
		${0}
	</footer>
snippet footer#
	<footer id="${1}">
		${0}
	</footer>
snippet form
	<form action="${1}" method="${2:post}">
		${0}
	</form>
snippet form.
	<form class="${1}" action="${2}" method="${3:post}">
		${0}
	</form>
snippet form#
	<form id="${1}" action="${2}" method="${3:post}">
		${0}
	</form>
snippet h1
	<h1>${0}</h1>
snippet h1.
	<h1 class="${1}">${0}</h1>
snippet h1#
	<h1 id="${1}">${0}</h1>
snippet h2
	<h2>${0}</h2>
snippet h2.
	<h2 class="${1}">${0}</h2>
snippet h2#
	<h2 id="${1}">${0}</h2>
snippet h3
	<h3>${0}</h3>
snippet h3.
	<h3 class="${1}">${0}</h3>
snippet h3#
	<h3 id="${1}">${0}</h3>
snippet h4
	<h4>${0}</h4>
snippet h4.
	<h4 class="${1}">${0}</h4>
snippet h4#
	<h4 id="${1}">${0}</h4>
snippet h5
	<h5>${0}</h5>
snippet h5.
	<h5 class="${1}">${0}</h5>
snippet h5#
	<h5 id="${1}">${0}</h5>
snippet h6
	<h6>${0}</h6>
snippet h6.
	<h6 class="${1}">${0}</h6>
snippet h6#
	<h6 id="${1}">${0}</h6>
snippet head
	<head>
		<meta charset="utf-8">

		<title>${1:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\u&', '')`}</title>
		${0}
	</head>
snippet header
	<header>
		${0}
	</header>
snippet header.
	<header class="${1}">
		${0}
	</header>
snippet header#
	<header id="${1}">
		${0}
	</header>
snippet hgroup
	<hgroup>
		${0}
	</hgroup>
snippet hgroup.
	<hgroup class="${1}>
		${0}
	</hgroup>
snippet hr
	<hr>
snippet html
	<html>
	${0}
	</html>
snippet xhtml
	<html xmlns="http://www.w3.org/1999/xhtml">
	${0}
	</html>
snippet html5
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width">
			<title>${1:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\u&', '')`}</title>
		</head>
		<body>
			$0
		</body>
	</html>
snippet html5l
	<!DOCTYPE html>
	<html lang="${1:en}">
		<head>
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width">
			<title>${2:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\u&', '')`}</title>
			${3:link}
		</head>
		<body>
			$0
		</body>
	</html>
snippet i
	<i>${0}</i>
snippet iframe
	<iframe src="${1}" frameborder="0"></iframe>
snippet iframe.
	<iframe class="${1}" src="${2}" frameborder="0"></iframe>
snippet iframe#
	<iframe id="${1}" src="${2}" frameborder="0"></iframe>
snippet img
	<img src="${1}" alt="${2}">
snippet img.
	<img class="${1}" src="${2}" alt="${3}">
snippet img#
	<img id="${1}" src="${2}" alt="${3}">
snippet input
	<input type="${1:text/submit/hidden/button/image}" name="${2}" id="${3:$2}" value="${4}">
snippet input.
	<input class="${1}" type="${2:text/submit/hidden/button/image}" name="${3}" id="${4:$3}" value="${5}">
snippet input:text
	<input type="text" name="${1}" id="${2:$1}" value="${3}">
snippet input:submit
	<input type="submit" name="${1}" id="${2:$1}" value="${3}">
snippet input:hidden
	<input type="hidden" name="${1}" id="${2:$1}" value="${3}">
snippet input:button
	<input type="button" name="${1}" id="${2:$1}" value="${3}">
snippet input:image
	<input type="image" name="${1}" id="${2:$1}" src="${3}" alt="${4}">
snippet input:checkbox
	<input type="checkbox" name="${1}" id="${2:$1}">
snippet input:radio
	<input type="radio" name="${1}" id="${2:$1}">
snippet input:color
	<input type="color" name="${1}" id="${2:$1}" value="${3}">
snippet input:date
	<input type="date" name="${1}" id="${2:$1}" value="${3}">
snippet input:datetime
	<input type="datetime" name="${1}" id="${2:$1}" value="${3}">
snippet input:datetime-local
	<input type="datetime-local" name="${1}" id="${2:$1}" value="${3}">
snippet input:email
	<input type="email" name="${1}" id="${2:$1}" value="${3}">
snippet input:file
	<input type="file" name="${1}" id="${2:$1}" value="${3}">
snippet input:month
	<input type="month" name="${1}" id="${2:$1}" value="${3}">
snippet input:number
	<input type="number" name="${1}" id="${2:$1}" value="${3}">
snippet input:password
	<input type="password" name="${1}" id="${2:$1}" value="${3}">
snippet input:range
	<input type="range" name="${1}" id="${2:$1}" value="${3}">
snippet input:reset
	<input type="reset" name="${1}" id="${2:$1}" value="${3}">
snippet input:search
	<input type="search" name="${1}" id="${2:$1}" value="${3}">
snippet input:time
	<input type="time" name="${1}" id="${2:$1}" value="${3}">
snippet input:url
	<input type="url" name="${1}" id="${2:$1}" value="${3}">
snippet input:week
	<input type="week" name="${1}" id="${2:$1}" value="${3}">
snippet ins
	<ins>${0}</ins>
snippet kbd
	<kbd>${0}</kbd>
snippet label
	<label for="${0:$1}">${1}</label>
snippet label:i
	<label for="${2:$1}">${1}</label>
	<input type="${3:text/submit/hidden/button}" name="${4:$2}" id="${5:$2}" value="${6}" />
snippet label:s
	<label for="${2:$1}">${1}</label>
	<select name="${3:$2}" id="${4:$2}">
		<option value="${5}">${0:$5}</option>
	</select>
snippet legend
	<legend>${0}</legend>
snippet legend+
	<legend><span>${0}</span></legend>
snippet li
	<li>${0}</li>
snippet li.
	<li class="${1}">${0}</li>
snippet li+
	<li>${1}</li>
	li+
snippet lia
	<li><a href="${0:#}">${1}</a></li>
snippet lia+
	<li><a href="${2:#}">${1}</a></li>
	lia+
snippet link
	<link rel="${1}" href="${2}" title="${3}" type="${4}">
snippet link:atom
	<link rel="alternate" href="${1:atom.xml}" title="Atom" type="application/atom+xml">
snippet link:s
	<link rel="stylesheet" href="${1:style.css}">
snippet link:css
	<link rel="stylesheet" href="${1:style.css}" type="text/css" media="${2:all}">
snippet link:favicon
	<link rel="shortcut icon" href="${1:favicon.ico}" type="image/x-icon">
snippet link:rss
	<link rel="alternate" href="${1:rss.xml}" title="RSS" type="application/atom+xml">
snippet link:touch
	<link rel="apple-touch-icon" href="${1:favicon.png}">
snippet main
	<main role="main">
		${0}
	</main>
snippet map
	<map name="${1}">
		${0}
	</map>
snippet map.
	<map class="${1}" name="${2}">
		${0}
	</map>
snippet map#
	<map name="${1}" id="${2:$1}>
		${0}
	</map>
snippet map+
	<map name="${1}">
		<area shape="${2}" coords="${3}" href="${4}" alt="${5}" />${6}
	</map>
snippet mark
	<mark>${0}</mark>
snippet menu
	<menu>
		${0}
	</menu>
snippet menu:c
	<menu type="context">
		${0}
	</menu>
snippet menu:t
	<menu type="toolbar">
		${0}
	</menu>
snippet meta
	<meta http-equiv="${1}" content="${2}">
snippet meta:s
	<meta ${0}>
snippet meta:d
	<meta name="description" content="${0}">
snippet meta:compat
	<meta http-equiv="X-UA-Compatible" content="IE=${1:7,8,edge}">
snippet meta:refresh
	<meta http-equiv="refresh" content="3;url=${0}">
snippet meta:utf5
	<meta charset="utf-8">
snippet meta:utf
	<meta http-equiv="content-type" content="text/html;charset=UTF-8">
snippet meter
	<meter>${0}</meter>
snippet nav
	<nav>
		${0}
	</nav>
snippet nav.
	<nav class="${1}">
		${0}
	</nav>
snippet nav#
	<nav id="${1}">
		${0}
	</nav>
snippet noscript
	<noscript>
		${0}
	</noscript>
snippet object
	<object data="${1}" type="${2}">
		${3}
	</object>
# Embed QT Movie
snippet movie
	<object width="$2" height="$3" classid="clsid:02BF25D5-8C17-4B23-BC80-D3488ABDDC6B"
	codebase="http://www.apple.com/qtactivex/qtplugin.cab">
		<param name="src" value="$1">
		<param name="controller" value="$4">
		<param name="autoplay" value="$5">
		<embed src="${1:movie.mov}"
			width="${2:320}" height="${3:240}"
			controller="${4:true}" autoplay="${5:true}"
			scale="tofit" cache="true"
			pluginspage="http://www.apple.com/quicktime/download/">
	</object>
snippet ol
	<ol>
		${0}
	</ol>
snippet ol.
	<ol class="${1}">
		${0}
	</ol>
snippet ol#
	<ol id="${1}">
		${0}
	</ol>
snippet ol+
	<ol>
		<li>${1}</li>
		li+${0}
	</ol>
snippet opt
	<option value="${1}">${0:$1}</option>
snippet opt+
	<option value="${1}">${2:$1}</option>
	opt+${0}
snippet optt
	<option>${0}</option>
snippet optgroup
	<optgroup>
		<option value="${1}">${2:$1}</option>
		opt+${0}
	</optgroup>
snippet output
	<output>${0}</output>
snippet p
	<p>${0}</p>
snippet p.
	<p class="${1}">${0}</p>
snippet p#
	<p id="${1}">${0}</p>
snippet param
	<param name="${1}" value="${2}">
snippet pre
	<pre>
		${0}
	</pre>
snippet progress
	<progress>${0}</progress>
snippet q
	<q>${0}</q>
snippet rp
	<rp>${0}</rp>
snippet rt
	<rt>${0}</rt>
snippet ruby
	<ruby>
		<rp><rt>${0}</rt></rp>
	</ruby>
snippet s
	<s>${0}</s>
snippet samp
	<samp>
		${0}
	</samp>
snippet script
	<script>
		${0}
	</script>
snippet scripts
	<script src="${0}.js"></script>
snippet scriptt
	<script type="${1}" id="${2}">
		${0}
	</script>
snippet scriptsrc
	<script src="${0}.js" charset="utf-8"></script>
snippet section
	<section>
		${0}
	</section>
snippet section.
	<section class="${1}">
		${0}
	</section>
snippet section#
	<section id="${1}">
		${0}
	</section>
snippet select
	<select name="${1}" id="${2:$1}">
		${0}
	</select>
snippet select.
	<select name="${1}" id="${2:$1}" class="${3}>
		${0}
	</select>
snippet select+
	<select name="${1}" id="${2:$1}">
		<option value="${3}">${4:$3}</option>
		opt+${0}
	</select>
snippet small
	<small>${0}</small>
snippet source
	<source src="${1}" type="${2}" media="${0}">
snippet span
	<span>${0}</span>
snippet span.
	<span class="${1}">${0}</span>
snippet span#
	<span id="${1}">${0}</span>
snippet strong
	<strong>${0}</strong>
snippet style
	<style type="text/css" media="${1:all}">
		${0}
	</style>
snippet sub
	<sub>${0}</sub>
snippet summary
	<summary>
		${0}
	</summary>
snippet sup
	<sup>${0}</sup>
snippet table
	<table>
		${0}
	</table>
snippet table.
	<table class="${1}">
		${0}
	</table>
snippet table#
	<table id="${1}">
		${0}
	</table>
snippet tbody
	<tbody>
		${0}
	</tbody>
snippet td
	<td>${0}</td>
snippet td.
	<td class="${1}">${0}</td>
snippet td#
	<td id="${1}">${0}</td>
snippet td+
	<td>${1}</td>
	td+${0}
snippet textarea
	<textarea name="${1}" id="${2:$1}" rows="${3:8}" cols="${4:40}">${5}</textarea>
snippet tfoot
	<tfoot>
		${0}
	</tfoot>
snippet th
	<th>${0}</th>
snippet th.
	<th class="${1}">${0}</th>
snippet th#
	<th id="${1}">${0}</th>
snippet th+
	<th>${1}</th>
	th+${0}
snippet thead
	<thead>
		${0}
	</thead>
snippet time
	<time datetime="${1}" pubdate="${2:$1}">${0:$1}</time>
snippet title
	<title>${0:`substitute(vim_snippets#Filename('', 'Page Title'), '^.', '\u&', '')`}</title>
snippet tr
	<tr>
		${0}
	</tr>
snippet tr+
	<tr>
		<td>${1}</td>
		td+${0}
	</tr>
snippet track
	<track src="${1}" srclang="${2}" label="${3}" default="${4:default}>${5}
snippet ul
	<ul>
		${0}
	</ul>
snippet ul.
	<ul class="${1}">
		${0}
	</ul>
snippet ul#
	<ul id="${1}">
		${0}
	</ul>
snippet ul+
	<ul>
		<li>${1}</li>
		li+${0}
	</ul>
snippet var
	<var>${0}</var>
snippet video
	<video src="${1}" height="${2}" width="${3}" preload="${4:none}" autoplay="${5:autoplay}">${6}</video>
snippet video.
	<video class="${1}" src="${2}" height="${3}" width="${4}" preload="${5:none}" autoplay="${6:autoplay}">${7}</video>
snippet wbr
	<wbr>
snippet viewport
	<meta name="viewport" content="width=device-width, initial-scale=1">
./snippets/htmldjango.snippets	[[[1
142
# Generic tags

extends html

snippet %
	{% ${1} %}
snippet %%
	{% ${1:tag_name} %}
	${0}
	{% end$1 %}
snippet {
	{{ ${1} }}
# Template Tags

snippet autoescape
	{% autoescape ${1:off} %}
		${0}
	{% endautoescape %}
snippet block
	{% block ${1} %}
		${0}
	{% endblock %}
snippet #
	{# ${0:comment} #}
snippet comment
	{% comment %}
		${0}
	{% endcomment %}
snippet cycle
	{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}
snippet debug
	{% debug %}
snippet extends
	{% extends "${0:base.html}" %}
snippet filter
	{% filter ${1} %}
		${0}
	{% endfilter %}
snippet firstof
	{% firstof ${1} %}
snippet for
	{% for ${1} in ${2} %}
		${0}
	{% endfor %}
snippet empty
	{% empty %}
	${0}
snippet if
	{% if ${1} %}
		${0}
	{% endif %}
snippet el
	{% else %}
		${1}
snippet eif
	{% elif ${1} %}
		${0}
snippet ifchanged
	{% ifchanged %}${1}{% endifchanged %}
snippet ifequal
	{% ifequal ${1} ${2} %}
		${0}
	{% endifequal %}
snippet ifnotequal
	{% ifnotequal ${1} ${2} %}
		${0}
	{% endifnotequal %}
snippet include
	{% include "${0}" %}
snippet load
	{% load ${0} %}
snippet now
	{% now "${0:jS F Y H:i}" %}
snippet regroup
	{% regroup ${1} by ${2} as ${0} %}
snippet spaceless
	{% spaceless %}${0}{% endspaceless %}
snippet ssi
	{% ssi ${0} %}
snippet trans
	{% trans "${0:string}" %}
snippet url
	{% url ${1} as ${0} %}
snippet widthratio
	{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}
snippet with
	{% with ${1} as ${2} %}
		${0}
	{% endwith %}

# Template Filters

# Note: Since SnipMate can't determine which template filter you are
# expanding without the "|" character, these do not add the "|"
# character.  These save a few keystrokes still.

# Note: Template tags that take no arguments are not implemented.

snippet add
	add:"${0}"
snippet center
	center:"${0}"
snippet cut
	cut:"${0}"
snippet date
	date:"${0}"
snippet default
	default:"${0}"
snippet defaultifnone
	default_if_none:"${0}"
snippet dictsort
	dictsort:"${0}"
snippet dictsortrev
	dictsortreversed:"${0}"
snippet divisibleby
	divisibleby:"${0}"
snippet floatformat
	floatformat:"${0}"
snippet getdigit
	get_digit:"${0}"
snippet join
	join:"${0}"
snippet lengthis
	length_is:"${0}"
snippet pluralize
	pluralize:"${0}"
snippet removetags
	removetags:"${0}"
snippet slice
	slice:"${0}"
snippet stringformat
	stringformat:"${0}"
snippet time
	time:"${0}"
snippet truncatewords
	truncatewords:${0}
snippet truncatewordshtml
	truncatewords_html:${0}
snippet urlizetrunc
	urlizetrunc:${0}
snippet wordwrap
	wordwrap:${0}
./snippets/htmltornado.snippets	[[[1
55
# Generic tags

snippet {
	{{ ${0} }}

# Template tags

snippet extends
	{% extends "${0:base.html}" %}
snippet autoescape
	{% autoescape ${0:xhtml_escape | None} %}
snippet apply
	{% apply ${1:function} %}
	  ${0}
	{% end %}
snippet block
	{% block ${1} %}
	  ${0}
	{% end %}
snippet for
	{% for ${1:item} in ${2} %}
	  ${0}
	{% end %}
snippet from
	{% from ${1:x} import ${0:y} %}
snippet if
	{% if $1 %}
	  ${0}
	{% end %}
snippet eif
	{% elif $0 %}
snippet el
	{% else %}
snippet import
	{% import ${0:module} %}
snippet include
	{% include "${0:filename}" %}
snippet module
	{% module ${0:expression} %}
snippet raw
	{% raw ${0:expression} %}
snippet set
	{% set ${1:x} = ${0:y} %}
snippet try
	{% try %}
	  ${1:${VISUAL}}
	{% except %}
	  ${2}
	{% finallly %}
	  ${0}
	{% end %}
snippet wh
	{% while $1 %}
	  ${0}
	{% end %}
./snippets/idris.snippets	[[[1
46
snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
	${0}
snippet imp
	import ${0:List}
snippet fn
	${1:fn} : ${2:a} -> ${3:a}
	$1 ${4} =
		${0}
snippet fn1
	${1:fn} : ${2:a} -> ${3:a}
	$1 ${4} =
		${0}
snippet fn2
	${1:fn} : ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5} =
		${0}
snippet fn3
	${1:fn} : ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6} =
		${0}
snippet fn0
	${1:fn} : ${2:a}
	$1 =
		${0}
snippet case
	case ${1} of
		${2} =>
			${0}
snippet let
	let
		${1} =
			${2}
	in
		${0}
snippet wh
	where
		${0}
snippet if
	if ${1} then
		${2:${VISUAL}}
	else
		${0}
	${0}
snippet \ "Lambda function (\x => ...)"
	(\\${1:_} => ${0})
./snippets/jade.snippets	[[[1
18
# Angular HTML
snippet rep
	div(ng-repeat='${1} in ${2}')

snippet repf
	div(ng-repeat='${1} in ${2}' | ${3})

snippet repi
	div(ng-repeat='${1} in ${2}' track by $index)

snippet hide
	div(ng-hide='${1}')

snippet show
	div(ng-show='${1}')

snippet if
	div(ng-if='${1}')
./snippets/java.snippets	[[[1
297
## Access Modifiers
snippet po
	protected ${0}
snippet pu
	public ${0}
snippet pr
	private ${0}
##
## Annotations
snippet before
	@Before
	static void ${1:intercept}(${2:args}) { ${0} }
snippet mm
	@ManyToMany
	${0}
snippet mo
	@ManyToOne
	${0}
snippet om
	@OneToMany${1:(cascade=CascadeType.ALL)}
	${0}
snippet oo
	@OneToOne
	${1}
##
## Basic Java packages and import
snippet im
	import ${0}
snippet j.b
	java.beans.
snippet j.i
	java.io.
snippet j.m
	java.math.
snippet j.n
	java.net.
snippet j.u
	java.util.
##
## Class
snippet cl
	class ${1:`vim_snippets#Filename("$1", "untitled")`} ${0}
snippet pcl
	public class ${1:`vim_snippets#Filename("$1", "untitled")`} ${0}
snippet in
	interface ${1:`vim_snippets#Filename("$1", "untitled")`} ${2:extends Parent}
snippet tc
	public class ${1:`vim_snippets#Filename("$1")`} extends ${0:TestCase}
##
## Class Enhancements
snippet ext
	extends ${0}
snippet imp
	implements ${0}
##
## Comments
snippet /*
	/*
	 * ${0}
	 */
##
## Constants
snippet co
	static public final ${1:String} ${2:var} = ${3};
snippet cos
	static public final String ${1:var} = "${2}";
##
## Control Statements
snippet case
	case ${1}:
		${0}
snippet def
	default:
		${0}
snippet el
	else
snippet eif
	else if (${1}) ${0}
snippet if
	if (${1}) ${0}
snippet sw
	switch (${1}) {
		${0}
	}
##
## Create a Method
snippet m
	${1:void} ${2:method}(${3}) ${4:throws }
##
## Create a Variable
snippet v
	${1:String} ${2:var}${3: = null}${4};
##
## Declaration for ArrayList
snippet d.al
	List<${1:Object}> ${2:list} = new ArrayList<$1>();${0}
## Declaration for HashMap
snippet d.hm
	Map<${1:Object}, ${2:Object}> ${3:map} = new HashMap<$1, $2>();${0}
## Declaration for HashSet
snippet d.hs
	Set<${1:Object}> ${2:set} = new HashSet<$1>();${0}
## Declaration for Stack
snippet d.st
	Stack<${1:Object}> ${2:stack} = new Stack<$1>();${0}
##
## Singleton Pattern
snippet singlet
	private static class Holder {
		private static final ${1:`vim_snippets#Filename("$1")`} INSTANCE = new $1();
	}

	private $1() { }

	public static $1 getInstance() {
		return Holder.INSTANCE;
	}
##
## Enhancements to Methods, variables, classes, etc.
snippet ab
	abstract ${0}
snippet fi
	final ${0}
snippet st
	static ${0}
snippet sy
	synchronized ${0}
##
## Error Methods
snippet err
	System.err.print("${0:Message}");
snippet errf
	System.err.printf("${1:Message}", ${0:exception});
snippet errln
	System.err.println("${0:Message}");
##
## Exception Handling
snippet as
	assert ${1:test} : "${2:Failure message}";
snippet ae
	assertEquals("${1:Failure message}", ${2:expected}, ${3:actual});
snippet aae
	assertArrayEquals("${1:Failure message}", ${2:expecteds}, ${3:actuals});
snippet af
	assertFalse("${1:Failure message}", $2);
snippet at
	assertTrue("${1:Failure message}", $2);
snippet an
	assertNull("${1:Failure message}", ${2:object});
snippet ann
	assertNotNull("${1:Failure message}", ${2:object});
snippet ass
	assertSame("${1:Failure message}", ${2:expected}, ${3:actual});
snippet asns
	assertNotSame("${1:Failure message}", ${2:expected}, ${3:actual});
snippet fa
	fail("${1:Failure message}");
snippet ca
	catch(${1:Exception} ${2:e}) ${0}
snippet thr
	throw ${0}
snippet ths
	throws ${0}
snippet try
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
	}
snippet tryf
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
##
## Find Methods
snippet findall
	List<${1:listName}> ${2:items} = $1.findAll();
snippet findbyid
	${1:var} ${2:item} = $1.findById(${3});
##
## Javadocs
snippet /**
	/**
	 * ${0}
	 */
snippet @au
	@author `system("grep \`id -un\` /etc/passwd | cut -d \":\" -f5 | cut -d \",\" -f1")`
snippet @br
	@brief ${0:Description}
snippet @fi
	@file ${0:`vim_snippets#Filename("$1")`}.java
snippet @pa
	@param ${0:param}
snippet @re
	@return ${0:param}
##
## Logger Methods
snippet debug
	Logger.debug(${1:param});
snippet error
	Logger.error(${1:param});
snippet info
	Logger.info(${1:param});
snippet warn
	Logger.warn(${1:param});
##
## Loops
snippet enfor
	for (${1} : ${2}) ${0}
snippet for
	for (${1}; ${2}; ${3}) ${0}
snippet wh
	while (${1:true}) ${0}
snippet wht
	while (true) ${0}
##
## Main method
snippet psvm
	public static void main (String[] args) {
		${0}
	}
snippet main
	public static void main (String[] args) {
		${0}
	}
##
## Print Methods
snippet sout
	System.out.println(${0});
snippet serr
	System.err.println(${0});
snippet print
	System.out.print("${0:Message}");
snippet printf
	System.out.printf("${1:Message}", ${0:args});
snippet println
	System.out.println(${0});
snippet printlna
	System.out.println(Arrays.toString(${0}));
##
## Render Methods
snippet ren
	render(${1:param});
snippet rena
	renderArgs.put("${1}", ${2});
snippet renb
	renderBinary(${1:param});
snippet renj
	renderJSON(${1:param});
snippet renx
	renderXml(${1:param});
##
## Setter and Getter Methods
snippet set
	${1:public} void set${3:}(${2:String} ${0:}){
		this.$4 = $4;
	}
snippet get
	${1:public} ${2:String} get${3:}(){
		return this.${0:};
	}
##
## Terminate Methods or Loops
snippet re
	return ${0}
snippet br
	break;
##
## Test Methods
snippet t
	public void test${1:Name}() throws Exception {
		${0}
	}
snippet test
	@Test
	public void test${1:Name}() throws Exception {
		${0}
	}
##
## Utils
snippet Sc
	Scanner
##
## Miscellaneous
snippet action
	public static void ${1:index}(${2:args}) { ${0} }
snippet rnf
	notFound(${1:param});
snippet rnfin
	notFoundIfNull(${1:param});
snippet rr
	redirect(${1:param});
snippet ru
	unauthorized(${1:param});
snippet unless
	(unless=${1:param});
./snippets/javascript/javascript-jquery.snippets	[[[1
589
snippet add
	${1:obj}.add('${2:selector expression}')
snippet addClass
	${1:obj}.addClass('${2:class name}')
snippet after
	${1:obj}.after('${2:Some text <b>and bold!</b>}')
snippet ajax
	$.ajax({
		url: '${1:mydomain.com/url}',
		type: '${2:POST}',
		dataType: '${3:xml/html/script/json}',
		data: $.param( $('${4:Element or Expression}') ),
		complete: function (jqXHR, textStatus) {
			${5:// callback}
		},
		success: function (data, textStatus, jqXHR) {
			${6:// success callback}
		},
		error: function (jqXHR, textStatus, errorThrown) {
			${0:// error callback}
		}
	});
snippet ajaxcomplete
	${1:obj}.ajaxComplete(function (${1:e}, xhr, settings) {
		${0:// callback}
	});
snippet ajaxerror
	${1:obj}.ajaxError(function (${1:e}, xhr, settings, thrownError) {
		${2:// error callback}
	});
	${0}
snippet ajaxget
	$.get('${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		function (data, textStatus, jqXHR) {
			${0:// success callback}
		}
	);
snippet ajaxpost
	$.post('${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		function (data, textStatus, jqXHR) {
			${0:// success callback}
		}
	);
snippet ajaxprefilter
	$.ajaxPrefilter(function (${1:options}, ${2:originalOptions}, jqXHR) {
		${0: // Modify options, control originalOptions, store jqXHR, etc}
	});
snippet ajaxsend
	${1:obj}.ajaxSend(function (${1:request, settings}) {
		${2:// error callback}
	});
	${0}
snippet ajaxsetup
	$.ajaxSetup({
		url: "${1:mydomain.com/url}",
		type: "${2:POST}",
		dataType: "${3:xml/html/script/json}",
		data: $.param( $("${4:Element or Expression}") ),
		complete: function (jqXHR, textStatus) {
			${5:// callback}
		},
		success: function (data, textStatus, jqXHR) {
			${6:// success callback}
		},
		error: function (jqXHR, textStatus, errorThrown) {
			${0:// error callback}
		}
	});
snippet ajaxstart
	$.ajaxStart(function () {
		${1:// handler for when an AJAX call is started and no other AJAX calls are in progress};
	});
	${0}
snippet ajaxstop
	$.ajaxStop(function () {
		${1:// handler for when all AJAX calls have been completed};
	});
	${0}
snippet ajaxsuccess
	$.ajaxSuccess(function (${1:e}, xhr, settings) {
		${2:// handler for when any AJAX call is successfully completed};
	});
	${0}
snippet andself
	${1:obj}.andSelf()
snippet animate
	${1:obj}.animate({${2:param1: value1, param2: value2}}, ${3:speed})
snippet append
	${1:obj}.append('${2:Some text <b>and bold!</b>}')
snippet appendTo
	${1:obj}.appendTo('${2:selector expression}')
snippet attr
	${1:obj}.attr('${2:attribute}', '${3:value}')
snippet attrm
	${1:obj}.attr({'${2:attr1}': '${3:value1}', '${4:attr2}': '${5:value2}'})
snippet before
	${1:obj}.before('${2:Some text <b>and bold!</b>}')
snippet bind
	${1:obj}.bind('${2:event name}', function (${3:e}) {
		${0:// event handler}
	});
snippet blur
	${1:obj}.blur(function (${2:e}) {
		${0:// event handler}
	});
snippet C
	$.Callbacks()
snippet Cadd
	${1:callbacks}.add(${2:callbacks})
snippet Cdis
	${1:callbacks}.disable()
snippet Cempty
	${1:callbacks}.empty()
snippet Cfire
	${1:callbacks}.fire(${2:args})
snippet Cfired
	${1:callbacks}.fired()
snippet Cfirew
	${1:callbacks}.fireWith(${2:this}, ${3:args})
snippet Chas
	${1:callbacks}.has(${2:callback})
snippet Clock
	${1:callbacks}.lock()
snippet Clocked
	${1:callbacks}.locked()
snippet Crem
	${1:callbacks}.remove(${2:callbacks})
snippet change
	${1:obj}.change(function (${2:e}) {
		${0:// event handler}
	});
snippet children
	${1:obj}.children('${2:selector expression}')
snippet clearq
	${1:obj}.clearQueue(${2:'queue name'})
snippet click
	${1:obj}.click(function (${2:e}) {
		${0:// event handler}
	});
snippet clone
	${1:obj}.clone()
snippet contains
	$.contains(${1:container}, ${0:contents});
snippet css
	${1:obj}.css('${2:attribute}', '${3:value}')
snippet csshooks
	$.cssHooks['${1:CSS prop}'] = {
		get: function (elem, computed, extra) {
			${2: // handle getting the CSS property}
		},
		set: function (elem, value) {
			${0: // handle setting the CSS value}
		}
	};
snippet cssm
	${1:obj}.css({${2:attribute1}: '${3:value1}', ${4:attribute2}: '${5:value2}'})
snippet D
	$.Deferred()
snippet Dalways
	${1:deferred}.always(${2:callbacks})
snippet Ddone
	${1:deferred}.done(${2:callbacks})
snippet Dfail
	${1:deferred}.fail(${2:callbacks})
snippet Disrej
	${1:deferred}.isRejected()
snippet Disres
	${1:deferred}.isResolved()
snippet Dnotify
	${1:deferred}.notify(${2:args})
snippet Dnotifyw
	${1:deferred}.notifyWith(${2:this}, ${3:args})
snippet Dpipe
	${1:deferred}.then(${2:doneFilter}, ${3:failFilter}, ${4:progressFilter})
snippet Dprog
	${1:deferred}.progress(${2:callbacks})
snippet Dprom
	${1:deferred}.promise(${2:target})
snippet Drej
	${1:deferred}.reject(${2:args})
snippet Drejw
	${1:deferred}.rejectWith(${2:this}, ${3:args})
snippet Dres
	${1:deferred}.resolve(${2:args})
snippet Dresw
	${1:deferred}.resolveWith(${2:this}, ${3:args})
snippet Dstate
	${1:deferred}.state()
snippet Dthen
	${1:deferred}.then(${2:doneCallbacks}, ${3:failCallbacks}, ${4:progressCallbacks})
snippet Dwhen
	$.when(${1:deferreds})
snippet data
	${1:obj}.data(${2:obj})
snippet dataa
	$.data('${1:selector expression}', '${2:key}'${3:, 'value'})
snippet dblclick
	${1:obj}.dblclick(function (${2:e}) {
		${0:// event handler}
	});
snippet delay
	${1:obj}.delay('${2:slow/400/fast}'${3:, 'queue name'})
snippet dele
	${1:obj}.delegate('${2:selector expression}', '${3:event name}', function (${4:e}) {
		${0:// event handler}
	});
snippet deq
	${1:obj}.dequeue(${2:'queue name'})
snippet deqq
	$.dequeue('${1:selector expression}'${2:, 'queue name'})
snippet detach
	${1:obj}.detach('${2:selector expression}')
snippet die
	${1:obj}.die(${2:event}, ${3:handler})
snippet each
	${1:obj}.each(function (index) {
		${0:this.innerHTML = this + " is the element, " + index + " is the position";}
	});
snippet el
	$('<${1}/>'${2:, {}})
snippet eltrim
	$.trim('${1:string}')
snippet empty
	${1:obj}.empty()
snippet end
	${1:obj}.end()
snippet eq
	${1:obj}.eq(${2:element index})
snippet error
	${1:obj}.error(function (${2:e}) {
		${0:// event handler}
	});
snippet eventsmap
	{
		:f${0}
	}
snippet extend
	$.extend(${1:true, }${2:target}, ${3:obj})
snippet fadein
	${1:obj}.fadeIn('${2:slow/400/fast}')
snippet fadeinc
	${1:obj}.fadeIn('slow/400/fast', function () {
		${0:// callback};
	});
snippet fadeout
	${1:obj}.fadeOut('${2:slow/400/fast}')
snippet fadeoutc
	${1:obj}.fadeOut('slow/400/fast', function () {
		${0:// callback};
	});
snippet fadeto
	${1:obj}.fadeTo('${2:slow/400/fast}', ${3:0.5})
snippet fadetoc
	${1:obj}.fadeTo('slow/400/fast', ${2:0.5}, function () {
		${0:// callback};
	});
snippet filter
	${1:obj}.filter('${2:selector expression}')
snippet filtert
	${1:obj}.filter(function (${2:index}) {
		${3}
	})
snippet find
	${1:obj}.find('${2:selector expression}')
snippet focus
	${1:obj}.focus(function (${2:e}) {
		${0:// event handler}
	});
snippet focusin
	${1:obj}.focusIn(function (${2:e}) {
		${0:// event handler}
	});
snippet focusout
	${1:obj}.focusOut(function (${2:e}) {
		${0:// event handler}
	});
snippet get
	${1:obj}.get(${2:element index})
snippet getjson
	$.getJSON('${1:mydomain.com/url}',
		${2:{ param1: value1 },}
		function (data, textStatus, jqXHR) {
			${0:// success callback}
		}
	);
snippet getscript
	$.getScript('${1:mydomain.com/url}', function (script, textStatus, jqXHR) {
		${0:// callback}
	});
snippet grep
	$.grep(${1:array}, function (item, index) {
		${2}
	}${0:, true});
snippet hasc
	${1:obj}.hasClass('${2:className}')
snippet hasd
	$.hasData('${0:selector expression}');
snippet height
	${1:obj}.height(${2:integer})
snippet hide
	${1:obj}.hide('${2:slow/400/fast}')
snippet hidec
	${1:obj}.hide('${2:slow/400/fast}', function () {
		${0:// callback}
	});
snippet hover
	${1:obj}.hover(function (${2:e}) {
		${3:// event handler}
	}, function ($2) {
		${4:// event handler}
	});
snippet html
	${1:obj}.html('${2:Some text <b>and bold!</b>}')
snippet inarr
	$.inArray(${1:value}, ${0:array});
snippet insa
	${1:obj}.insertAfter('${2:selector expression}')
snippet insb
	${1:obj}.insertBefore('${2:selector expression}')
snippet is
	${1:obj}.is('${2:selector expression}')
snippet isarr
	$.isArray(${1:obj})
snippet isempty
	$.isEmptyObject(${1:obj})
snippet isfunc
	$.isFunction(${1:obj})
snippet isnum
	$.isNumeric(${1:value})
snippet isobj
	$.isPlainObject(${1:obj})
snippet iswin
	$.isWindow(${1:obj})
snippet isxml
	$.isXMLDoc(${1:node})
snippet jj
	$('${1:selector}')
snippet kdown
	${1:obj}.keydown(function (${2:e}) {
		${0:// event handler}
	});
snippet kpress
	${1:obj}.keypress(function (${2:e}) {
		${0:// event handler}
	});
snippet kup
	${1:obj}.keyup(function (${2:e}) {
		${0:// event handler}
	});
snippet last
	${1:obj}.last('${1:selector expression}')
snippet live
	${1:obj}.live('${2:events}', function (${3:e}) {
		${0:// event handler}
	});
snippet load
	${1:obj}.load(function (${2:e}) {
		${0:// event handler}
	});
snippet loadf
	${1:obj}.load('${2:mydomain.com/url}',
		${2:{ param1: value1 },}
		function (responseText, textStatus, xhr) {
			${0:// success callback}
		}
	});
snippet makearray
	$.makeArray(${0:obj});
snippet map
	${1:obj}.map(function (${2:index}, ${3:element}) {
		${0:// callback}
	});
snippet mapp
	$.map(${1:arrayOrObject}, function (${2:value}, ${3:indexOrKey}) {
		${0:// callback}
	});
snippet merge
	$.merge(${1:target}, ${0:original});
snippet mdown
	${1:obj}.mousedown(function (${2:e}) {
		${0:// event handler}
	});
snippet menter
	${1:obj}.mouseenter(function (${2:e}) {
		${0:// event handler}
	});
snippet mleave
	${1:obj}.mouseleave(function (${2:e}) {
		${0:// event handler}
	});
snippet mmove
	${1:obj}.mousemove(function (${2:e}) {
		${0:// event handler}
	});
snippet mout
	${1:obj}.mouseout(function (${2:e}) {
		${0:// event handler}
	});
snippet mover
	${1:obj}.mouseover(function (${2:e}) {
		${0:// event handler}
	});
snippet mup
	${1:obj}.mouseup(function (${2:e}) {
		${0:// event handler}
	});
snippet next
	${1:obj}.next('${2:selector expression}')
snippet nexta
	${1:obj}.nextAll('${2:selector expression}')
snippet nextu
	${1:obj}.nextUntil('${2:selector expression}'${3:, 'filter expression'})
snippet not
	${1:obj}.not('${2:selector expression}')
snippet off
	${1:obj}.off('${2:events}', '${3:selector expression}'${4:, handler})
snippet offset
	${1:obj}.offset()
snippet offsetp
	${1:obj}.offsetParent()
snippet on
	${1:obj}.on('${2:events}', '${3:selector expression}', function (${4:e}) {
		${0:// event handler}
	});
snippet one
	${1:obj}.one('${2:event name}', function (${3:e}) {
		${0:// event handler}
	});
snippet outerh
	${1:obj}.outerHeight()
snippet outerw
	${1:obj}.outerWidth()
snippet param
	$.param(${1:obj})
snippet parent
	${1:obj}.parent('${2:selector expression}')
snippet parents
	${1:obj}.parents('${2:selector expression}')
snippet parentsu
	${1:obj}.parentsUntil('${2:selector expression}'${3:, 'filter expression'})
snippet parsejson
	$.parseJSON(${1:data})
snippet parsexml
	$.parseXML(${1:data})
snippet pos
	${1:obj}.position()
snippet prepend
	${1:obj}.prepend('${2:Some text <b>and bold!</b>}')
snippet prependto
	${1:obj}.prependTo('${2:selector expression}')
snippet prev
	${1:obj}.prev('${2:selector expression}')
snippet preva
	${1:obj}.prevAll('${2:selector expression}')
snippet prevu
	${1:obj}.prevUntil('${2:selector expression}'${3:, 'filter expression'})
snippet promise
	${1:obj}.promise(${2:'fx'}, ${3:target})
snippet prop
	${1:obj}.prop('${2:property name}')
snippet proxy
	$.proxy(${1:function}, ${2:this})
snippet pushstack
	${1:obj}.pushStack(${2:elements})
snippet queue
	${1:obj}.queue(${2:name}${3:, newQueue})
snippet queuee
	$.queue(${1:element}${2:, name}${3:, newQueue})
snippet ready
	$(function () {
		${0}
	});
snippet rem
	${1:obj}.remove()
snippet rema
	${1:obj}.removeAttr('${2:attribute name}')
snippet remc
	${1:obj}.removeClass('${2:class name}')
snippet remd
	${1:obj}.removeData('${2:key name}')
snippet remdd
	$.removeData(${1:element}${2:, 'key name}')
snippet remp
	${1:obj}.removeProp('${2:property name}')
snippet repa
	${1:obj}.replaceAll(${2:target})
snippet repw
	${1:obj}.replaceWith(${2:content})
snippet reset
	${1:obj}.reset(function (${2:e}) {
		${0:// event handler}
	});
snippet resize
	${1:obj}.resize(function (${2:e}) {
		${0:// event handler}
	});
snippet scroll
	${1:obj}.scroll(function (${2:e}) {
		${0:// event handler}
	});
snippet scrolll
	${1:obj}.scrollLeft(${2:value})
snippet scrollt
	${1:obj}.scrollTop(${2:value})
snippet sdown
	${1:obj}.slideDown('${2:slow/400/fast}')
snippet sdownc
	${1:obj}.slideDown('${2:slow/400/fast}', function () {
		${0:// callback};
	});
snippet select
	${1:obj}.select(function (${2:e}) {
		${0:// event handler}
	});
snippet serialize
	${1:obj}.serialize()
snippet serializea
	${1:obj}.serializeArray()
snippet show
	${1:obj}.show('${2:slow/400/fast}')
snippet showc
	${1:obj}.show('${2:slow/400/fast}', function () {
		${0:// callback}
	});
snippet sib
	${1:obj}.siblings('${2:selector expression}')
snippet size
	${1:obj}.size()
snippet slice
	${1:obj}.slice(${2:start}${3:, end})
snippet stoggle
	${1:obj}.slideToggle('${2:slow/400/fast}')
snippet stop
	${1:obj}.stop('${2:queue}', ${3:false}, ${4:false})
snippet submit
	${1:obj}.submit(function (${2:e}) {
		${0:// event handler}
	});
snippet sup
	${1:obj}.slideUp('${2:slow/400/fast}')
snippet supc
	${1:obj}.slideUp('${2:slow/400/fast}', function () {
		${0:// callback};
	});
snippet text
	${1:obj}.text(${2:'some text'})
snippet this
	$(this)
snippet toarr
	${0:obj}.toArray()
snippet tog
	${1:obj}.toggle(function (${2:e}) {
		${3:// event handler}
	}, function ($2) {
		${4:// event handler}
	});
	${0}
snippet togclass
	${1:obj}.toggleClass('${2:class name}')
snippet togsh
	${1:obj}.toggle('${2:slow/400/fast}')
snippet trig
	${1:obj}.trigger('${2:event name}')
snippet trigh
	${1:obj}.triggerHandler('${2:event name}')
snippet $trim
	$.trim(${1:str})
snippet $type
	$.type(${1:obj})
snippet unbind
	${1:obj}.unbind('${2:event name}')
snippet undele
	${1:obj}.undelegate(${2:selector expression}, ${3:event}, ${4:handler})
snippet uniq
	$.unique(${1:array})
snippet unload
	${1:obj}.unload(function (${2:e}) {
		${0:// event handler}
	});
snippet unwrap
	${1:obj}.unwrap()
snippet val
	${1:obj}.val('${2:text}')
snippet width
	${1:obj}.width(${2:integer})
snippet wrap
	${1:obj}.wrap('${2:&lt;div class="extra-wrapper"&gt;&lt;/div&gt;}')
./snippets/javascript/javascript-react.snippets	[[[1
190
# Import
snippet ir import React
	import React from 'react';

snippet irc import React and Component
	import React, { Component } from 'react';

snippet irh import React hooks
	import { use$1 } from 'react';

snippet ird import ReactDOM
	import ReactDOM from 'react-dom';

snippet irp import PropTypes
	import PropTypes from 'prop-types';

# Lifecycle Methods
snippet cdm componentDidMount
	componentDidMount() {
		${1}
	};

snippet cdup componentDidUpdate
	componentDidUpdate(prevProps, prevState) {
		${1}
	};

snippet cwm componentWillMount
	componentWillMount() {
		${1}
	};

snippet cwr componentWillReceiveProps
	componentWillReceiveProps(nextProps) {
		${1}
	};

snippet cwun componentWillUnmount
	componentWillUnmount() {
		${1}
	};

snippet cwu componentWillUpdate
	componentWillUpdate(nextProps, nextState) {
		${1}
	};

snippet scu shouldComponentUpdate
	shouldComponentUpdate(nextProps, nextState) {
		${1}
	}

# Props
snippet spt static propTypes
	static propTypes = {
		${1}: PropTypes.${2}
	};

snippet pt propTypes
	${1}.propTypes = {
		${2}: PropTypes.${2}
	};

snippet sdp static defaultProps
	static defaultProps = {
		${1}: ${2}	
	};

snippet dp defaultProps
	${1}.defaultProps = {
		${2}: ${3}
	};

snippet pp props
	props.${1};

snippet tp this props
	this.props.${1};

# State
snippet st
	state = {
		${1}: ${2},
	};

snippet sst
	this.setState({
		${1}: ${2}
	});

snippet tst 
	this.state.${1};

# Component
snippet raf
	const ${1:ComponentName} = (${2:props}) => {
		${3:state}

		return (
			<>
				${4}
			</>
		);
	};

snippet rcla
	class ${1:ClassName} extends Component {
		render() {
			return (
				<>
					${2}
				</>
			);
		}
	}

snippet ercla
	export default class ${1:ClassName} extends Component {
		render() {
			return (
				<>
					${2}
				</>
			);
		};
	};

snippet ctor
	constructor() {
		super();

		${1:state}
	}

snippet ren
	render() {
		return (
			<>
				${2}
			</>
		);
	}

snippet fup
	forceUpdate(${1:callback});

# Hooks
snippet uses useState
	const [${1:state}, set${2}] = useState(${3:initialState});

snippet usee useEffect
	useEffect(() => {
		${1}
	});

snippet userd useReducer
	const [${1:state}, ${2:dispatch}] = useReducer(${3:reducer});

snippet userf useRef
	const ${1:refContainer} = useRef(${2:initialValue});

snippet usect useContext
	const ${1:value} = useContext(${2:MyContext});

snippet usecb useCallback
	const ${1:memoizedCallback} = useCallback(
	() => {
		${2}(${3})
	},
	[$3]
	);

snippet usem useMemo
	const ${1:memoizedCallback} = useMemo(() => ${2}(${3}), [$3]);

snippet usei useImperativeHandle
	useImperativeHandle(${1:ref}, ${2:createHandle});

snippet used useDebugValue
	useDebugValue(${1:value});

# ReactDOM methods
snippet rdr ReactDOM.render
	ReactDOM.render(${1}, ${2});

snippet rdh ReactDOM.hydrate
	ReactDOM.hydrate(${1:element}, ${2:container}[, ${3:callback}]);

snippet rdcp ReactDOM.createPortal
	ReactDOM.createPortal(${1:child}, ${2:container});
./snippets/javascript/javascript-redux.snippets	[[[1
37
snippet ist
	import { createStore } from 'redux';
snippet con
	connect(${1:mapStateToProps}, ${2:mapDispatchToProps})(<${3:VISUAL}/>);
snippet act
	const ${1:actionName} = (${2:arg}) => {
		return {
			type: ${3:VISUAL},
			$2
		};
	};
snippet rdc
	const ${1:reducerName} = (state={}, action) => {
		switch(action.type) {
			case ${1:action}:
				return {
					...state,
					$2
				};
			default:
				return state;
		};
	};
snippet mstp
	const mapStateToProps = (state) => {
		return {
			${1:propName}: state.$1,
		};
	};
snippet mdtp
	const mapDispatchToProps = (dispatch) => {
		return {
			${1:propName}: () => {
				dispatch(${2:actionName}());
			},
		};
	};
./snippets/javascript/javascript-requirejs.snippets	[[[1
14
snippet def
	define(["${1:#dependencies1}"], function (${2:#dependencies2}) {
		return ${0:TARGET};
	});

snippet defn
	define("${1:#name}", ["${2:#dependencies1}"], function (${3:#dependencies2}) {
		return ${0:TARGET};
	});

snippet reqjs
	require(["${1:#dependencies1}"], function (${2:#dependencies2}) {
		return ${0:TARGET};
	});
./snippets/javascript/javascript.node.snippets	[[[1
51
snippet #!
	#!/usr/bin/env node
# module exports
snippet ex
	module.exports = ${1};
# require
snippet re
	const ${1} = require('${2:module_name}');
# EventEmitter
snippet on
	on('${1:event_name}', function(${2:stream}) {
	  ${3}
	});
snippet emit
	emit('${1:event_name}', ${2:args});
snippet once
	once('${1:event_name}', function(${2:stream}) {
	  ${3}
	});
# http. User js function snippet as handler
snippet http
	http.createServer(${1:handler}).listen(${2:port_number});
# net 
snippet net
	net.createServer(function(${1:socket}){
		${1}.on('data', function('data'){
		  ${2}
		]});
		${1}.on('end', function(){
		  ${3}
		});
	}).listen(${4:8124});
# Stream snippets
snippet pipe
	pipe(${1:stream})${2}
# Express snippets
snippet eget
	${1:app}.get('${2:route}', ${3:handler});
snippet epost
	${1:app}.post('${2:route}', ${3:handler});
snippet eput
	${1:app}.put('${2:route}', ${3:handler});
snippet edel
	${1:app}.delete('${2:route}', ${3:handler});
# process snippets
snippet stdin
	process.stdin
snippet stdout
	process.stdout
snippet stderr
	process.stderr
./snippets/javascript/javascript.snippets	[[[1
363
# Functions
# prototype
snippet proto
	${1:class_name}.prototype.${2:method_name} = function(${3}) {
		${0:${VISUAL}}
	};
# Function
snippet fun "function"
	function ${1:function_name}(${2}) {
		${0:${VISUAL}}
	}
# Asynchronous Function
snippet asf "async function"
	async function ${1:function_name}(${2}) {
		${0:${VISUAL}}
	}
# Anonymous Function
snippet anf "" w
	function(${1}) {
		${0:${VISUAL}}
	}
# Anonymous Function assigned to variable
snippet vaf
	var ${1:function_name} = function(${2}) {
		${0:${VISUAL}}
	};
# Function assigned to variable
snippet vf
	var ${1:function_name} = function $1(${2}) {
		${0:${VISUAL}}
	};
# Immediate function
snippet (f
	(function(${1}) {
		${0:${VISUAL}}
	}(${2}));
# Minify safe iife
snippet ;fe
	;(function(${1}) {
		${0:${VISUAL}}
	}(${2}))
# self-defining function
snippet sdf
	var ${1:function_name} = function (${2:argument}) {
		${3}

		$1 = function ($2) {
			${0:${VISUAL}}
		};
	};
# Flow control
# if
snippet if "if (condition) { ... }"
	if (${1:true}) {
		${0:${VISUAL}}
	}
# if ... else
snippet ife "if (condition) { ... } else { ... }"
	if (${1:true}) {
		${0:${VISUAL}}
	} else {
		${2}
	}
# tertiary conditional
snippet ter Ternary: `condition ? true : false`
	$1 ? $2: $0
# switch
snippet switch
	switch (${1:expression}) {
		case '${3:case}':
			${4}
			break;
		${0}
		default:
			${2}
	}
snippet case "case 'xyz': ... break"
	case '${1:case}':
		${0:${VISUAL}}
		break;
snippet try "try { ... } catch(e) { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:e}) {
		${2:/* handle error */}
	}
snippet tryf "try { ... } catch(e) { ... } finally { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:e}) {
		${2:/* handle error */}
	} finally {
		${3:/* be executed regardless of the try / catch result*/}
	}
# throw Error
snippet terr
	throw new Error('${1:error message}')
# return
snippet ret
	return ${0:result};
snippet for "for (...) {...}"
	for (let ${1:i} = 0, ${2:len} = ${3:Things.length}; $1 < $2; $1++) {
		${0:${VISUAL}}
	}
snippet forr "reversed for (...) {...}"
	for (let ${2:i} = ${1:Things.length} - 1; $2 >= 0; $2--) {
		${0:${VISUAL}}
	}
snippet wh "(condition) { ... }"
	while (${1:true}) {
		${0:${VISUAL}}
	}
snippet wht "(true) { ... }"
	while (true) {
		${0:${VISUAL}}
	}
snippet do "do { ... } while (condition)"
	do {
		${0:${VISUAL}}
	} while ($1);
# For in loop
snippet fori
	for (let ${1:prop} in ${2:object}) {
		${0:$2[$1]}
	}
# Objects
# Object Method
snippet :f
	${1:method_name}: function (${2:attribute}) {
		${0:${VISUAL}}
	},
# hasOwnProperty
snippet has
	hasOwnProperty(${0})
# singleton
snippet sing
	function ${1:Singleton} (${2:argument}) {
		// the cached instance
		var instance;

		// rewrite the constructor
		$1 = function $1($2) {
			return instance;
		};

		// carry over the prototype properties
		$1.prototype = this;

		// the instance
		instance = new $1();

		// reset the constructor pointer
		instance.constructor = $1;

		${0}

		return instance;
	}
# Crockford's object function
snippet obj
	function object(o) {
		function F() {}
		F.prototype = o;
		return new F();
	}
# Define multiple properties
snippet props
	var ${1:my_object} = Object.defineProperties(
		${2:new Object()},
		{
			${3:property} : {
				get : function $1_$3_getter() {
					// getter code
				},
				set : function $1_$3_setter(value) {
					// setter code
				},
				value        : ${4:value},
				writeable    : ${5:boolean},
				enumerable   : ${6:boolean},
				configurable : ${0:boolean}
			}
		}
	);
# Define single property
snippet prop
	Object.defineProperty(
		${1:object},
		'${2:property}',
		{
			get : function $1_$2_getter() {
				// getter code
			},
			set : function $1_$2_setter(value) {
				// setter code
			},
			value        : ${3:value},
			writeable    : ${4:boolean},
			enumerable   : ${5:boolean},
			configurable : ${0:boolean}
		}
	);
# Documentation
# docstring
snippet /**
	/**
	 * ${0:description}
	 *
	 */
snippet @par
	@param {${1:type}} ${2:name} ${0:description}
snippet @ret
	@return {${1:type}} ${0:description}
# JSON.parse
snippet jsonp
	JSON.parse(${0:jstr});
# JSON.stringify
snippet jsons
	JSON.stringify(${0:object});
# DOM selectors
# Get elements
snippet get
	getElementsBy${1:TagName}('${0}')
# Get element
snippet gett
	getElementBy${1:Id}('${0}')
# Elements by class
snippet by.
	${1:document}.getElementsByClassName('${0:class}')
# Element by ID
snippet by#
	${1:document}.getElementById('${0:element ID}')
# Query selector
snippet qs
	${1:document}.querySelector('${0:CSS selector}')
# Query selector all
snippet qsa
	${1:document}.querySelectorAll('${0:CSS selector}')
# Debugging
snippet de
	debugger;
snippet cl "console.log"
	console.log(${0});
snippet cd "console.debug"
	console.debug(${0});
snippet ce "console.error"
	console.error(${0});
snippet cw "console.warn"
	console.warn(${0});
snippet ci "console.info"
	console.info(${0});
snippet ct "console.trace"
	console.trace(${0:label});
snippet ctime "console.time ... console.timeEnd"
	console.time("${1:label}");
	${0:${VISUAL}}
	console.timeEnd("$1");
snippet ctimestamp "console.timeStamp"
	console.timeStamp("${1:label}");
snippet ca "console.assert"
	console.assert(${1:expression}, ${0:obj});
snippet cclear "console.clear"
	console.clear();
snippet cdir "console.dir"
	console.dir(${0:obj});
snippet cdirx "console.dirxml"
	console.dirxml(${1:object});
snippet cgroup "console.group"
	console.group("${1:label}");
	${0:${VISUAL}}
	console.groupEnd();
snippet cgroupc "console.groupCollapsed"
	console.groupCollapsed("${1:label}");
	${0:${VISUAL}}
	console.groupEnd();
snippet cprof "console.profile"
	console.profile("${1:label}");
	${0:${VISUAL}}
	console.profileEnd();
snippet ctable "console.table"
	console.table(${1:"${2:value}"});
snippet clstr "console.log stringified"
	console.log(JSON.stringify(${0}, null, 2));
# Misc
snippet us
	'use strict';
# setTimeout function
snippet timeout
	setTimeout(function () {${0}}${2}, ${1:10});
snippet const
	const ${1} = ${0};
snippet constn
	const ${1} = new ${0};
snippet let
	let ${1} = ${0};
snippet im "import xyz from 'xyz'"
	import ${1} from '${2:$1}';
snippet imas "import * as xyz from 'xyz'"
	import * as ${1} from '${2:$1}';
snippet imm "import { member } from 'xyz'"
	import { ${1} } from '${2}';
snippet cla
	class ${1} {
		${0:${VISUAL}}
	}
snippet clax
	class ${1} extends ${2} {
		${0:${VISUAL}}
	}
snippet clac
	class ${1} {
		constructor(${2}) {
			${0:${VISUAL}}
		}
	}
snippet foro "for (const prop of object}) { ... }"
	for (const ${1:prop} of ${2:object}) {
		${0:$1}
	}
snippet forl "for (let prop of object}) { ... }"
	for (let ${1:prop} of ${2:object}) {
		${0:$1}
	}
snippet fun*
	function* ${1:function_name}(${2}) {
		${0:${VISUAL}}
	}
snippet c=>
	const ${1:function_name} = (${2}) => {
		${0:${VISUAL}}
	}
snippet ca=>
	const ${1:function_name} = async (${2}) => {
		${0:${VISUAL}}
	}
snippet caf
	const ${1:function_name} = (${2}) => {
		${0:${VISUAL}}
	}
snippet casf
	const ${1:function_name} = async (${2}) => {
		${0:${VISUAL}}
	}
snippet =>
	(${1}) => {
		${0:${VISUAL}}
	}
snippet af "() =>"
	(${1}) => ${0:${VISUAL}}
snippet afb "() => {}"
	(${1}) => {
		${0:${VISUAL}}
	}
snippet sym
	const ${1} = Symbol('${0}');
snippet ed
	export default ${0}
snippet ${
	\${${1}}${0}
snippet as "async"
	async ${0}
snippet aw "await"
	await ${0:${VISUAL}}
./snippets/javascript-bemjson.snippets	[[[1
52
# Snippet for bemjson. https://en.bem.info/platform/bemjson/

# Blocks
snippet b
	{
		block : '${1:name}',
		content : [
			'${2:content}'
		]
	}

# btc - BEM block with text content
snippet btc
	{
		 block : '${1:name}',
		 content: '${2:content}'
	}

# bwm - BEM block with modifier.
snippet bwm
	{
		block : '${1:name}',
		mods: { ${2:modName}: '${3:modVal}' },
		content : [
			'${4:content}'
		]
	}

# Elems

# e - BEM elem
snippet e
	{
		elem : '${1:name}',
		content : [
			'${2:content}'
		]
	}


# mo - Mods
snippet mo
	mods : { ${1:modName} : '${2:modVal}' },

# mi - BEM mix mod
snippet mi
	mix : [ { ${1:block} : '${2:block}' } ],

# a - BEM attrs mod
snippet a
	attrs : { ${1:attr} : '${2:val}' },

./snippets/javascript-d3.snippets	[[[1
30
snippet .attr
	.attr("${1}", ${2})
snippet .style
	.style("${1}", ${2})
snippet axis
	d3.svg.axis()
	  .orient(${1})
	  .scale(${2})
snippet fd
	function(d) { ${1} }
snippet fdi
	function(d, i) { ${1} }
snippet marginconvention
	var ${1:margin} = { top: ${2:10}, right: ${3:10}, bottom: ${4:10}, left: ${5:10} };
	var ${6:width} = ${7:970} - $1.left - $1.right;
	var ${8:height} = ${9:500} - $1.top - $1.bottom;
	
	var ${10:svg} = d3.select("${11}").append("svg")
	  .attr("width", $6 + $1.left + $1.right)
	  .attr("height", $8 + $1.top + $1.bottom)
	    .append("g")
	  .attr("transform", "translate(" + $1.left + "," + $1.top + ")")
snippet nest
	d3.nest()
	  .key(${1})
	  .entries(${2})
snippet scale
	d3.scale.linear()
	  .domain(${1})
	  .range(${2})
./snippets/javascript-jasmine.snippets	[[[1
175
snippet des "Describe (js)"
	describe('${1:description}', function() {
		$0
	});

snippet it "it (js)"
	it('${1:description}', function() {
		$0
	});

snippet bef "before each (js)"
	beforeEach(function() {
		$0
	});

snippet aft "after each (js)"
	afterEach(function() {
		$0
	});

snippet befa "before all (js)"
	beforeAll(function() {
		$0
	});

snippet afta "after all (js)"
	afterAll(function() {
		$0
	});

snippet any "any (js)"
	jasmine.any($1)

snippet anyt "anything (js)"
	jasmine.anything()

snippet objc "object containing (js)"
	jasmine.objectContaining({
		${VISUAL}$0
	});

snippet arrc "array containing (js)"
	jasmine.arrayContaining([${1:value1}]);

snippet strm "string matching (js)"
	jasmine.stringMatching("${1:matcher}")

snippet ru "runs (js)"
	runs(function() {
		$0
	});

snippet wa "waits (js)"
	waits($1);

snippet ex "expect (js)"
	expect(${1:target})$0;

snippet ee "expect to equal (js)"
	expect(${1:target}).toEqual(${2:value});

snippet el "expect to be less than (js)"
	expect(${1:target}).toBeLessThan(${2:value});

snippet eg "expect to be greater than (js)"
	expect(${1:target}).toBeGreaterThan(${2:value});

snippet eb "expect to be (js)"
	expect(${1:target}).toBe(${2:value});

snippet em "expect to match (js)"
	expect(${1:target}).toMatch(${2:pattern});

snippet eha "expect to have attribute (js)"
	expect(${1:target}).toHaveAttr('${2:attr}'${3:, '${4:value}'});

snippet et "expect to be truthy (js)"
	expect(${1:target}).toBeTruthy();

snippet ef "expect to be falsy (js)"
	expect(${1:target}).toBeFalsy();

snippet etbd "expect to be defined (js)"
	expect(${1:target}).toBeDefined();

snippet eud "expect to be defined (js)"
	expect(${1:target}).toBeUndefined();

snippet en "expect to be null (js)"
	expect(${1:target}).toBeNull();

snippet ec "expect to contain (js)"
	expect(${1:target}).toContain(${2:value});

snippet ev "expect to be visible (js)"
	expect(${1:target}).toBeVisible();

snippet eh "expect to be hidden (js)"
	expect(${1:target}).toBeHidden();

snippet eth "expect to throw (js)"
	expect(${1:target}).toThrow(${2:value});

snippet ethe "expect to throw error (js)"
	expect(${1:target}).toThrowError(${2:value});

snippet notx "expect not (js)"
	expect(${1:target}).not$0;

snippet note "expect not to equal (js)"
	expect(${1:target}).not.toEqual(${2:value});

snippet notl "expect to not be less than (js)"
	expect(${1:target}).not.toBeLessThan(${2:value});

snippet notg "expect to not be greater than (js)"
	expect(${1:target}).not.toBeGreaterThan(${2:value});

snippet notm "expect not to match (js)"
	expect(${1:target}).not.toMatch(${2:pattern});

snippet notha "expect to not have attribute (js)"
	expect(${1:target}).not.toHaveAttr('${2:attr}'${3:, '${4:value}'});

snippet nott "expect not to be truthy (js)"
	expect(${1:target}).not.toBeTruthy();

snippet notf "expect not to be falsy (js)"
	expect(${1:target}).not.toBeFalsy();

snippet notd "expect not to be defined (js)"
	expect(${1:target}).not.toBeDefined();

snippet notn "expect not to be null (js)"
	expect(${1:target}).not.toBeNull();

snippet notc "expect not to contain (js)"
	expect(${1:target}).not.toContain(${2:value});

snippet notv "expect not to be visible (js)"
	expect(${1:target}).not.toBeVisible();

snippet noth "expect not to be hidden (js)"
	expect(${1:target}).not.toBeHidden();

snippet notth "expect not to throw (js)"
	expect(${1:target}).not.toThrow(${2:value});

snippet notthe "expect not to throw error (js)"
	expect(${1:target}).not.toThrowError(${2:value});

snippet s "spy on (js)"
	spyOn(${1:object}, '${2:method}')$0;

snippet sr "spy on and return (js)"
	spyOn(${1:object}, '${2:method}').and.returnValue(${3:arguments});

snippet st "spy on and throw (js)"
	spyOn(${1:object}, '${2:method}').and.throwError(${3:exception});

snippet sct "spy on and call through (js)"
	spyOn(${1:object}, '${2:method}').and.callThrough();

snippet scf "spy on and call fake (js)"
	spyOn(${1:object}, '${2:method}').and.callFake(${3:function});

snippet ethbc "expect to have been called (js)"
	expect(${1:target}).toHaveBeenCalled();

snippet nthbc "expect not to have been called (js)"
	expect(${1:target}).not.toHaveBeenCalled();

snippet ethbcw "expect to have been called with (js)"
	expect(${1:target}).toHaveBeenCalledWith(${2:arguments});

./snippets/javascript-mocha.snippets	[[[1
34
snippet des "describe('thing', function() { ... })" b
	describe('${1:}', function() {
		${0:${VISUAL}}
	});
snippet it "it('should do', function() { ... })" b
	it('${1:}', function() {
		${0:${VISUAL}}
	});
snippet xit "xit('should do', function() { ... })" b
	xit('${1:}', function() {
		${0:${VISUAL}}
	});
snippet bef "before(function() { ... })" b
	before(function() {
		${0:${VISUAL}}
	});
snippet befe "beforeEach(function() { ... })" b
	beforeEach(function() {
		${0:${VISUAL}}
	});
snippet aft "after(function() { ... })" b
	after(function() {
		${0:${VISUAL}}
	});
snippet afte "afterEach(function() { ... })" b
	afterEach(function() {
		${0:${VISUAL}}
	});
snippet exp "expect(...)" b
	expect(${1:})${0};
snippet expe "expect(...).to.equal(...)" b
	expect(${1:}).to.equal(${0});
snippet expd "expect(...).to.deep.equal(...)" b
	expect(${1:}).to.deep.equal(${0});
./snippets/javascript-openui5.snippets	[[[1
205
snippet sapmlabel
	var $1 = new sap.m.Label({
				design : $2,
				text : $3,
				visible : $4,
				textAlign : $5,
				textDirection : $6,
				width : $7,
				required : $7
			});

snippet sapmtext
	var $1 = new sap.m.Text({
				text :$2,
				textDirection :$3,
				visible :$4,
				wrapping : $5,
				textAlign : $6,
				width :$7,
				maxLines :$8
			});

snippet sapmbutton
	var $1 = new sap.m.Button({
				text : $2,
				type : $3,
				width : $4,
				enabled :$5,
				visible :$6,
				icon : $7,
				iconFirst : $8,
				activeIcon :$9,
				iconDensityAware : $10,
			});
snippet sapmflexbox
	var $1 = new sap.m.FlexBox({
				visible : $2,
				height : $3,
				width : $4,
				displayInline :$5,
				direction :$6,
				fitContainer : $7,
				renderType : $8,
				justifyContent :$9,
				alignItems : $10,
				items:[]
			});
snippet sapmhbox
	var $1 = new sap.m.HBox({
				visible : $2,
				height : $3,
				width : $4,
				displayInline :$5,
				direction :$6,
				fitContainer : $7,
				renderType : $8,
				justifyContent :$9,
				alignItems : $10,
				items:[]
			});

snippet sapmvbox
	var $1 = new sap.m.VBox({
				visible : $2,
				height : $3,
				width : $4,
				displayInline :$5,
				direction :$6,
				fitContainer : $7,
				renderType : $8,
				justifyContent :$9,
				alignItems : $10,
				items:[]
			});

snippet sapcomponent
	sap.ui.controller("$1", {
	   onInit: function(){
	   },
	   onAfterRendering: function() {
	   },
	   onAfterRendering: function() {
	   },
	   onExit: function() {
	   },
	});

snippet sapminput
	var $1 = new sap.m.Input({
		value :$2,
		width : $3,
		enabled :$4,
		visible :$5,
		valueState :$6,
		name : $7,
		placeholder : $8,
		editable : $9,
		type : $10,
		maxLength :$11,
		valueStateText :$12,
		showValueStateMessage :$13,
		dateFormat :$14,
		showValueHelp :$15,
		showSuggestion :$16,
		valueHelpOnly :$17,
		filterSuggests :$18,
		maxSuggestionWidth :$19,
		startSuggestion : $20,
		showTableSuggestionValueHelp : $21,
		description : $22,
		fieldWidth : $23,
		valueLiveUpdate :$24,
		suggestionItems  :[$25],
		suggestionColumns : [$26],
		suggestionRows : [$27],
		liveChange : $28,
		valueHelpRequest :$29,
		suggest : $30,
		suggestionItemSelected : $31
	});
snippet _sthis
	var _self = this;

snippet sapmresponsivepopup
	var $1 = new sap.m.ResponsivePopover({
				placement :$2 ,//sap.m.PlacementType (default: sap.m.PlacementType.Right)
				showHeader :$3 ,//boolean (default: true)
				title : $4,//string
				icon :$5 ,//sap.ui.core.URI
				modal :$6 ,// boolean
				offsetX :$7, //int
				offsetY :$8, //int
				contentWidth : $9,//sap.ui.core.CSSSize
				contentHeight :$10, //sap.ui.core.CSSSize
				horizontalScrolling :$11, //boolean
				verticalScrolling :$12, //boolean
				showCloseButton :$13, //boolean (default: true)
				//Aggregations
				content :$14,  //sap.ui.core.Control[]
				customHeader :$15,  //sap.m.IBar
				subHeader : $16, //sap.m.IBar
				beginButton :$17,  //sap.m.Button
				endButton : $18, //sap.m.Button
				//Associations
				initialFocus : $19, //string | sap.ui.core.Control
				//Events
				beforeOpen :$20,  //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]
				afterOpen : $21, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]
				beforeClose : $22, //fnListenerFunction or [fnListenerFunction, oListenerObject] or [oData, fnListenerFunction, oListenerObject]
				afterClose : $23 //fnList
			});

snippet sapicon
	var $1 = new sap.ui.core.Icon({
					src :$2 , //sap.ui.core.URI
					size :$3 , //sap.ui.core.CSSSize
					color :$4 , //sap.ui.core.CSSColor
					hoverColor : $5 ,  // sap.ui.core.CSSColor
					activeColor :$6 , //sap.ui.core.CSSColor
					width :$7 , //sap.ui.core.CSSSize
					height : $8 ,//sap.ui.core.CSSSize
					backgroundColor :$8 , //sap.ui.core.CSSColor
					hoverBackgroundColor :$9 , //sap.ui.core.CSSColor
					activeBackgroundColor :$10 , //sap.ui.core.CSSColor
					visible :$11 , //boolean (default: true)
					decorative : $12 ,//boolean (default: true)
				});
snippet extendVerticalL
	sap.ui.layout.VerticalLayout.extend("$1", {
	    metadata: {
		properties: {
		  	$2
		},
		aggregations: {
			$3
		},
		events: {
			$4
		}
	    },
	   init: function(){
		$5
	    },

	    renderer: "$6"
	});
snippet extendHorizontalL
	sap.ui.layout.HorizontalLayout.extend("$1", {
	    metadata: {
		properties: {
		  	$2
		},
		aggregations: {
			$3
		},
		events: {
			$4
		}
	    },
	   init: function(){
		$5
	    },

	    renderer: "$6"
	});
./snippets/jenkins.snippets	[[[1
270
snippet steps
	steps {
		sh '${1:make check}'
		junit '${2:reports/**/*.xml}' 
	}
	${0}

snippet stage
	stage('${1:Test}'){
		steps {
			sh '${2:make check}'
			junit '${3:reports/**/*.xml}' 
		}
	}
	${0}

snippet pipeline
	pipeline {
		agent any 
		stages {
			stage('${1:Build}') { 
				steps { 
					sh '${2:make}' 
				}
			}
		}
	}
	${0}

snippet pipeline_sample
	pipeline {
		agent any 
		stages {
			stage('${1:Build}') { 
				steps { 
					sh '${2:make}' 
				}
			}
			stage('${3:Test}'){
				steps {
					sh '${4:make check}'
					junit '${5:reports/**/*.xml}' 
				}
			}
			stage('${6:Deploy}') {
				steps {
					sh '${7:make publish}'
				}
			}
		}
	}
	${0}

snippet d
	docker {
		image '${1:myregistry.com/node'}'
		label '${2:my-defined-label'}'
		registryUrl '${3:https://myregistry.com/'}'
		registryCredentialsId '${4:myPredefinedCredentialsInJenkins'}'
	}


snippet df
	dockerfile {
		filename '${1:Dockerfile.build}'
		dir '${2:build}'
		label '${3:my-defined-label}'
		registryUrl '${4:https://myregistry.com/}'
		registryCredentialsId '${5:myPredefinedCredentialsInJenkins}'
	}

snippet  pa
	post { 
		always { 
			${1}
		}
	}
	${0}

snippet  pc
	post { 
		changed { 
			${1}
		}
	}
	${0}

snippet  pf
	post { 
		fixed { 
			${1}
		}
	}
	${0}

snippet  pr
	post { 
		regression { 
			${1}
		}
	}
	${0}

snippet  pab
	post { 
		aborted { 
			${1}
		}
	}
	${0}

snippet pfa 
	post { 
		failure { 
			${1}
		}
	}
	${0}

snippet ps
	post { 
		success { 
			${1}
		}
	}
	${0}

snippet pu
	post { 
		unstable { 
			${1}
		}
	}
	${0}

snippet  pc
	post { 
		cleanup { 
			${1}
		}
	}
	${0}


snippet psss
	pipeline {
		agent any 
		stages {
			stage('${1:Build}') { 
				steps { 
					sh '${2:make}' 
				}
			}
	}
	${0}

snippet sss
	stages {
		stage('${1:Build}') { 
			steps { 
				sh '${2:make}' 
			}
		}
	}
	${0}



snippet parameters
	parameters{ 
		${1}
	}
	${0}

snippet paramtext
		text(name: "${1:BIOGRAPHY}" , defaultValue: "${2:default}" , description: "${3:Enter some information about the person}")
		${0}

snippet parambool
		booleanParam(name: "${1:TOGGLE}" , defaultValue: ${2:default}, description: "${3:Toggle this value}")
		${0}

snippet paramchoice
		choice(name: "${1:CHOICE}" , choices: ["${2:Choices}",] , description: "${3:Pick something}") 
		${0}

snippet parampassword
		password(name: "${1:PASSWORD}" , defaultValue: "${2:SECRET}" , description: "${3:Enter a password}")
		${0}

snippet paramfile
		file(name: "${1:FILE}" , description: "${2:Choose a file to upload}")${0}
		${0}

snippet triggers
	triggers {
		cron('${1:H */4 * * 1-5}')
	}
	${0}

snippet input
	input {
		message '${1:Should we continue?}'
		ok '${2:Yes, we should.}'
		submitter '${3:alice,bob}'
		parameters { 
			string(name: '${4:PERSON}' , defaultValue: '${5:Mr Jenkins}' , description: '${6:Who should I say hello to?}')
		}
	}
	${0}

snippet whenbranch
	when {
		branch '${1:branch}'
	}
	${0}
snippet whenbuildingTag
	when {
		buildingTag '${1:tag}'
	}
	${0}
snippet whenchangelog
	when {
		changelog '${1:changelog}'
	}
	${0}
snippet whenchangeset
	when {
		changeset '${1:changeSet}'
	}
	${0}
snippet whenchangeRequest
	when {
		changeRequest '${1:changeRequest}'
	}
	${0}
snippet whenenvironment
	when {
		environment '${1:environment}'
	}
	${0}
snippet whenequals
	when {
		equals '${1:equals}'
	}
	${0}
snippet whenexpression
	when {
		expression '${1:expression}'
	}
	${0}
snippet whentag
	when {
		tag '${1:tag}'
	}
	${0}
snippet whennot
	when {
		not '${1:not}'
	}
	${0}
snippet whenallOf
	when {
		allOf '${1:allOf}'
	}
	${0}
snippet whenanyOf
	when {
		anyOf '${1:anyOf}'
	}
./snippets/jinja.snippets	[[[1
142
# Generic tags

extends html

snippet %
	{% ${1} %}
snippet %%
	{% ${1:tag_name} %}
	${0}
	{% end$1 %}
snippet {
	{{ ${1} }}
# Template Tags

snippet autoescape
	{% autoescape ${1:off} %}
		${0}
	{% endautoescape %}
snippet block
	{% block ${1} %}
		${0}
	{% endblock %}
snippet #
	{# ${0:comment} #}
snippet comment
	{% comment %}
		${0}
	{% endcomment %}
snippet cycle
	{% cycle ${1:val1} ${2:val2} ${3:as ${4}} %}
snippet debug
	{% debug %}
snippet extends
	{% extends "${0:base.html}" %}
snippet filter
	{% filter ${1} %}
		${0}
	{% endfilter %}
snippet firstof
	{% firstof ${1} %}
snippet for
	{% for ${1} in ${2} %}
		${0}
	{% endfor %}
snippet empty
	{% empty %}
	${0}
snippet if
	{% if ${1} %}
		${0}
	{% endif %}
snippet el
	{% else %}
		${1}
snippet eif
	{% elif ${1} %}
		${0}
snippet ifchanged
	{% ifchanged %}${1}{% endifchanged %}
snippet ifequal
	{% ifequal ${1} ${2} %}
		${0}
	{% endifequal %}
snippet ifnotequal
	{% ifnotequal ${1} ${2} %}
		${0}
	{% endifnotequal %}
snippet include
	{% include "${0}" %}
snippet load
	{% load ${0} %}
snippet now
	{% now "${0:jS F Y H:i}" %}
snippet regroup
	{% regroup ${1} by ${2} as ${0} %}
snippet spaceless
	{% spaceless %}${0}{% endspaceless %}
snippet ssi
	{% ssi ${0} %}
snippet trans
	{% trans %}${0}{% endtrans %}
snippet url
	{% url ${1} as ${0} %}
snippet widthratio
	{% widthratio ${1:this_value} ${2:max_value} ${0:100} %}
snippet with
	{% with ${1} as ${2} %}
		${0}
	{% endwith %}

# Template Filters

# Note: Since SnipMate can't determine which template filter you are
# expanding without the "|" character, these do not add the "|"
# character.  These save a few keystrokes still.

# Note: Template tags that take no arguments are not implemented.

snippet add
	add:"${0}"
snippet center
	center:"${0}"
snippet cut
	cut:"${0}"
snippet date
	date:"${0}"
snippet default
	default:"${0}"
snippet defaultifnone
	default_if_none:"${0}"
snippet dictsort
	dictsort:"${0}"
snippet dictsortrev
	dictsortreversed:"${0}"
snippet divisibleby
	divisibleby:"${0}"
snippet floatformat
	floatformat:"${0}"
snippet getdigit
	get_digit:"${0}"
snippet join
	join:"${0}"
snippet lengthis
	length_is:"${0}"
snippet pluralize
	pluralize:"${0}"
snippet removetags
	removetags:"${0}"
snippet slice
	slice:"${0}"
snippet stringformat
	stringformat:"${0}"
snippet time
	time:"${0}"
snippet truncatewords
	truncatewords:${0}
snippet truncatewordshtml
	truncatewords_html:${0}
snippet urlizetrunc
	urlizetrunc:${0}
snippet wordwrap
	wordwrap:${0}
./snippets/jsp.snippets	[[[1
99
snippet @page
	<%@page contentType="text/html" pageEncoding="UTF-8"%>
snippet jstl
	<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
	<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>
snippet jstl:c
	<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
snippet jstl:fn
	<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>
snippet cpath
	${pageContext.request.contextPath}
snippet cout
	<c:out value="${1}" default="${0}" />
snippet cset
	<c:set var="${1}" value="${0}" />
snippet cremove
	<c:remove var="${1}" scope="${0:page}" />
snippet ccatch
	<c:catch var="${0}" />
snippet cif
	<c:if test="\${${1}}">
		${0}
	</c:if>
snippet cchoose
	<c:choose>
		${0}
	</c:choose>
snippet cwhen
	<c:when test="\${${1}}">
		${0}
	</c:when>
snippet cother
	<c:otherwise>
		${0}
	</c:otherwise>
snippet cfore
	<c:forEach items="\${${1}}" var="${2}" varStatus="${3}">
		${0:<c:out value="$2" />}
	</c:forEach>
snippet cfort
	<c:set var="${1}">${2:item1,item2,item3}</c:set>
	<c:forTokens var="${3}" items="\${$1}" delims="${4:,}">
		${0:<c:out value="$3" />}
	</c:forTokens>
snippet cparam
	<c:param name="${1}" value="${0}" />
snippet cparam+
	<c:param name="${1}" value="${2}" />
	cparam+${0}
snippet cimport
	<c:import url="${1}" />
snippet cimport+
	<c:import url="${1}">
		<c:param name="${2}" value="${3}" />
		cparam+${0}
	</c:import>
snippet curl
	<c:url value="${1}" var="${2}" />
	<a href="\${$2}">${0}</a>
snippet curl+
	<c:url value="${1}" var="${2}">
		<c:param name="${4}" value="${5}" />
		cparam+${0}
	</c:url>
	<a href="\${$2}">${3}</a>
snippet credirect
	<c:redirect url="${0}" />
snippet contains
	${fn:contains(${1:string}, ${0:substr})}
snippet contains:i
	${fn:containsIgnoreCase(${1:string}, ${0:substr})}
snippet endswith
	${fn:endsWith(${1:string}, ${0:suffix})}
snippet escape
	${fn:escapeXml(${0:string})}
snippet indexof
	${fn:indexOf(${1:string}, ${0:substr})}
snippet join
	${fn:join(${1:collection}, ${0:delims})}
snippet length
	${fn:length(${0:collection_or_string})}
snippet replace
	${fn:replace(${1:string}, ${2:substr}, ${0:replace})}
snippet split
	${fn:split(${1:string}, ${0:delims})}
snippet startswith
	${fn:startsWith(${1:string}, ${0:prefix})}
snippet substr
	${fn:substring(${1:string}, ${2:begin}, ${0:end})}
snippet substr:a
	${fn:substringAfter(${1:string}, ${0:substr})}
snippet substr:b
	${fn:substringBefore(${1:string}, ${0:substr})}
snippet lc
	${fn:toLowerCase(${0:string})}
snippet uc
	${fn:toUpperCase(${0:string})}
snippet trim
	${fn:trim(${0:string})}
./snippets/julia.snippets	[[[1
114
snippet #!
	#!/usr/bin/env julia

# Functions
snippet fun function definition
	function ${1}(${2})
		${0}
	end

snippet ret return
	return(${0})

# Printing to console
snippet pr print
	print("${1}")
	${0}

snippet prl print line
	println("${1}")
	${0}

# Includes
snippet use load a package
	using ${0}

snippet incl include source code
	include("${1}")
	${0}

# Loops
snippet forc for loop iterating over iterable container
	for ${1} in ${2}
		${0}
	end

snippet for standard for loop
	for ${1} = ${2}
		${0}
	end

snippet fornest nested for loop
	for ${1} = ${2}, ${3} = ${4}
		${0}
	end

snippet wh while loop
	while ${1} ${2:<=} ${3}
		${0}
	end

# Conditionals
snippet if if statement
	if ${1}
		${0}
	end

snippet el else part of statement
	else
		${0}

snippet eif else if part of if statement
	else if ${1}
		${0}

snippet ife full if-else statement
	if ${1}
		${2}
	else
		${0}
	end

snippet tern ternary operator
	${1} ? ${2} : ${3:nothing}

# Exceptions
snippet try try catch
	try
		${1:${VISUAL}}
	catch ${2}
		${0}
	end

snippet fin finally statement
	finally
		${0}

snippet thr throw
	throw(${1})
	${0}

# Messages
snippet @i
	@info "${1}" ${0}

snippet @w
	@warn "${1}" ${0}

snippet @e
	@error "${1}" ${0}
	
snippet @d
	@debug "${1}" ${0}

snippet @t @testset with @test 
	@testset "${1}" begin
		${2}
		@test ${0}
	end
	
snippet @tt @testset with @test_throws
	@testset "${1}" begin
		${2}
		@test_throws ${0}
	end
./snippets/kotlin.snippets	[[[1
41
snippet fun
	fun ${1:name}(${2}): ${3:String} {
		${4}
	}
snippet pfun
	private fun ${1:name}(${2}): ${3:String} {
		${4}
	}
snippet main
	@JvmStatic
	fun main(args: Array<String>) {
		${0}
	}
snippet ret
	return ${0}
snippet whe
	when (${1:${VISUAL}}) {
		${2} -> ${3}
	}
snippet cla
	class ${1} {
		${0:${VISUAL}}
	}
snippet cobj
	companion object {
		${0:${VISUAL}}
	}
snippet obj
	object ${1} {
		${0:${VISUAL}}
	}
snippet if
	if (${1}) {
		${0:${VISUAL}}
	}
snippet ife
	if (${1}) {
		${2:${VISUAL}}
	} else {
		${0}
	}
./snippets/laravel.snippets	[[[1
242
#resource controller
snippet l_rsc
	/*!
	* \class       $1
	*
	* \author      ${3:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	class ${1:`!v expand('%:t:r')`} extends ${2:BaseController} {
		function __construct() {
		}
		
		public function index() {
		}
		
		public function create() {
		}
		
		public function store() {
		}
		
		public function show($id) {
		}
		
		public function edit($id) {
		}
		
		public function update($id) {
		}
		
		public function destroy($id) {
		}
	}
#service service provider
snippet l_ssp
	/*!
	* \namespace   $1
	* \class       $2
	*
	* \author      ${3:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${1:Services};

	use Illuminate\Support\ServiceProvider;

	class ${2:`!v expand('%:t:r')`} extends ServiceProvider {
		
		public function register() {
			$this->app->bind('${4}Service', function ($app) {
				return new ${5}(
					$app->make('Repositories\\${6}Interface')
				);
			});
		}
	}
#repository service provider
snippet l_rsp
	/*!
	* \namespace   $2
	* \class       $3
	*
	* \author      ${4:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${2:Repositories\\${1:}};

	use Entities\\$1;
	use $2\\$1Repository;
	use Illuminate\Support\ServiceProvider;

	class ${3:`!v expand('%:t:r')`} extends ServiceProvider {
		/*!
		* \var     defer
		* \brief   Defer service
		*/
		protected $defer = ${5:true};

		public function register() {
				$this->app->bind('$2\\$1Interface', function($app) {
						return new $1Repository(new $1());
				});
		}

		/*!
		* \brief   If $defer == true need this fn
		*/ 
		public function provides() {
				return ['$2\\$1Interface'];
		}
	}
#model
snippet l_md
	/*!
	* \namespace   $1
	* \class       $2
	*
	* \author      ${3:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${1:Entities};

	class ${2:`!v expand('%:t:r')`} extends \Eloquent {
		protected $table   = '${4:`!p snip.rv = t[2].lower()`}';

		public $timestamps = ${5:false};

		protected $hidden  = array(${6});

		protected $guarded = array(${7:'id'});
	}
#abstract repository
snippet l_ar
	/*!
	* \namespace   $1
	* \class       $2
	* \implements  $3
	*
	* \author      ${4:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${1:Repositories};

	use Illuminate\Database\Eloquent\Model;

	abstract class ${2:`!v expand('%:t:r')`} implements ${3:BaseRepositoryInterface} {
		protected $model;

		/*!
		* \fn      __construct
		*
		* \brief   Take the model
		*/

		public function __construct(Model $model) {
				$this->model = $model;
		}

		/*!
		* \fn      all
		*
		* \return  Illuminate\Database\Eloquent\Collection
		*/
		public function all($columns = array('*')) {
				return $this->model->all()->toArray();
		}

		/*!
		* \fn      create
		*
		* \return  Illuminate\Database\Eloquent\Model
		*/
		public function create(array $attributes) {
				return $this->model->create($attributes);
		}

		/*!
		* \fn      destroy
		*
		* \return  int
		*/
		public function destroy($ids) {
				return $this->model->destroy($ids);
		}

		/*!
		* \fn      find
		*
		* \return  mixed
		*/
		public function find($id, $columns = array('*')) {
			return $this->model->find($id, $columns);
		}
	}

#repository
snippet l_r
	/*!
	* \namespace   $1
	* \class       $3
	* \implements  $4
	*
	* \author      ${5:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${1:Repositories\\${2}};

	class ${3:`!v expand('%:t:r')`} extends \\${6} implements ${4:$3RepositoryInterface} {
		${7}
	}
#service
snippet l_s
	/*!
	* \namespace $1
	* \class     $2
	*
	* \author    ${6:`!v g:snips_author`}
	* \date      `!v strftime('%d-%m-%y')`
	*/

	namespace Services\\${1};

	use ${3:Repositories\\${4:Interface}};

	class ${2:`!v expand('%:t:r')`} {
		protected $${5:repo};

		/*!
		* \fn      __construct
		*/
		public function __construct($4 $repo) {
			$this->$5 = $repo;
		}
	}
#facade
snippet l_f
	/*!
	* \namespace   $1
	* \class       $2
	*
	* \author      ${5:`!v g:snips_author`}
	* \date        `!v strftime('%d-%m-%y')`
	*/

	namespace ${1:Services};

	use \Illuminate\Support\Facades\Facade;

	class ${2:`!v expand('%:t:r')`} extends Facade {
		/*!
		* \fn          getFacadeAccessor
		*
		* \return      string
		*/
		protected static function getFacadeAccessor() { return '${4:${3}Service}'; }
	}
./snippets/ledger.snippets	[[[1
5
# Ledger <http://ledger-cli.org/>
snippet ent
	`strftime("%Y/%m/%d")` ${1:transaction}
	    ${2:account}    ${3:value}
	    ${0:account}
./snippets/lfe.snippets	[[[1
18
snippet defmo
	(defmodule ${1:`vim_snippets#Filename()`}
		(export ${2:all}))
	$0
snippet def
	(defun $1 ($2)
		$0)
snippet ltest
	(defmodule ${1:`vim_snippets#Filename()`}
		(behaviour ltest-unit)
		(export all))

	(include-lib "ltest/include/ltest-macros.lfe")

	$0
snippet test
	(deftest $1
		$0)
./snippets/liquid.snippets	[[[1
472
# Port of Shopify Liquid Template Snippets
# https://marketplace.visualstudio.com/items?itemName=killalau.vscode-liquid-snippets

snippet if
	{% if $1 %}
		${0:${VISUAL}}
	{% endif %}
snippet else
	{% else %}
snippet elsif
	{% elsif $1 %}
snippet ifelse
	{% if $1 %}
		${2}
	{% else %}
		${0}
	{% endif %}
snippet unless
	{% unless $1 %}
		${0:${VISUAL}}
	{% endunless %}
snippet case
	{% case ${1:variable} %}
		{% when $2 %}
			${3}
		{% else %}
			${0}
	{% endcase %}
snippet when
	{% when $1 %}
		${0:${VISUAL}}
snippet cycle
	{% cycle '${1:odd}', '${2:even}' %}
snippet cyclegroup
	{% cycle '${1:group name}': '${2:odd}', '${3:even}' %}
snippet for
	{% for ${1:item} in ${2:collection} %}
		${0}
	{% endfor %}
snippet limit
	limit: ${1:5}
snippet offset
	offset: ${1:0}
snippet reversed
	reversed
snippet break
	{% break %}
snippet continue
	{% continue %}
snippet tablerow
	{% tablerow ${1:item} in ${2:collection} cols: ${3:2} %}
		${0}
	{% endtablerow %}
snippet assign
	{% assign ${1:variable} = ${0:value} %}
snippet increment
	{% increment ${0:variable} %}
snippet decrement
	{% decrement ${0:variable} %}
snippet capture
	{% capture ${1:variable} %}${0}{% endcapture %}
snippet include
	{% include '${0:snippet}' %}
snippet includewith
	{% include '${1:snippet}', ${2:variable}: ${0:value} %}
snippet render
	{% render '${0:snippet}' %}
snippet renderwith
	{% render '${1:snippet}', ${2:variable}: ${0:value} %}
snippet section
	{% section '${1:snippet}' %}
snippet raw
	{% raw %}${0}{% endraw %}
snippet layout
	{% layout '${1:layout}' %}
snippet layoutnone
	{% layout none %}
snippet paginate
	{% paginate ${1:collection.products} by ${2:12} %}
		{% for ${3:product} in $1 %}
			${0}
		{% endfor %}
	{% endpaginate %}
snippet schema
	{% schema %}
		{
			${0}
		}
	{% endschema %}
snippet stylesheet
	{% stylesheet %}
		${0}
	{% endstylesheet %}
snippet stylesheet_scss
	{% stylesheet '${1:scss}' %}
		${0}
	{% endstylesheet %}
snippet javascript
	{% javascript %}
		${0}
	{% endjavascript %}
snippet comment-
	{%- comment -%}${0:${VISUAL}}{%- endcomment -%}
snippet if-
	{%- if $1 -%}
		${0:${VISUAL}}
	{%- endif -%}
snippet else-
	{%- else -%}
snippet elsif-
	{%- elsif $1 -%}
snippet ifelse-
	{%- if $1 -%}
		${2}
	{%- else -%}
		${0}
	{%- endif -%}
snippet unless-
	{%- unless $1 -%}
		${0:${VISUAL}}
	{%- endunless -%}
snippet case-
	{%- case ${1:variable} -%}
		{%- when $2 -%}
			${3}
		{%- else -%}
			${0}
	{%- endcase -%}
snippet when-
	{%- when $1 -%}
		${0:${VISUAL}}
snippet cycle-
	{%- cycle '${1:odd}', '${2:even}' -%}
snippet cyclegroup-
	{%- cycle '${1:group name}': '${2:odd}', '${3:even}' -%}
snippet for-
	{%- for ${1:item} in ${2:collection} -%}
		${0}
	{%- endfor -%}
snippet continue-
	{%- continue -%}
snippet tablerow-
	{%- tablerow ${1:item} in ${2:collection} cols: ${3:2} -%}
		${0}
	{%- endtablerow -%}
snippet assign-
	{%- assign ${1:variable} = ${0:value} -%}
snippet capture-
	{%- capture ${1:variable} -%}${0}{%- endcapture -%}
snippet include-
	{%- include '${0:snippet}' -%}
snippet includewith-
	{%- include '${1:snippet}', ${2:variable}: ${0:value} -%}
snippet render-
	{%- render '${0:snippet}' -%}
snippet renderwith-
	{%- render '${1:snippet}', ${2:variable}: ${0:value} -%}
snippet section-
	{%- section '${1:snippet}' -%}
snippet layout-
	{%- layout '${1:layout}' -%}
snippet layoutnone-
	{%- layout none -%}
snippet paginate-
	{%- paginate ${1:collection.products} by ${2:12} -%}
		{%- for ${3:product} in $1 -%}
			${0}
		{%- endfor -%}
	{%- endpaginate -%}
snippet join
	| join: '${1:, }'
snippet first
	| first
snippet last
	| last
snippet concat
	| concat: ${1:array}
snippet map
	| map: '${1:key}'
snippet reverse
	| reverse
snippet size
	| size
snippet sort
	| sort: '${1:key}'
snippet uniq
	| uniq
snippet img_tag
	| img_tag
snippet img_tag_param
	| img_tag: '${1:alt}', '${2:class}'
snippet script_tag
	| script_tag
snippet stylesheet_tag
	| stylesheet_tag
snippet abs
	| abs
snippet ceil
	| ceil
snippet divided_by
	| divided_by: ${1:2}
snippet floor
	| floor
snippet minus
	| minus: ${1:1}
snippet plus
	| plus: ${1:1}
snippet round
	| round: ${1:0}
snippet times
	| times: ${1:1}
snippet modulo
	| modulo: ${1:2}
snippet money
	| money
snippet money_with_currency
	| money_with_currency
snippet money_without_trailing_zeros
	| money_without_trailing_zeros
snippet money_without_currency
	| money_without_currency
snippet append
	| append: '${1:string}'
snippet camelcase
	| camelcase
snippet capitalize
	| capitalize
snippet downcase
	| downcase
snippet escape
	| escape
snippet handleize
	| handleize
snippet md5
	| md5
snippet newline_to_br
	| newline_to_br
snippet pluralize
	| pluralize: '${1:item}', '${2:items}'
snippet prepend
	| prepend: '${1:string}'
snippet remove
	| remove: '${1:string}'
snippet remove_first
	| remove_first: '${1:string}'
snippet replace
	| replace: '${1:target}', '${2:replace}'
snippet replace_first
	| replace_first: '${1:target}', '${2:replace}'
snippet slice
	| slice: ${1:0}, ${2:5}
snippet slice_single
	| slice: ${1:at}
snippet split
	| split: '${1:,}'
snippet strip
	| strip
snippet lstrip
	| lstrip
snippet rstrip
	| rstrip
snippet strip_html
	| strip_html
snippet strip_newlines
	| strip_newlines
snippet truncate
	| truncate: ${1:20}, '${2:...}'
snippet truncatewords
	| truncatewords: ${1:5}, '${2:...}'
snippet upcase
	| upcase
snippet url_encode
	| url_encode
snippet url_escape
	| url_escape
snippet url_param_escape
	| url_param_escape
snippet asset_url
	| asset_url
snippet asset_img_url
	| asset_img_url: '${1:medium}'
snippet img_url
	| img_url: '${1:medium}'
snippet _schema
	{% schema %}
		{
			"name": "${1}",
			"class": "${2}",
			"settings": [
				${0}
			]
		}
	{% endschema %}
snippet _blocks
	"blocks": [
		{
			"type": "${1}",
			"name": "${2}",
			"settings": [
				${0}
			]
		}
	]
snippet _text
	{
		"type": "text",
		"id": "${1}",
		"label": "${2}",
		"default": "${3}",
		"info": "${4}",
		"placeholder": "${0}"
	}
snippet _textarea
	{
		"type": "textarea",
		"id": "${1}",
		"label": "${2}",
		"default": "${3}",
		"info": "${4}",
		"placeholder": "${0}"
	}
snippet _image_picker
	{
		"type": "image_picker",
		"id": "${1}",
		"label": "${0}"
	}
snippet _radio
	{
		"type": "radio",
		"id": "${1}",
		"label": "${2}",
		"options": [
			{ "value": "${5}", "label": "${0}" }
		],
		"default": "${3}",
		"info": "${4}"
	}
snippet _select
	{
		"type": "select",
		"id": "${1}",
		"label": "${2}",
		"options": [
			{
				"group": "${5}",
				"value": "${6}",
				"label": "${0}"
			}
		],
		"default": "${3}",
		"info": "${4}"
	}
snippet _checkbox
	{
		"type": "checkbox",
		"id": "${1}",
		"label": "${2}",
		"default": ${3:true},
		"info": "${0}"
	}
snippet _range
	{
		"type": "range",
		"id": "${1}",
		"min": ${2},
		"max": ${3},
		"step": ${4},
		"unit": "${5}",
		"label": "${6}",
		"default": ${0}
	}
snippet _color
	{
		"type": "color",
		"id": "${1}",
		"label": "${2}",
		"default": "${3}",
		"info": "${0}"
	}
snippet _font
	{
		"type": "font_picker",
		"id": "${1}",
		"label": "${2}",
		"info": "${3}",
		"default": "${0:helvetica_n4}"
	}
snippet _collection
	{
		"type": "collection",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _product
	{
		"type": "product",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _blog
	{
		"type": "blog",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _page
	{
		"type": "page",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _link_list
	{
		"type": "link_list",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _url
	{
		"type": "url",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _video
	{
		"type": "video_url",
		"id": "${1}",
		"label": "${2}",
		"accept": ["youtube", "vimeo"${0}],
		"default": "${3}",
		"info": "${4}",
		"placeholder": "${5}"
	}
snippet _richtext
	{
		"type": "richtext",
		"id": "${1}",
		"label": "${2}",
		"default": "<p>${0}</p>"
	}
snippet _html
	{
		"type": "html",
		"id": "${1}",
		"label": "${2}",
		"default": "<div>${0}</div>"
	}
snippet _article
	{
		"type": "article",
		"id": "${1}",
		"label": "${2}",
		"info": "${0}"
	}
snippet _header
	{
		"type": "header",
		"content": "${1}",
		"info": "${0}"
	}
snippet _paragraph
	{
		"type": "paragraph",
		"content": "${0}"
	}
./snippets/lpc.snippets	[[[1
190
##
## Preprocessor
# #include <...>
snippet inc
	#include <${1:stdio}.h>
# #include "..."
snippet Inc
	#include "${1:`vim_snippets#Filename("$1.h")`}"
# ifndef...define...endif
snippet ndef
	#ifndef $1
	#define ${1:SYMBOL} ${2:value}
	#endif /* ifndef $1 */
# define
snippet def
	#define
# ifdef...endif
snippet ifdef
	#ifdef ${1:FOO}
		${2:#define }
	#endif
# if
snippet #if
	#if ${1:FOO}
		${0:${VISUAL}}
	#endif
# header include guard
snippet once
	#ifndef ${1:`toupper(vim_snippets#Filename('$1_H', 'UNTITLED_H'))`}

	#define $1

	${0}

	#endif /* end of include guard: $1 */
##
## Control Statements
# if
snippet if
	if(${1:true})
	{
		${0:${VISUAL}}
	}
snippet ife
	if(${1:true})
	{
		${2:${VISUAL}}
	}
	else
	{
		${0}
	}
# else
snippet el
	else
	{
		${0:${VISUAL}}
	}
# else if
snippet elif
	else if(${1:true})
	{
		${0:${VISUAL}}
	}
# ifi
snippet ifi
	if(${1:true}) ${0};
# ternary
snippet t Ternary: `condition ? true : false`
	$1 ? $2 : $0
# switch
snippet switch
	switch(${1:/* variable */})
	{
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
		default:
			${6}
	}
# switch without default
snippet switchndef
	switch(${1:/* variable */})
	{
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
	}
# case
snippet case
	case ${1:/* variable case */}:
		${2}
		${3:break;}
snippet ret
	return ${0};
##
## Loops
#foreach
snippet fore
	foreach(${1:mixed} ${2:ele} in ${3:arr})
	{
		${4}
	}
# for
snippet for
	for(int ${2:i} = 0; $2 < ${1:count}; $2${3:++})
	{
		${4}
	}
# for (custom)
snippet forr
	for(int ${1:i} = ${2:0}; ${3:$1 < 10}; $1${4:++})
	{
		${5}
	}
# while
snippet wh
	while($1)
	{
		${0:${VISUAL}}
	}
# do... while
snippet do
	do{
		${0:${VISUAL}}
	}while ($1);
##
## Functions
# function definition
snippet fnc
	${1:void} ${2:function_name}(${3})
	{
		${4}
	}
# function definition with zero parameters
snippet defun0
	${1:void} ${2:function_name}()
	{
		${3}
	}
# function definition with one parameter
snippet defun1
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter})
	{
		${5}
	}
# function definition with two parameters
snippet defun2
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter})
	{
		${7}
	}
# function definition with three parameters
snippet defun3
	${1:void} ${2:function_name}(${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter}, ${7:Type} ${8:Parameter})
	{
		${9}
	}
# function declaration
snippet fund
	${1:void} ${2:function_name}(${3});
##
## Input/Output
# printf
snippet pr
	printf("${1:%s}\n"${2});
# fprintf (again, this isn't as nice as TextMate's version, but it works)
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});
snippet prd
	printf("${1:} = %d\n", $1);
snippet prf
	printf("${1:} = %f\n", $1);
snippet prx
	printf("${1:} = %${2}\n", $1);
##
# TODO section
snippet todo
	/*! TODO: ${1:Todo description here} */

## Miscellaneous
# This is kind of convenient
snippet .
	[${1}]


##
## MHXY
snippet head
	// code for ${1} by `$USER` create at `strftime("%Y-%m-%d %H:%M:%S")`
./snippets/ls.snippets	[[[1
108
# Closure loop
snippet forinlet
	for ${1:name} in ${2:array}
		let $1
			${3}
# Array comprehension
snippet fora
	for ${1:name} in ${2:array}
		${3}
# Object comprehension
snippet foro
	for ${1:key}, ${2:value} of ${3:object}
		${4}
# Range comprehension (inclusive)
snippet forr
	for ${1:name} from ${2:start} to ${3:finish}
		${4}
snippet forrb
	for ${1:name} from ${2:start} to ${3:finish} by ${4:step}
		${5}
# Range comprehension (exclusive)
snippet forrex
	for ${1:name} from ${2:start} til ${3:finish}
		${4}
snippet forrexb
	for ${1:name} from ${2:start} til ${3:finish} by ${4:step}
		${5}
# Function
snippet fun
	(${1:args}) ->
		${2}
# Function (bound)
snippet bfun
	(${1:args}) ~>
		${2}
# Class
snippet cla class ..
	class ${1:`substitute(Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${2}
snippet cla class .. constructor: ..
	class ${1:`substitute(Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		(${2:args}) ->
			${3}

		${4}
snippet cla class .. extends ..
	class ${1:`substitute(Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		${3}
snippet cla class .. extends .. constructor: ..
	class ${1:`substitute(Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} extends ${2:ParentClass}
		(${3:args}) ->
			${4}

		${5}
# If
snippet if
	if $1
		${2}
# If __ Else
snippet ife
	if $1
		${2}
	else
		${3}
# Else if
snippet elif
	else if $1
		${2}
# Ternary If
snippet ifte
	if $1 then $2 else $0
# Unless
snippet unl
	$1 unless $0
# Switch
snippet swi
	switch ${1:object}
	case ${2:value}
		${3}
	default void
snippet mat
	match ${1:object}
	| ${2:value} => ${3}
	| otherwise => void

# Log
snippet log
	console.log ${1}
# stringify
snippet str
	JSON.stringify ${1}, void, 2

# Try __ Catch
snippet try
	try
		${1:${VISUAL}}
	catch ${2:error}
		${3}
# Require
snippet req
	${2:$1} = require '${1}'${3}
# Require!
snippet req!
	require! ${1}

# Export
snippet exp
	${1:root} = exports ? this
./snippets/lua.snippets	[[[1
72
snippet #!
	#!/usr/bin/env lua
	$1
snippet local
	local ${1:x} = ${0:1}
snippet fun
	function ${1:fname}(${2:...})
		$0
	end
snippet for
	for ${1:i}=${2:1},${3:10} do
		${0:print(i)}
	end
snippet forp
	for ${1:i},${2:v} in pairs(${3:table_name}) do
		$0
	end
snippet fori
	for ${1:i},${2:v} in ipairs(${3:table_name}) do
		$0
	end
snippet if
	if $1 then
		$2
	end
snippet ife
	if $1 then
		${2:-- if condition}
	else
		${0:-- else}
	end
snippet elif
	elseif $1 then
		$0
snippet repeat
	repeat
		$1
	until $0
snippet while
	while $1 do
		$0
	end
snippet wh
	while ${1:true} do
		${0}
	end
snippet wht
	while true do
		${0}
	end
snippet print
	print("${1:string}")
snippet pr
	print($0)
snippet prs
	print("$0")
snippet prf
	print(string.format("${1:%s}"$0))
snippet wr
	io.write($0)
snippet wrs
	io.write("$0")
snippet wrf
	io.write(string.format("${1:%s}"$0))
snippet fwr
	io.${1:stderr}:write($0)
snippet fwrs
	io.${1:stderr}:write("$0")
snippet fwrf
	io.${1:stderr}:write(string.format("${2:%s}"$0))
snippet req
	require('${1:mod}')
./snippets/make.snippets	[[[1
50
# base
snippet base
	.PHONY: clean, mrproper
	CC = gcc
	CFLAGS = -g -Wall

	all: $1

	%.o: %.c
		$(CC) $(CFLAGS) -c -o $@ $<
	
	${1:out}: $1.o
		$(CC) $(CFLAGS) -o $@ $+

	clean:
		rm -f *.o core.*

	mrproper: clean
		rm -f $1
# add
snippet add
	${1:out}: $1.o
		$(CC) $(CFLAGS) -o $@ $+
# print
snippet print
	print-%: ; @echo $*=$($*)
# ifeq
snippet if
	ifeq (${1:cond0}, ${2:cond1})
		${0:${VISUAL}}
	endif
# ifeq ... else ... endif
snippet ife
	ifeq (${1:cond0}, ${2:cond1})
		${3:${VISUAL}}
	else
		${0}
	endif
# else ...
snippet el
	else
		${0:${VISUAL}}
# .DEFAULT_GOAL := target
snippet default
	.DEFAULT_GOAL := ${1}
# help target for self-documented Makefile
snippet help
	help: ## Prints help for targets with comments
		@cat $(MAKEFILE_LIST) | grep -E '^[a-zA-Z_-]+:.*?## .*$$' | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-30s\033[0m %s\n", $\$1, $\$2}'
	${0}
./snippets/mako.snippets	[[[1
54
snippet def
	<%def name="${1:name}">
		${0:}
	</%def>
snippet call
	<%call expr="${1:name}">
		${0:}
	</%call>
snippet doc
	<%doc>
		${0:}
	</%doc>
snippet text
	<%text>
		${0:}
	</%text>
snippet for
	% for ${1:i} in ${2:iter}:
		${0:}
	% endfor
snippet if if
	% if $1:
		${0:}
	% endif
snippet ife if/else
	% if $1:
		${2:}
	% else:
		${0:}
	% endif
snippet try
	% try:
		${1:${VISUAL}}
	% except${2:}:
		${0:pass}
	% endtry
snippet wh
	% while ${1:}:
		${0:}
	% endwhile
snippet $
	${ ${0:} }
snippet <%
	<% ${0:} %>
snippet <!%
	<!% ${0:} %>
snippet inherit
	<%inherit file="${0:filename}" />
snippet include
	<%include file="${0:filename}" />
snippet namespace
	<%namespace file="${0:name}" />
snippet page
	<%page args="${0:}" />
./snippets/markdown.snippets	[[[1
156
# Markdown

# Includes octopress (http://octopress.org/) snippets

# The suffix `c` stands for "Clipboard".

snippet [
	[${1:text}](https://${2:address})
snippet [*
	[${1:link}](${2:`@*`})
snippet [c
	[${1:link}](${2:`@+`})
snippet ["
	[${1:text}](https://${2:address} "${3:title}")
snippet ["*
	[${1:link}](${2:`@*`} "${3:title}")
snippet ["c
	[${1:link}](${2:`@+`} "${3:title}")
snippet [:
	[${1:id}]: https://${2:url}

snippet [:*
	[${1:id}]: ${2:`@*`}

snippet [:c
	[${1:id}]: ${2:`@+`}

snippet [:"
	[${1:id}]: https://${2:url} "${3:title}"

snippet [:"*
	[${1:id}]: ${2:`@*`} "${3:title}"

snippet [:"c
	[${1:id}]: ${2:`@+`} "${3:title}"

snippet ![
	![${1:alttext}](${2:/images/image.jpg})
snippet ![*
	![${1:alt}](${2:`@*`})
snippet ![c
	![${1:alt}](${2:`@+`})
snippet !["
	![${1:alttext}](${2:/images/image.jpg} "${3:title}")
snippet !["*
	![${1:alt}](${2:`@*`} "${3:title}")
snippet !["c
	![${1:alt}](${2:`@+`} "${3:title}")
snippet ![:
	![${1:id}]: ${2:url}

snippet ![:*
	![${1:id}]: ${2:`@*`}

snippet ![:"
	![${1:id}]: ${2:url} "${3:title}"

snippet ![:"*
	![${1:id}]: ${2:`@*`} "${3:title}"

snippet ![:"c
	![${1:id}]: ${2:`@+`} "${3:title}"

snippet <
	<http://${1:url}>
snippet <*
	<`@*`>
snippet <c
	<`@+`>
snippet ** Bold
	**$0**
snippet __ Bold
	__$0__
snippet --- Front matter
	---
	$0
	---
snippet ====
	`repeat('=', strlen(getline(line('.') - 3)))`

	${0}
snippet -
	-   ${0}
snippet ----
	`repeat('-', strlen(getline(line('.') - 3)))`

	${0}
snippet blockquote
	{% blockquote %}
	${0:quote}
	{% endblockquote %}

snippet blockquote-author
	{% blockquote ${1:author}, ${2:title} %}
	${0:quote}
	{% endblockquote %}

snippet blockquote-link
	{% blockquote ${1:author} ${2:URL} ${3:link_text} %}
	${0:quote}
	{% endblockquote %}

snippet ```
	\`\`\`${1}
	${0:${VISUAL}}
	\`\`\`

# Language.
snippet ```l
	\`\`\`${1:language}
	${2:code}
	\`\`\`

snippet codeblock-short
	{% codeblock %}
	${0:code_snippet}
	{% endcodeblock %}

snippet codeblock-full
	{% codeblock ${1:title} lang:${2:language} ${3:URL} ${4:link_text} %}
	${0:code_snippet}
	{% endcodeblock %}

snippet gist-full
	{% gist ${1:gist_id} ${0:filename} %}

snippet gist-short
	{% gist ${0:gist_id} %}

snippet img
	{% img ${1:class} ${2:URL} ${3:width} ${4:height} ${5:title_text} ${0:alt_text} %}

snippet youtube
	{% youtube ${0:video_id} %}

snippet tb
	|  ${0:factors}      |    ${1:a}       |  ${2:b}   	|
	| ------------- |-------------  | ------- |
	|    ${3:f1}    |    Y          | N       |
	|    ${4:f2}    |    Y          | N       |

# The quote should appear only once in the text. It is inherently part of it.
# See http://octopress.org/docs/plugins/pullquote/ for more info.

snippet pullquote
	{% pullquote %}
	${1:text} {" ${2:quote} "} ${0:text}
	{% endpullquote %}

# Definition lists
snippet : Definition list
	$1
	: $0
snippet :: Alternate definition list
	$1
	  - $0
./snippets/matlab.snippets	[[[1
64
snippet if if
	if ${1}
		${0}
	end

snippet ife if ... else
	if ${1}
		${2}
	else
		${0}
	end

snippet el else
	else
		${0}

snippet eif elsif
	elseif ${1}
		${0}

snippet wh while
	while ${1}
		${0}
	end

snippet for for
	for ${1:i} = ${2:1:n}
		${0}
	end

snippet parfor parfor
	parfor ${1:i} = ${2:1:n}
		${0}
	end

snippet fun function
	function [${3:out}] = ${1:`vim_snippets#Filename("$1", "fun_name")`}(${2}) 
	${0}

snippet try try ... catch
	try
		${1}
	catch ${2:err}
		${0}
	end

snippet switch switch
	switch ${1:n}
		case ${2:0}
			${0}
	end

snippet @ anonymous function
	@(${1:x}) ${0:x*x}

snippet cl class 
	classdef ${1:`vim_snippets#Filename("$1", "class_name")`}
	   properties
		  ${2}
	   end
	   methods
		  ${0}
	   end
	end
./snippets/mustache.snippets	[[[1
15
snippet if # {{#value}} ... {{/value}}
	{{#${1:value}}}
	${0:${VISUAL}}
	{{/$1}}
snippet ifn # {{^value}} ... {{/value}}
	{{^${1:value}}}
	${0:${VISUAL}}
	{{/$1}}
snippet ife # {{#value}} ... {{/value}} {{^value}} ... {{/value}}
	{{#${1:value}}}
	${2:${VISUAL}}
	{{/$1}}
	{{^$1}}
	${3}
	{{/$1}}
./snippets/objc.snippets	[[[1
247
# #import <...>
snippet Imp
	#import <${1:Cocoa/Cocoa.h}>
# #import "..."
snippet imp
	#import "${1:`vim_snippets#Filename()`.h}"
# @selector(...)
snippet sel
	@selector(${1:method}:)
# @"..." string
snippet s
	@"${1}"
# Object
snippet o
	${1:NSObject} *${2:foo} = [${3:$1 alloc}]${4};
# NSLog(...)
snippet log
	NSLog(@"${1:%@}"${2});
# Class
snippet objc
	@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}
	{
	}
	@end

	@implementation $1
	${0}
	@end
# Class Interface
snippet int
	@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${0}
	@end
snippet @interface
	@interface ${1:`vim_snippets#Filename('', 'someClass')`} : ${2:NSObject}
	{${3}
	}
	${0}
	@end
# Class Implementation
snippet impl
	@implementation ${1:`vim_snippets#Filename('', 'someClass')`}
	${0}
	@end
snippet @implementation
	@implementation ${1:`vim_snippets#Filename('', 'someClass')`}
	${0}
	@end
# Protocol
snippet pro
	@protocol ${1:`vim_snippets#Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${0}
	@end
snippet @protocol
	@protocol ${1:`vim_snippets#Filename('$1Delegate', 'MyProtocol')`} ${2:<NSObject>}
	${0}
	@end
# init Definition
snippet init
	- (id)init
	{
		if (self = [super init]) {
			${0}
		}
		return self;
	}
# dealloc Definition
snippet dealloc
	- (void) dealloc
	{
		${0:deallocations}
		[super dealloc];
	}
snippet su
	[super ${1:init}]
snippet ibo
	IBOutlet ${1:NSSomeClass} *${2:$1};
# Category
snippet cat
	@interface ${1:NSObject} (${2:MyCategory})
	@end

	@implementation $1 ($2)
	${0}
	@end
# Category Interface
snippet cath
	@interface ${1:`vim_snippets#Filename('$1', 'NSObject')`} (${2:MyCategory})
	${0}
	@end
# Method
snippet m
	- (${1:id})${2:method}
	{
		${0}
	}
# Method declaration
snippet md
	- (${1:id})${2:method};
# IBAction declaration
snippet ibad
	- (IBAction)${1:method}:(${2:id})sender;
# IBAction method
snippet iba
	- (IBAction)${1:method}:(${2:id})sender
	{
		${0}
	}
# awakeFromNib method
snippet wake
	- (void)awakeFromNib
	{
		${0}
	}
# Class Method
snippet M
	+ (${1:id})${2:method}
	{
		${0:return nil;}
	}
# Sub-method (Call super)
snippet sm
	- (${1:id})${2:method}
	{
		[super $2];${0}
		return self;
	}
# Accessor Methods For:
# Object
snippet objacc
	- (${1:id})${2:thing}
	{
		return $2;
	}

	- (void)set$2:($1)${3:new$2}
	{
		[$3 retain];
		[$2 release];
		$2 = $3;
	}
# for (object in array)
snippet forin
	for (${1:Class} *${2:some$1} in ${3:array}) {
		${0}
	}
snippet fore
	for (${1:object} in ${2:array}) {
		${0:statements}
	}
snippet forarray
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${0}
	}
snippet fora
	unsigned int ${1:object}Count = [${2:array} count];

	for (unsigned int index = 0; index < $1Count; index++) {
		${3:id} $1 = [$2 $1AtIndex:index];
		${0}
	}
# Try / Catch Block
snippet	@try
	@try {
		${1:statements}
	}
	@catch (NSException * e) {
		${2:handler}
	}
	@finally {
		${0:statements}
	}
snippet @catch
	@catch (${1:exception}) {
		${0:handler}
	}
snippet @finally
	@finally {
		${0:statements}
	}
# IBOutlet
# @property (Objective-C 2.0)
snippet prop
	@property (${1:retain}) ${2:NSSomeClass} ${3:*$2};
# @synthesize (Objective-C 2.0)
snippet syn
	@synthesize ${1:property};
# [[ alloc] init]
snippet alloc
	[[${1:foo} alloc] init${2}];
snippet a
	[[${1:foo} alloc] init${2}];
# retain
snippet ret
	[${1:foo} retain];
# release
snippet rel
	[${0:foo} release];
# autorelease
snippet arel
	[${0:foo} autorelease];
# autorelease pool
snippet pool
	NSAutoreleasePool *${1:pool} = [[NSAutoreleasePool alloc] init];
	${0}
	[$1 drain];
# Throw an exception
snippet except
	NSException *${1:badness};
	$1 = [NSException exceptionWithName:@"${2:$1Name}"
	                             reason:@"${0}"
	                           userInfo:nil];
	[$1 raise];
snippet prag
	#pragma mark ${0:-}
snippet cl
	@class ${1:Foo};
snippet color
	[[NSColor ${0:blackColor}] set];
# NSArray
snippet array
	NSMutableArray *${1:array} = [NSMutable array];
snippet nsa
	NSArray ${0}
snippet nsma
	NSMutableArray ${0}
snippet aa
	NSArray * array;
snippet ma
	NSMutableArray * array;
# NSDictionary
snippet dict
	NSMutableDictionary *${1:dict} = [NSMutableDictionary dictionary];
snippet nsd
	NSDictionary ${0}
snippet nsmd
	NSMutableDictionary ${0}
# NSString
snippet nss
	NSString ${0}
snippet nsms
	NSMutableString ${0}
./snippets/ocaml.snippets	[[[1
39
snippet doc
	(** ${0} *)
snippet comment
	(* ${0} *)
snippet let
	let ${1} = ${2} in
	${0}
snippet fn
	let ${1} =
		${0}
snippet fun
	type ${1} = ${0}
snippet mod
	module ${1} = struct
		${0}
	end
snippet modty
	module type ${1} = sig
		${0}
	end
snippet sw
	match ${1} with
	| ${2} -> ${0}
snippet |
	| ${1} -> ${0}
snippet p
	|> ${0}
snippet if
	if ${1} then
		${2}
	else
		${0}
snippet fnr
	let rec ${1} =
		${0}
snippet try
	try
		${1}
	with ${0}
./snippets/octave.snippets	[[[1
2
extends matlab

./snippets/openfoam.snippets	[[[1
53
# 0/*
snippet fv
	type		fixedValue;
	value		uniform ${0};
snippet zg
	type		zeroGradient;
snippet sym
	type		symmetryPlane;
# system/controlDict
snippet forces
	forces
	{
		type				forces;
		functionObjectLibs	("libforces.so");
		enabled				true;
		outputControl		${1:timeStep};
		outputInterval		${2:1};
		patches				(${3});
		log					${4:true};
		CofR				(${0:0 0 0});
	}
# system/fvSolution
# solvers
snippet gamg
	${1:p}
	{
		solver          GAMG;
		tolerance       1e-${2:6};
		relTol          ${0:0.0};
		smoother        GaussSeidel;
		cacheAgglomeration true;
		nCellsInCoarsestLevel 10;
		agglomerator    faceAreaPair;
		mergeLevels     1;
	}
snippet pbicg
	${1:U}
	{
		solver          PBiCG;
		preconditioner  DILU;
		tolerance       1e-${2:6};
		relTol          ${0:0.0};
	}
# PIMPLE
snippet pimple
	PIMPLE
	{
		nOuterCorrectors 	${1:outer};
		nCorrectors     	${2:inner};
		nNonOrthogonalCorrectors ${3:nonOrtho};
		pRefCell        	${4:cell};
		pRefValue       	${0:value for $4};
	}
./snippets/org.snippets	[[[1
135
# Org Mode Snippets Imported from (https://github.com/doomemacs/snippets/)
# Imported by ybenel (github.com/m1ndo)

# Begin 
snippet begin
	#+begin_${1:type} ${2:options}
	$0
	#+end_$1
# Begin Center
snippet <C
	#+begin_center
	$0
	#+end_center
# Begin Comment
snippet <c
	#+begin_comment
	$0
	#+end_comment
# Begin Example
snippet <e
	#+begin_example
	$0
	#+end_example
# Begin Export Ascii
snippet <a
	#+begin_export ascii
	$0
	#+end_export
# Begin export html
snippet <h
	#+begin_export html
	$0
	#+end_export
# Begin export Latex
snippet <l
	#+begin_export latex
	$0
	#+end_export
# Begin export python 
snippet <p
	#+begin_export python
	$0
	#+end_export
# Begin export shell
snippet <s
	#+begin_export shell
	$0
	#+end_export
# dot
snippet dot
	#+begin_src dot :file ${1:file}.${2:svg} :results file graphics
	$0
	#+end_src
# elisp
snippet elisp
	#+begin_src emacs-lisp :tangle yes
	$0
	#+end_src
# Entry
snippet entry
	#+begin_html
	---
	layout: ${1:default}
	title: ${2:title}
	---
	#+end_html
	$0
# Begin example
snippet ex
	#+begin_example
	$0
	#+end_example
# Begin export
snippet export
	#+begin_export ${1:type}
	$0
	#+end_export
# Figure
snippet fig
	#+caption: ${1:caption}
	#+attr_latex: ${2:scale=0.75}
	#+name: fig-${3:label}
# Org Header
snippet head
	#+title:     ${1:untitled document}
	#+author:    ${2:user-full-name}
	#+email:     ${3:user-mail-address}
# Image
snippet img
	#+attr_html: :alt $2 :align ${3:left} :class img
	[[${1:src}]${4:[${5:title}]}]
	$0
# Inline 
snippet inl
	src_${1:language}${2:[${3::exports code}]}{${4:code}}
# Inline source
snippet srci
	src_${1:language}[${2:header}]{${0:body}}
# Jupyter
snippet jupyter
	#+begin_src jupyter-${1:$$(yas-choose-value '("python" "julia" "R"))}${2: :session $3}${4: :async yes}
	$0
	#+end_src
# Matrix (latex)
snippet matrix
	\left \(
	\begin{array}{${1:ccc}}
	${2:v1 & v2} \\
	$0
	\end{array}
	\right \)
# Name
snippet name
	#+name: $0
# Quote
snippet quote
	#+begin_quote
	$0
	#+end_quote
# Source
snippet src
	#+begin_src $1
	$0
	#+end_src
# Todo
snippet todo
	TODO ${1:task description}
# Verse
snippet verse
	#+begin_verse
	$0
	#+end_verse
# Atrribute Width
snippet #+attr_html:width
	#+attr_html: :width ${1:500px}
./snippets/pandoc.snippets	[[[1
1
extends markdown
./snippets/perl.snippets	[[[1
367
# #!/usr/bin/perl
snippet #!
	#!/usr/bin/env perl

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name} {
		${0}
	}
# Conditional
snippet if
	if (${1}) {
		${0}
	}
# Conditional if..else
snippet ife
	if (${1}) {
		${2}
	}
	else {
		${0}
	}
# Conditional if..elsif..else
snippet ifee
	if (${1}) {
		${2}
	}
	elsif (${3}) {
		${4:# elsif...}
	}
	else {
		${0}
	}
snippet eif
	elsif (${1}) {
		${0}
	}
# Conditional One-line
snippet xif
	$1 if $0;
# Unless conditional
snippet unless
	unless (${1}) {
		${0}
	}
# Unless conditional One-line
snippet xunless
	$1 unless $0;
# Try/Except
snippet eval
	local $@;
	eval {
		${1:# do something risky...}
	};
	if (my $e = $@) {
		${0:# handle failure...}
	}
# While Loop
snippet wh
	while (${1}) {
		${0}
	}
# While Loop One-line
snippet xwh
	$1 while $0;
# C-style For Loop
snippet cfor
	for (my $${2:var} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${0}
	}
# For loop one-line
snippet xfor
	$1 for @$0;
# Foreach Loop
snippet for
	foreach my $${1:x} (@${2:array}) {
		${0}
	}
# Foreach Loop One-line
snippet fore
	$1 foreach @$0;
# Package
snippet package
	package ${1:`expand('%:p:s?.*lib/??:r:gs?/?::?')`};
	use strict;
	use warnings;

	${0}

	1;

	__END__
# Package syntax perl >= 5.14
snippet packagev514
	package ${1:`expand('%:p:s?.*lib/??:r:gs?/?::?')`} ${2:0.99};
	use v5.14;
	use warnings;

	${0}

	1;

	__END__
#moose
snippet moose
	use Moose;
	use namespace::autoclean;
	${1:#}BEGIN {extends '${2:ParentClass}'};

	${0}
# parent
snippet parent
	use parent qw(${0:Parent Class});
# Read File
snippet slurp
	my $${1:var} = do { local $/; open my $file, '<', "${2:file}"; <$file> };
	${0}
# strict warnings
snippet strwar
	use strict;
	use warnings;
# older versioning with perlcritic bypass
snippet vers
	## no critic
	our $VERSION = '${0:version}';
	eval $VERSION;
	## use critic
# new 'switch' like feature
snippet switch
	use feature 'switch';

# Anonymous subroutine
snippet asub
	sub {
		${0}
	}



# Begin block
snippet begin
	BEGIN {
		${0}
	}

# call package function with some parameter
snippet pkgmv
	__PACKAGE__->${1:package_method}(${0:var})

# call package function without a parameter
snippet pkgm
	__PACKAGE__->${0:package_method}()

# call package "get_" function without a parameter
snippet pkget
	__PACKAGE__->get_${0:package_method}()

# call package function with a parameter
snippet pkgetv
	__PACKAGE__->get_${1:package_method}(${0:var})

# complex regex
snippet qrx
	qr/
	     ${0:regex}
	/xms

#simpler regex
snippet qr/
	qr/${0:regex}/x

#given
snippet given
	given ($${1:var}) {
		${2:# cases}
		${0:# default}
	}

# switch-like case
snippet when
	when (${1:case}) {
		${0}
	}

# hash slice
snippet hslice
	@{ ${1:hash}  }{ ${0:array} }


# map
snippet map
	map {  ${0: body }    }  ${1: @array } ;



# Pod stub
snippet ppod
	=head1 NAME

	${1:ClassName} - ${2:ShortDesc}

	=head1 SYNOPSIS

	  use $1;

	  ${3:# synopsis...}

	=head1 DESCRIPTION

	${0:# longer description...}


	=head1 INTERFACE


	=head1 DEPENDENCIES


	=head1 SEE ALSO


# Heading for a subroutine stub
snippet psub
	=head2 ${1:MethodName}

	${0:Summary....}

# Heading for inline subroutine pod
snippet psubi
	=head2 ${1:MethodName}

	${0:Summary...}


	=cut
# inline documented subroutine
snippet subpod
	=head2 $1

	Summary of $1

	=cut

	sub ${1:subroutine_name} {
		${0}
	}
# Subroutine signature
snippet parg
	=over 2

	=item
	Arguments


	=over 3

	=item
	C<${1:DataStructure}>

	  ${2:Sample}


	=back


	=item
	Return

	=over 3


	=item
	C<${0:...return data}>


	=back


	=back



# Moose has
snippet has
	has ${1:attribute} => (
		is	    => '${2:ro|rw}',
		isa 	=> '${3:Str|Int|HashRef|ArrayRef|etc}',
		default => sub {
			${4:defaultvalue}
		},
		${0:# other attributes}
	);


# override
snippet override
	override ${1:attribute} => sub {
		${2:# my $self = shift;};
		${0:# my ($self, $args) = @_;};
	};


# use test classes
snippet tuse
	use Test::More;
	use Test::Deep; # (); # uncomment to stop prototype errors
	use Test::Exception;

# local test lib
snippet tlib
	use lib qw{ ./t/lib };

#test methods
snippet tmeths
	$ENV{TEST_METHOD} = '${0:regex}';

# runtestclass
snippet trunner
	use ${0:test_class};
	$1->runtests();

# Test::Class-style test
snippet tsub
	sub t${1:number}_${2:test_case} :Test(${3:num_of_tests}) {
		my $self = shift;
		${0}

	}

# Test::Routine-style test
snippet trsub
	test ${1:test_name} => { description => '${2:Description of test.}'} => sub {
		my ($self) = @_;
		${0}
	};

#prep test method
snippet tprep
	sub prep${1:number}_${2:test_case} :Test(startup) {
		my $self = shift;
		${0}
	}

# cause failures to print stack trace
snippet debug_trace
	use Carp; # 'verbose';
	# cloak "die"
	# warn "warning"
	$SIG{'__DIE__'} = sub {
		require Carp; Carp::confess
	};

snippet dump
	use Data::Dump qw(dump);
	warn dump ${1:variable}

snippet ddp
	use DDP;
	p ${1:variable}

snippet subtest
	subtest '${1: test_name}' => sub {
		${2}
	};
./snippets/perl6.snippets	[[[1
116
# shebang
snippet #!
	#!/usr/bin/env perl6

# Hash Pointer
snippet .
	 =>
# Function
snippet sub
	sub ${1:function_name}(${2:Str $var}) {
		${3}
	}
snippet mul
	multi ${1:function_name}(${2:Str $var}) {
		${3}
	}
# Conditional
snippet if
	if ${1} {
		${2}
	}
# Conditional if..else
snippet ife
	if ${1} {
		${2}
	}
	else {
		${3}
	}
snippet eif
	elsif ${1} {
		${2}
	}
# Conditional One-line
snippet xif
	${1} if $2;
# Unless conditional
snippet unless
	unless ${1} {
		${2}
	}
# Unless conditional One-line
snippet xunless
	${1} unless $2;
# Ternary conditional
snippet tc
	$1 ?? ${2:value-if-true} !! ${3:value-if-false};
# given - when (perl6 switch)
snippet switch
	given ${1:$var} {
	  when $2 {
		  ${3:# code block ...}
	  }
	  ${4}
	  default {
		  ${5}
	  }
	}
# 'loop' - C's for.
snippet loop
	loop (my ${1:$i} = 0; $$1 < ${2:count}; $$1++) {
		${3}
	}
# for loop
snippet for
	for ${1:@array} -> ${2:$variable} {
		${3}
	}
# While Loop
snippet wh
	while ${1} {
		${2}
	}
# Repeat while and repean until
snippet rp
	repeat {
		${1}
	} ${2:while|until} ${3};
# classes ..
snippet cl
	${1:my} class ${2:ClassName} ${3:is|does Parent|Role}{
		${4}
	}
snippet has
	has ${1:Type} ${2:$!identifier};
snippet mth
	method ${1:method_name}(${2:$attr}) {
		${3}
	}
snippet pmth
	method ${1:!}${2:method_name}(${3:$attr}) {
		${4}
	}
snippet smth
	submethod ${1:submethod_name}(${2:$attr}) {
		${3}
	}
# Tests
snippet test
	use v6;
	use Test;
	${1:use lib 'lib';}

	plan ${2:$num-tests};

# IO
snippet slurp
	my ${1:$var} = "${2:filename}".IO.slurp;
snippet rfile
	for "${1:filename}".IO.lines -> $line {
		${2}
	}
snippet open
	my $fh = open "${1:filename}", ${2::r|:w|:a};
	${3:# actions};
	$fh.close;
./snippets/phoenix.snippets	[[[1
16
snippet cont
	defmodule ${1:AppName}Web.${2:ControllerName}Controller do
		use $1Web, :controller
		
		${3}
	end

snippet view
	defmodule ${1:AppName}Web.${2:ViewName}View do
		use $1Web, :view
	end

snippet chan
	defmodule ${1:AppName}Web.${2:ChannelName}Channel do
		use $1Web, :channel
	end
./snippets/php.snippets	[[[1
690
snippet <?
	<?php

	${0:${VISUAL}}
snippet dst "declare(strict_types=1)"
	declare(strict_types=${1:1});
snippet ec
	echo ${0};
snippet <?e
	<?php echo ${0} ?>
# this one is for php5.4
snippet <?=
	<?=${0}?>
snippet ?=
	<?= ${0} ?>
snippet ?
	<?php ${0} ?>
snippet ?f
	<?php foreach ($${1:vars} as $${2:$var}): ?>
		${0:${VISUAL}}
	<?php endforeach ?>
snippet ?i
	<?php if ($${1:var}): ?>
		${0:${VISUAL}}
	<?php endif ?>
snippet ns
	namespace ${1:Foo\Bar\Baz};
	
	${0:${VISUAL}}
snippet c
	class ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
snippet i
	interface ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
snippet t.
	\$this->
snippet f
	function ${1}(${3})
	{
		${0:${VISUAL}}
	}
# method
snippet m
	${1:protected} function ${2:foo}()
	{
		${0:${VISUAL}}
	}
snippet sm "PHP Class Setter"
	/**
	 * Sets the value of ${1:foo}
	 *
	 * @param ${2:string} $$1 ${3:description}
	 *
	 * @return ${4:`vim_snippets#Filename()`}
	 */
	${5:public} function set${6:$1}(${7:$2 }$$1)
	{
		$this->${8:$1} = $$1;

		return $this;
	}
snippet gm "PHP Class Getter Setter"
	/**
	 * Gets the value of ${1:foo}
	 *
	 * @return ${2:string}
	 */
	${3:public} function get${4:$1}()
	{
		return $this->${5:$1};
	}
#setter
snippet $s
	${1:$foo}->set${2:Bar}(${0});
#getter
snippet $g
	${1:$foo}->get${0:Bar}();
# Tertiary conditional
snippet =?:
	$${1:foo} = ${2:true} ? ${3:a} : ${0};
snippet ?:
	${1:true} ? ${2:a} : ${0}
snippet t "$retVal = (condition) ? a : b"
	$${1:retVal} = ($2) ? ${3:a} : ${4:b};
# Predefined variables
snippet C
	$_COOKIE['${1:variable}']
snippet E
	$_ENV['${1:variable}']
snippet F
	$_FILES['${1:variable}']
snippet G "_GET array"
	$_GET['${1:variable}']
snippet P "_POST array"
	$_POST['${1:variable}']
snippet R
	$_REQUEST['${1:variable}']
snippet S
	$_SERVER['${1:variable}']
snippet SS
	$_SESSION['${1:variable}']
snippet get "get"
	$_GET['${1}']
snippet post "post"
	$_POST['${1}']
snippet session "session"
	$_SESSION['${1}']
# the following are old ones
snippet inc
	include '${1:file}';
snippet inc1
	include_once '${1:file}';
snippet req
	require '${1:file}';
snippet req1
	require_once '${1:file}';
# Start Docblock
snippet /*
	/**
	 * ${0}
	 */
# Class - post doc
snippet doc_cp
	/**
	 * ${1:undocumented class}
	 *
	 * @package ${2:default}
	 * @subpackage ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
# Class Variable - post doc
snippet doc_vp
	/**
	 * ${1:undocumented class variable}
	 *
	 * @var ${2:string}
	 */
# Class Variable
snippet doc_v
	/**
	 * ${3:undocumented class variable}
	 *
	 * @var ${4:string}
	 */
	${1:var} $${2};

# Class attribute with short comment
snippet att
	/** @var ${3:string} */
	${1:public} $${2};

# Class
snippet doc_c
	/**
	 * ${3:undocumented class}
	 *
	 * @package ${4:default}
	 * @subpackage ${5:default}
	 * @author ${6:`g:snips_author`}
	 */
	${1:}class ${2:}
	{
		${0:${VISUAL}}
	} // END $1class $2
# Constant Definition - post doc
snippet doc_dp
	/**
	 * ${1:undocumented constant}
	 */
# Constant Definition
snippet doc_d
	/**
	 * ${3:undocumented constant}
	 */
	define(${1}, ${2});
# Function - post doc
snippet doc_fp
	/**
	 * ${1:undocumented function}
	 *
	 * @return ${2:void}
	 * @author ${3:`g:snips_author`}
	 */
# Function signature
snippet doc_s
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 */
	${1}function ${2}(${3});
# Function
snippet doc_f
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 */
	${1}function ${2}(${3})
	{${0}
	}
# Header
snippet doc_h
	/**
	 * ${1}
	 *
	 * @author ${2:`g:snips_author`}
	 * @version ${3:$Id$}
	 * @copyright ${4:$2}, `strftime('%d %B, %Y')`
	 * @package ${0:default}
	 */
snippet doc_i "interface someClass {}"
	/**
	 * $1
	 * @package ${2:default}
	 * @author ${3:`!v g:snips_author`}
	 **/
	interface ${1:someClass}
	{${4}
	}
snippet inheritdoc "@inheritdoc docblock"
	/**
	 * {@inheritdoc}
	 */
# Interface
snippet interface
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
	interface ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# Trait
snippet trait
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
	trait ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# class ...
snippet class
	/**
	 * ${1}
	 */
	class ${2:`vim_snippets#Filename()`}
	{
		${3}
		/**
		 * ${4}
		 */
		${5:public} function ${6:__construct}(${7:argument})
		{
			${0}
		}
	}
snippet nc
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};

	${2:abstract }class ${3:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# define(...)
snippet def "define('VARIABLE_NAME', 'definition')"
	define('${1:VARIABLE_NAME}', ${2:'definition'});
# defined(...)
snippet def?
	${1}defined('${2}')
snippet wh "while (condition) { ... }"
	while ($1) {
		${0:${VISUAL}}
	}
snippet do "do { ... } while (condition)"
	do {
		${0:${VISUAL}}
	} while (${1});
snippet if "if (condition) { ... }"
	if (${1}) {
		${0:${VISUAL}}
	}
snippet ifn "if (!condition) { ... }"
	if (!${1}) {
		${0:${VISUAL}}
	}
snippet ifil "<?php if (condition): ?> ... <?php endif; ?>"
	<?php if (${1}): ?>
		${0:${VISUAL}}
	<?php endif; ?>
snippet ife "if (cond) { ... } else { ... }"
	if (${1}) {
		${0:${VISUAL}}
	} else {
		${2}
	}
snippet ifeil "<?php if (condition): ?> ... <?php else: ?> ... <?php endif; ?>"
	<?php if (${1}): ?>
		${0:${VISUAL}}
	<?php else: ?>
		${2}
	<?php endif; ?>
snippet el "else { ... }"
	else {
		${0:${VISUAL}}
	}
snippet eif "elseif(condition) { ... }"
	elseif (${1}) {
		${0:${VISUAL}}
	}
snippet switch "switch($var) { case 'xyz': ... default: .... }"
	switch ($${1:variable}) {
		case '${2:value}':
			${3}
			break;
		${0}
		default:
			${4}
			break;
	}
snippet case "case 'value': ... break"
	case '${1:value}':
		${0:${VISUAL}}
		break;
snippet for "for ($i = 0; $i < $count; $i++) { ... }"
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${0:${VISUAL}}
	}
snippet foreach "foreach ($var as $value) { .. }"
	foreach ($${1:variable} as $${2:value}) {
		${0:${VISUAL}}
	}
snippet foreachil "<?php foreach ($var as $value): ?>  ... <?php endforeach; ?>"
	<?php foreach ($${1:variable} as $${2:value}): ?>
		${0:${VISUAL}}
	<?php endforeach; ?>
snippet foreachk "foreach ($var as $key => $value) { .. }"
	foreach ($${1:variable} as $${2:key} => $${3:value}) {
		${0:${VISUAL}}
	}
snippet foreachkil "<?php foreach ($var as $key => $value): ?>  ... <?php endforeach; ?>"
	<?php foreach ($${1:variable} as $${2:key} => $${3:value}): ?>
		${0:<!-- html... -->}
	<?php endforeach; ?>
snippet array "$... = ['' => ]"
	$${1:arrayName} = ['${2}' => ${3}];
snippet try "try { ... } catch (Exception $e) { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:Exception} $e) {
	}
# lambda with closure
snippet lambda
	${1:static }function (${2:args}) use (${3:&$x, $y /*put vars in scope (closure) */}) {
		${0}
	};
# pre_dump();
snippet pd
	echo '<pre>'; var_dump(${0}); echo '</pre>';
# pre_dump(); die();
snippet pdd
	echo '<pre>'; var_dump(${1}); echo '</pre>'; die(${0:});
snippet vd
	var_dump(${0});
snippet vdd
	var_dump(${1}); die(${0:});
snippet pr
	print_r(${0});
snippet prs
	print_r(${0}, 1);
snippet vdf
	error_log(print_r($${1:foo}, true), 3, '${2:/tmp/debug.log}');
snippet http_redirect
	header ("HTTP/1.1 301 Moved Permanently");
	header ("Location: ".URL);
	exit();
snippet log "error_log(var_export($var, true));"
	error_log(var_export(${1}, true));
snippet var "var_export($var)"
	var_export(${1});
snippet ve "Dumb debug helper in HTML"
	echo '<pre>' . var_export(${1}, 1) . '</pre>';
snippet pc "Dumb debug helper in cli"
	var_export($1);$0
# Getters & Setters
snippet gs "PHP Class Getter Setter"
	/**
	 * Gets the value of ${1:foo}
	 *
	 * @return ${2:string}
	 */
	public function get${3:$1}()
	{
		return $this->${4:$1};
	}

	/**
	 * Sets the value of $1
	 *
	 * @param $2 $$1 ${5:description}
	 *
	 * @return ${6:`vim_snippets#Filename()`}
	 */
	public function set$3(${7:$2 }$$1)
	{
		$this->$4 = $$1;
		return $this;
	}
# anotation, get, and set, useful for doctrine
snippet ags
	/**
	 * ${1:description}
	 *
	 * @${0}
	 */
	${2:protected} $${3:foo};

	public function get${4:$3}()
	{
		return $this->$3;
	}

	public function set$4(${5:$4 }$${6:$3})
	{
		$this->$3 = $$6;
		return $this;
	}
snippet rett
	return true;
snippet retf
	return false;
snippet am
	$${1:foo} = array_map(function($${2:v}) {
		${0}
		return $$2;
	}, $$1);
snippet aw
	array_walk($${1:foo}, function(&$${2:v}, $${3:k}) {
		$$2 = ${0};
	});
# static var assign once
snippet static_var
	static $${1} = null;
	if (is_null($$1)){
		$$1 = ${2};
	}
snippet CSVWriter
	<?php
	
	class CSVWriter {
		public function __construct($file_or_handle, $sep = "\t", $quot = '"'){
			$args = func_get_args();
			$mode = isset($opts['mode']) ? $opts['mode'] : 'w';
	
			$this->f =
				is_string($file_or_handle)
				? fopen($file_or_handle, $mode)
				: $file_or_handle;
	
			$this->fputcsv_args = [$this->f, null, $sep, $quot];
	
			if (!$this->f) throw new Exception('bad file descriptor');
		}
	
		public function write($row){
			$this->fputcsv_args[1] =& $row;
			call_user_func_array('fputcsv', $this->fputcsv_args);
		}
	
		public function close(){
			if (!is_null($this->f))
				fclose($this->f);
			$this->f = null;
		}
	
		public function __destruct(){
			$this->close();
		}
	
	}
snippet CSVIterator
	
	// http://snipplr.com/view.php?codeview&id=1986 // modified
	class CSVIterator implements Iterator
	{	
		private $f;
		private $curr;
		private $rowCounter;
	
		 /* opts keys:
			* row_size
			* escape
			* enclosure
			* delimiter
			*/
		public function __construct( $file_or_handle, $opts = [4096, ','] )
		{
			$d = function($n) use(&$opts){ return isset($opts[$n]) ? $opts[$n] : false; };
	
			$this->combine = $d('combine');
			$this->headers = $d('headers');
			$this->headerCheckFunction = $d('header_check_function');
	
			$this->f =
				is_string($file_or_handle)
				? fopen( $file_or_handle, 'r' )
				: $file_or_handle;
			if (!$this->f) throw new Exception('bad file descriptor');
			$this->fgetcsv_args = [
					$this->f,
					isset($opts['row_size']) ? $opts['row_size'] : 4096,
					isset($opts['delimiter']) ? $opts['delimiter'] : ',',
					isset($opts['enclosure']) ? $opts['enclosure'] : '"',
					isset($opts['escape']) ? $opts['escape'] : '\\',
			];
			$this->start();
		}
	
		protected function readRow(){
			$this->curr = call_user_func_array('fgetcsv', $this->fgetcsv_args );
			$this->rowCounter++;
			if ($this->rowCounter == 1){
				$this->processHeader();
			} elseif ($this->curr) {
				$this->processRow();
			}
		}
	
		public function processHeader(){
			if ($this->headers || $this->combine){
				$this->header = $this->curr;
				if ($this->headerCheckFunction){
					$f = $this->headerCheckFunction;
					$f($this->header);
				}
				$this->readRow();
			}
		}
	
		public function processRow(){
			if ($this->combine)
				$this->curr = array_combine($this->header, $this->curr);
		}
	
		public function start(){
			$this->rowCounter = 0;
			rewind( $this->f );
			$this->readRow();
		}
	
		public function rewind()
		{
			$this->start();
		}
	
		public function current()
		{
			$curr = $this->curr;
			$this->readRow();
			return $curr;
		}
	
		public function key()
		{
			return $this->rowCounter;
		}
	
		public function next()
		{
			return $this->curr;
		}
	
		public function valid(){
			if( !$this->next() )
			{
				fclose( $this->f );
				return FALSE;
			}
			return TRUE;
		}
	
	} // end class
# phpunit
snippet ase "$this->assertEquals($a, $b)"
	$this->assertEquals(${1:$expected}, ${2:$actual});
snippet asne "$this->assertNotEquals($a, $b)"
	$this->assertNotEquals(${1:$expected}, ${2:$actual});
snippet asf "$this->assertFalse($a)"
	$this->assertFalse(${1});
snippet ast "$this->assertTrue($a)"
	$this->assertTrue(${1});
snippet asfex "$this->assertFileExists('path/to/file')"
	$this->assertFileExists(${1:'path/to/file'});
snippet asfnex "$this->assertFileNotExists('path/to/file')"
	$this->assertFileNotExists(${1:'path/to/file'});
snippet ascon "$this->assertContains($needle, $haystack)"
	$this->assertContains(${1:$needle}, ${2:$haystack});
snippet asncon "$this->assertNotContains($needle, $haystack)"
	$this->assertNotContains(${1:$needle}, ${2:$haystack});
snippet ascono "$this->assertContainsOnly($needle, $haystack)"
	$this->assertContainsOnly(${1:$needle}, ${2:$haystack});
snippet asconoi "$this->assertContainsOnlyInstancesOf(Example::class, $haystack)"
	$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});
snippet ashk "$this->assertArrayHasKey($key, $array)"
	$this->assertArrayHasKey(${1:$key}, ${2:$array});
snippet asnhk "$this->assertArrayNotHasKey($key, $array)"
	this->assertArrayNotHasKey(${1:$key}, ${2:$array});
snippet ascha "$this->assertClassHasAttribute($name, Example::class)"
	$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);
snippet asi "$this->assertInstanceOf(Example::class, $actual)"
	$this->assertInstanceOf(${1:Example}::class, ${2:$actual});
snippet asit "$this->assertInternalType('string', $actual)"
	$this->assertInternalType(${1:'string'}, ${2:actual});
snippet asco "$this->assertCount($count, $haystack)"
	$this->assertCount(${1:$expectedCount}, ${2:$haystack});
snippet asnco "$this->assertNotCount($count, $haystack)"
	$this->assertNotCount(${1:$count}, ${2:$haystack});
snippet assub "$this->assertArraySubset($subset, $array)"
	$this->assertArraySubset(${1:$subset}, ${2:$array});
snippet asnu "$this->assertNull($a)"
	$this->assertNull(${1});
snippet asnnu "$this->assertNotNull($a)"
	$this->assertNotNull(${1});
snippet test "public function testXYZ() { ... }"
	public function test${1}()
	{
		${0:${VISUAL}}
	}
snippet setup "protected function setUp() { ... }"
	protected function setUp()
	{
		${0:${VISUAL}}
	}
snippet teardown "protected function tearDown() { ... }"
	protected function tearDown()
	{
		${0:${VISUAL}}
	}
snippet proph "$observer = $this->prophesize(SomeClass::class);"
	$${1:observer} = $this->prophesize(${2:SomeClass}::class);
snippet mock "$mock = $this->createMock(SomeClass::class);"
	$${1:mock} = $this->createMock(${2:SomeClass}::class);
snippet exp "phpunit expects"
	expects($this->${1:once}())
		->method('${2}')
		->with(${3})
		->willReturn(${4});
snippet testcmt "phpunit comment with group"
	/**
	* @group ${1}
	*/
snippet fail "$this->fail()"
	$this->fail(${1});
snippet marki "$this->markTestIncomplete()"
	$this->markTestIncomplete(${1});
snippet marks "$this->markTestSkipped()"
	$this->markTestSkipped(${1});
# end of phpunit snippets
snippet te "throw new Exception()"
	throw new ${1:Exception}("${2:Error Processing Request}");
snippet fpc "file_put_contents" b
	file_put_contents(${1:file}, ${2:content}${3:, FILE_APPEND});$0
snippet sr "str_replace"
	str_replace(${1:search}, ${2:replace}, ${3:subject})$0
snippet ia "in_array"
	in_array(${1:needle}, ${2:haystack})$0
snippet is "isset"
	isset(${1:var})$0
snippet isa "isset array"
	isset($${1:array}[${2:key}])$0
snippet in "is_null"
	is_null($${1:var})$0
snippet fe "file_exists"
	file_exists(${1:file})$0
snippet id "is_dir"
	is_dir(${1:path})$0
./snippets/plsql.snippets	[[[1
109
# create package spec
snippet ps
	create or replace package ${1:name}
	as
		${0:-- spec}
	end; -- end of package spec $1
# create package body
snippet pb
	create or replace package body ${1:name}
	as
		$0
	end; -- end of package body $1;
# package procedure spec
snippet pps
	procedure ${1:name}(${0:args});
# package procedure body
snippet ppb
	procedure ${1:name}(${2:args})
	as
	begin
		$0
	end $2;
# package function spec
snippet pfs
	function ${1:name}(${2:args})
	  return ${0:type};
# package function body
snippet pfb
	function ${1:name}(${2:args})
	  return ${3:type}
	as
		l_res	$3;
	begin
		$0;
		return l_res;
	end $1;
# snow errors
snippet err
	show errors;
# proc/func in parameter
snippet p
	${1:name} ${2:in} ${3:type} ${0: := null}
# package type: record
snippet tr
	type tr_${1:name} is record (${0:/* columns */});
# package type: nested table
snippet tt
	type tt_${1:name} is table of tr_${0:name};
# package type: indexed table
snippet tti
	type tt_${1:name} is table of tr_${0:name} index by binary_integer;
# proc/func comment
snippet doc
	/*
	 *	${0: comment ...}
	 */
# plsql block
snippet beg
	begin
		${0}
	end;
# plsql block with declare part
snippet dec
	declare
		${1}
	begin
		${0}
	end;
# return pipe row
snippet rpipe
	for ${1:i} in 1 .. ${0:l_res}.count loop
		pipe row( $2($1) );
	end loop;
	return;
# bulk collect
snippet bc
	bulk collect into ${0}
# local variable
snippet l
	l_${1}		${0:number};
# output
snippet log
	dbms_output.put_line('${0}');
# for loop
snippet for
	for ${1:i} in ${2:1}..${3:42} loop
		${0}
	end loop;
# for loop with select
snippet fors
	for ${1:rec} in (${2: select}) loop
		${0}
	end loop;
# for loop with collection
snippet forc
	for ${1:i} in ${2:l_var}.first .. $2.last loop
		${0: -- dbms_output.put_line($2($1)); }
	end loop;
# if
snippet if
	if ${1} then
		${0}
	end if;
snippet ife
	if ${1} then
		${2}
	else
		${0}
	end if;
./snippets/po.snippets	[[[1
5
snippet msg
	msgid "${1}"
	msgstr "${2}"

	${0}
./snippets/processing.snippets	[[[1
705
#BASICS
# doc
snippet doc
	/**
	 *  ${1:Description}
	 *
	 *	@author ${2:name}
	 *	@since  ${3:`strftime("%d/%m/%y %H:%M:%S")`}
	 */
	${0}
# doc comment
snippet docc
	/**
	 *	${1:@private}$0
	 */
	${0}
# class
snippet class
	${1:public }class ${2:`fnamemodify(bufname("%"),":t:r")`} ${3:extends}
	{

		//--------------------------------------
		//  CONSTRUCTOR
		//--------------------------------------

		public $2 (${4:arguments}) {
			${0:// expression}
		}
	}
# package
snippet package
	/**
	 *  ${1:Description}
	 *
	 *	@author ${2:$TM_FULLNAME}
	 *	@since  ${3:`strftime("%d/%m/%y %H:%M:%S")`}
	 */

	package ${0:package};
# function
snippet fun
	${1:void/private/protected/public}${2: static} ${3:name}(${4}) {
		${5://if not void return null;}
	}
	${0}
snippet fn
	${1:void }${2:name}(${3}) {
		${4://if not void return null;}
	}
	${0}
#	constant
snippet const
	static final ${1:Object} ${2:VAR_NAM} = ${0};
# var
snippet var
	${1:private/public }${2:static }${3:String} ${4:str}${5: =}${0:value};
# var objects
snippet obj
	${1:private/public }${2:Object} ${3:o}${4: = new }$2(${0});
#loop for
snippet for
	for (int ${2:i} = 0; $2 < ${1:Things}.length; $2${3:++}) {
		${0:$1[$2]}
	};
#loop while
snippet wh
	while ($1) {
		${0}
	}
#break
snippet break
	break ${1:label};
#case
snippet case
	case ${1:expression} :
		${0}
	break;
#default
snippet default
	default :
		${1}
	break;
#switch
snippet switch
	switch(${1:expression}) {
		case '${3:case}':
			${4}
			break;
		${0}
		default:
			${2}
	}
#try
snippet try
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
	}
#try catch finally
snippet tryf
	try {
		${0:${VISUAL}}
	} catch(${1:Exception} ${2:e}) {
	} finally {
	}
#throw
snippet throw
	throw new ("${1:Exception()}");
#ternary
snippet ?
	? ${1:trueExpression} : ${2:falseExpression}
	${0}
snippet if
	if (${1:true}) {${0}}
# if ... else
snippet ife
	if (${1:true}) {${2}}
	else{${0}}
#get
snippet get
	public ${1:String} get${2}() {
		return ${0:fieldName};
	}
#set
snippet set
	public void set${1}(${0:String} new${1}) {
		${1:fieldName} = new${1};
	}
#printIn
snippet println
	println("${1:`fnamemodify(bufname("%"),":t:r")`}::${2:method}() "${3: +} ${0});
#println string
snippet pr
	println("${0}");
#setup draw
snippet setup
	void setup(){
		${1}
	}

	void draw(){
		${0}
	}
#setup OPENGL
snippet opengl
	import processing.opengl.*;
	import javax.media.opengl.*;

	PGraphicsOpenGL pgl;
	GL gl;

	void setup(){
		size( ${1:300}, ${2:300}, OPENGL );
		colorMode( RGB, 1.0 );
		hint( ENABLE_OPENGL_4X_SMOOTH );
		pgl = (PGraphicsOpenGL) g;
		gl = pgl.gl;
		gl.setSwapInterval(1);
		initGL();
		${3}
	}

	void draw(){
		pgl.beginGL();
			${4}
		pgl.endGL();
		getOpenGLErrors();
	}

	void initGL(){
		${0}
	}

	void getOpenGLErrors(){
		int error = gl.glGetError();
		switch (error){
			case 1280 :
				println("GL_INVALID_ENUM - An invalid enumerant was passed to an OpenGL command.");
			break;
			case 1282 :
				println("GL_INVALID_OPERATION - An OpenGL command was issued that was invalid or inappropriate for the current state.");
			break;
			case 1281 :
				println("GL_INVALID_VALUE - A value was passed to OpenGL that was outside the allowed range.");
			break;
			case 1285 :
				println("GL_OUT_OF_MEMORY - OpenGL was unable to allocate enough memory to process a command.");
			break;
			case 1283 :
				println("GL_STACK_OVERFLOW - A command caused an OpenGL stack to overflow.");
			break;
			case 1284 :
				println("GL_STACK_UNDERFLOW - A command caused an OpenGL stack to underflow.");
			break;
			case 32817 :
				println("GL_TABLE_TOO_LARGE");
			break;
		}
	}

#GL Functions
snippet gl begin gl
	pgl.beginGL();
		${0}
	pgl.endGL();
snippet gl gl swap interval
	// specify the minimum swap interval for buffer swaps.
	gl.setSwapInterval(${0:interval});
snippet gl gl call list
	// execute a display list
	gl.glCallList(${0:list});
snippet gl gl gen buffers
	// import java.nio.IntBuffer;
	// import java.nio.FloatBuffer;
	// import com.sun.opengl.util.BufferUtil;

	// You might need to create four buffers to store vertext data, normal data, texture coordinate data, and indices in vertex arrays
	IntBuffer bufferObjects = IntBuffer.allocate(${1:4});
	gl.glGenBuffers($1, bufferObjects);

	int vertexCount = ${2:3};
	int numCoordinates = ${0:3};
	// vertexCount * numCoordinates
	FloatBuffer vertices = BufferUtil.newFloatBuffer(vertexCount * numCoordinates);
	float[] v = {0.0f, 0.0f, 0.0f,
							 1.0f, 0.0f, 0.0f,
							 0.0f, 1.0f, 1.0f};
	vertices.put(v);

	// Bind the first buffer object ID for use with vertext array data
	gl.glBindBuffer(GL.GL_ARRAY_BUFFER, bufferObjects.get(0));
	gl.glBufferData(GL.GL_ARRAY_BUFFER, vertexCount * numCoordinates * BufferUtil.SIZEOF_FLOAT, vertices, GL.GL_STATIC_DRAW);
snippet gl gl bind buffer
	${0:// A buffer ID of zero unbinds a buffer object}
	gl.glBindBuffer(GL.GL_ARRAY_BUFFER, ${1:0});
snippet gl gl delete buffers
	${0:// Parameters are the same for glGenBuffers}
	gl.glDeleteBuffers(${1:4}, ${2:bufferObjects});
snippet gl gl depth mask
	// enable or disable writing into the depth buffer
	gl.glDepthMask(${0:flag});
snippet gl gl load identity
	// replaces the top of the active matrix stack with the identity matrix
	gl.glLoadIdentity();
snippet gl gl tex coord 2f
	// set the current texture coordinates - 2 floats
	gl.glTexCoord2f(${1:0.0f}, ${0:0.0f});
snippet gl gl vertex 2f
	gl.glVertex2f(${1:0.0f}, ${0:0.0f});
snippet gl gl vertex 3f
	gl.glVertex3f(${1:0.0f}, ${2:0.0f}, ${0:0.0f});
snippet gl gl translate f
	// multiply the current matrix by a translation matrix
	gl.glTranslatef(${1:x}, ${2:y}, ${0:z});
snippet gl gl rotate f
	// rotate, x-axis, y-axis, z-axiz
	gl.glRotatef(${1:angle}, ${2:x}, ${3:y}, ${0:z});
snippet gl gl scale f
	// multiply the current matrix by a general scaling matrix
	gl.glScalef(${1:x}, ${2:y}, ${0:z});
snippet gl gl color 4f
	gl.glColor4f(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});
snippet gl gl clear color
	gl.glClearColor(${1:red}, ${2:green}, ${3:blue}, ${0:alpha});
snippet gl gl color 3f
	gl.glColor3f(${1:red}, ${2:green}, ${0:blue});
snippet gl gl push matrix
	// spush and pop the current matrix stack
	gl.glPushMatrix();
	${0}
	gl.glPopMatrix();
snippet gl gl gen lists
	gl.glGenLists(${0:1})
snippet gl gl flush
	// Empties buffers. Call this when all previous issues commands completed
	gl.glFlush();
	${0}
snippet gl gl get error
	println(gl.glGetError());
snippet gl gl clear
	gl.glClear(${1:GL.GL_COLOR_BUFFER_BIT}${2: | }${0:GL.GL_DEPTH_BUFFER_BIT});

#frame operations
snippet frameRate
	frameRate(${1:30});
	${0}
snippet saveFrame
	saveFrame("${1:filename-####}${0:.ext}");

#size
snippet size normal
	size(${1:200}, ${2:200}${0:, P3D});
snippet size opengl
	size(${1:200}, ${2:200}${0:, OPENGL});

#PRIMITIVES
#color
snippet color
	color ${1:c}${2: = color(}${3:value1, }${4:value2, }${0:value3)};
#char
snippet char
	char ${1:m}${2: = "}${0:char"};
#float
snippet float
	float ${1:f}${2: = }${0:0.0f};
#int
snippet int
	int ${1:f}${2: = }${0:0};
#boolean
snippet boolean
	boolean ${1:b}${2: = }${0:true};
#byte
snippet byte
	byte ${1:b}${2: = }${0:127};
#string
snippet string
	String ${1:str}${2: = "}${0:CCCP"};
#array
snippet array
	${1:int}[] ${2:numbers}${3: = new $1}[${0:length}];
#object
snippet object
	${1:Object} ${2:o}${3: = new $1}(${0});

#curve
snippet curve
	curve(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});
snippet curve 3D
	curve(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${6:z2}, ${7:x3}, ${8:y3}, ${9:z3}, ${10:x4}, ${11:y4}, ${0:z4});
snippet curveDetail
	curveDetail(${0:detail});
snippet curvePoint
	curvePoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});
snippet curveTightness
	curveTightness(${0:squishy});

#bezier
snippet bezier
	bezier(${1:x1}, ${2:y1}, ${3:cx1}, ${4:cy1}, ${5:cx2}, ${6:cy2}, ${7:x2}, ${0:y2});
snippet bezier 3D
	bezier(${1:x1}, ${2:y1}, ${3:z1}, ${4:cx1}, ${5:cy1}, ${6:cz1}, ${7:cx2}, ${8:cy2}, ${9:cz2}, ${10:x2}, ${11:y2}, ${0:z2});
snippet bezierDetail
	bezierDetail(${0:detail});
snippet bezierTangent
	bezierTangent(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});
snippet bezierPoint
	bezierPoint(${1:a}, ${2:b}, ${3:c}, ${4:d}, ${0:t});

#vertex
snippet vertex
	vertex(${1:x}, ${2:y}${3:, }${4:u}${5:, }${0:v});
snippet vertex 3D
	vertex(${1:x}, ${2:y}, ${3:z}${4:, }${5:u}${6:, }${0:v});
snippet bezierVertex
	bezierVertex(${1:cx1}, ${2:cy1}, ${3:cx2}, ${4:cy2}, ${5:x}, ${0:y});
snippet bezierVertex 3D
	bezierVertex(${1:cx1}, ${2:cy1}, ${3:cz1}, ${4:cx2}, ${5:cy2}, ${6:cz2}, ${7:x}, ${8:y}, ${0:z});
snippet curveVertex
	curveVertex(${1:x}, ${0:y});
snippet curveVertex 3D
	curveVertex(${1:x}, ${2:y}, ${0:z});

#stroke
snippet stroke
	stroke(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});
snippet strokeWeight
	strokeWeight(${0:1});

#mouse
snippet mouseDragged
	void mouseDragged(){
		${0}
	}
snippet mouseMoved
	void mouseMoved(){
		${0}
	}
snippet mouseReleased
	void mouseReleased(){
		${0}
	}
snippet mousePressed
	void mousePressed(){
		${0}
	}

#key
snippet keyReleased
	void keyReleased(){
		${0}
	}
snippet keyTyped
	void keyTyped(){
		${0}
	}
snippet keyPressed
	void keyPressed(){
		${0}
	}

#file
snippet loadStrings
	loadStrings("${0:filename}");
snippet saveStrings
	saveStrings(${1:filename}, ${0:strings});
snippet loadBytes
	loadBytes("${0:filename}");
snippet beginRecord
	beginRecord(${1:renderer}, ${0:filename});
snippet saveBytes
	saveBytes(${1:filename}, ${0:bytes});
snippet createWriter
	createWriter(${0:filename});
snippet createReader
	createReader(${0:filename});

#matrix
snippet pushMatrix
	pushMatrix();
	${0:};
	popMatrix();


#text
snippet text data
	text(${1:data}, ${2:x}, ${3:y}${4:, }${0:z});
snippet text stringdata
	text(${1:stringdata}, ${2:x}, ${3:y}, ${4:width}, ${5:height}${6:, }${0:z});
snippet textSize
	textSize(${0:size});
snippet textLeading
	textLeading(${0:size});
snippet textWidth
	textWidth(${0:data});
snippet font
	PFont ${1:font};
	$1 = loadFont("${0:FFScala-32.vlw}");
#load font
snippet loadFont
	${1:font} = loadFont("${0:FFScala-32.vlw}");
snippet textFont
	textFont(${1:font}${2:, }${0:size});

#math
snippet tan
	tan(${0:rad});
snippet atan
	atan(${0:rad});
snippet atan2
	atan2(${0:rad});
snippet sin
	sin(${0:rad});
snippet asin
	asin(${0:rad});
snippet cos
	cos(${0:rad});
snippet acos
	acos(${0:rad});
snippet degrees
	degrees(${0:rad});
snippet radians
	radians(${0:deg});
snippet randomSseed
	randomSeed(${0:value});
snippet random
	random(${1:value1}${2:, }${0:value2});
snippet pow
	pow(${1:num}, ${0:exponent});
snippet floor
	floor(${0:value});
snippet sqrt
	sqrt(${0:value});
snippet abs
	abs(${0:value});
snippet sq
	sq(${0:value});
snippet ceil
	ceil(${0:value});
snippet exp
	exp(${0:value});
snippet round
	round(${0:value}};
snippet min
	min(${1:value1}, ${2:value2}${3:, }${0:value3});
snippet max
	max(${1:value1}, ${2:value2}${3:, }${0:value3});
snippet max array
	max(${0:array});
snippet min array
	min(${0:array});
snippet log
	log(${0:value});
snippet map
	map(${1:value}, ${2:low1}, ${4:high1}, ${5:low2}, ${0:high2});
snippet norm
	norm(${1:value}, ${2:low}, ${0:high});
snippet constrain
	constrain(${1:value}, ${2:min}, ${0:max});
snippet mag
	mag(${1:a}, ${2:b}${3:, }${0:c});
snippet dist
	dist(${1:x1}, ${2:y1}, ${4:x2}, ${0:y2});
snippet dist 3D
	dist(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});

#noise math
snippet noise
	noise(${1:x}${2:, }${3:y}${4:, }${0:z});
snippet noiseDetail
	noiseDetail(${1:octaves}${2:, }${0:falloff});
snippet noiseSeed
	noiseSeed(${0:x});

#material
snippet shininess
	shininess(${0:shine});
snippet specular
	specular(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});
snippet ambient
	ambient(${1:value1}, ${2:value2}, ${0:value3});
snippet emissive
	emissive(${1:value1}, ${2:value2}, ${0:value3});

#light
snippet diretionalLight
	directionalLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});
snippet pointLight
	pointLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:nx}, ${5:ny}, ${0:nz});
snippet lightFalloff
	lightFalloff(${1:constant}, ${2:linear}, ${0:quadratic});
snippet normal
	normal(${1:nx}, ${2:ny}, ${0:nz});
snippet lightSpecular
	lightSpecular(${1:v1}, ${2:v2}, ${0:v3});
snippet ambientLight
	ambientLight(${1:v1}, ${2:v2}, ${3:v3}${7:, ${4:x}, ${5:y}, ${0:z}});
snippet spotLight
	spotLight(${1:v1}, ${2:v2}, ${3:v3}, ${4:x}, ${5:y}, ${6:z}, ${7:nx}, ${8:ny}, ${9:nz}, ${10:angle}, ${0:concentration});

#camera
snippet camera
	camera(${1:eyeX}, ${2:eyeY}, ${3:eyeZ}, ${4:centerX}, ${5:centerY}, ${6:centerZ}, ${7:upX}, ${8:upY}, ${0:upZ});
snippet ortho
	ortho(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});
snippet perspective
	perspective(${1:fov}, ${2:aspect}, ${3:zNear}, ${0:zFar});
snippet frustrum
	frustrum(${1:left}, ${2:right}, ${3:bottom}, ${4:top}, ${5:near}, ${0:far});

#transformations
snippet rotate
	rotate${1:X}(${0:angle});
snippet translate
	translate(${1:x}, ${2:y}${3:, }${0:z});
snippet scale size
	scale(${0:size});
snippet scale
	scale(${1:x}, ${2:y}${3:, }${0:z});

#coordinates
snippet coord
	${1:model/screen}${2:X}(${3:x}, ${4:y}, ${0:z});

#effects
snippet brightness
	brightness(${0:color});
snippet lerpColor
	lerpColor(${1:c1}, ${2:c2}, ${0:amt});
snippet saturation
	saturation(${0:color});
snippet hue
	hue(${0:color});
snippet alpha
	alpha(${0:color});
snippet tint
	tint(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});

#pixel
snippet set pixel
	set(${1:x}, ${2:y}, ${0:color/image});
snippet pixels
	pixels[${0:index}]
snippet get pixel
	get(${1:x}, ${2:y}${3:, }${4:width}${5:, }${0:height});

#geometric figures
snippet triangle
	triangle(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${0:y3});
snippet line
	line(${1:x1}, ${2:y1}, ${3:x2}, ${0:y2});
snippet line 3D
	line(${1:x1}, ${2:y1}, ${3:z1}, ${4:x2}, ${5:y2}, ${0:z2});
snippet arc
	arc(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:start}, ${0:stop});
snippet point
	point(${1:x}, ${2:y}${3:, }${0:z});
snippet quad
	quad(${1:x1}, ${2:y1}, ${3:x2}, ${4:y2}, ${5:x3}, ${6:y3}, ${7:x4}, ${0:y4});
snippet ellipse
	ellipse(${1:x}, ${2:y}, ${3:width}, ${0:height});
snippet rect
	rect(${1:x}, ${2:y}, ${3:width}, ${0:height});
snippet box
	box(${1:width}, ${2:height}, ${0:depth});
snippet sphere
	sphere(${0:radius});
snippet sphereDetails
	sphereDetail(${0:n});

#array operations
snippet split
	split("${1:str}"${2: , }${0:delimiter});
snippet splitTokens
	splitTokens(${1:str}${2:, }${0:tokens});
snippet join
	join(${1:strgArray}${2: , }${0:seperator});
snippet shorten
	shorten(${0:array});
snippet concat
	concat(${1:array1}, ${0:array2});
snippet subset
	subset(${1:array}, ${0:offset});
snippet append
	append(${1:array}, ${0:element});
snippet reverse
	reverse(${0:array});
snippet splice
	splice(${1:array}, ${2:value/array2}, ${0:index});
snippet sort
	sort(${1:dataArray}${2:, }${0:count});
snippet expand
	expand(${1:array}${2:, }${0:newSize});
snippet arrayCopy
	arrayCopy(${1:src}, ${2:dest}, ${3:, }${0:length});

#string operations
snippet str
	str("${0:str}");
snippet match
	match(${1:str}, ${0:regexp});
snippet trim
	trim(${0:str});
snippet nf
	nf(${2:value}, ${3:left}${4:, }${0:right});
snippet nfs
	nfs(${2:value}, ${3:left}${4:, }${0:right});
snippet nfp
	nfp(${2:value}, ${3:left}${4:, }${0:right});
snippet nfc
	nfc(${1:value}${2:, }${0:right});

#convert
snippet unbinary
	unbinary("${0:str}"});
snippet hexadecimal
	hex(${0:c});
snippet unhex
	unhex(${0:c});
snippet binary
	binary(${1:value}${2:, }${0:digits});

#image operations
snippet loadImage
	loadImage(${0:filename});
snippet image
	image(${1:img}, ${2:x}, ${3:y}${4:, }${5:width}${6:, }${0:height});
snippet copy
	copy(${1:srcImg}${2:, }${3:x}, ${4:y}, ${5:width}, ${6:height}, ${7:dx}, ${8:dy}, ${9:dwidth}, ${0:dheight});



#containers
snippet bg
	background(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});
snippet pg
	PGraphics pg;
	pg = createGraphics(${1:width}, ${2:height}${3:, }${0:applet});
snippet pimage
	PImage(${1:width}, ${0:height});

#UTILS
#fill
snippet fill
	fill(${1:value1}, ${2:value2}, ${3:value3}${4:, }${0:alpha});
#red
snippet red
	red(${0:color});
#green
snippet green
	green(${0:color});
#blue
snippet blue
	blue(${0:color});
#status
snippet status
	status(${0:text});
#param
snippet param
	param(${0:s});
#link
snippet link
	link(${1:url}${2:, }${0:target});
#@param
snippet @
	@${1:param/return/private/public}  ${1:parameter}  ${0:description}
./snippets/progress.snippets	[[[1
58
# Progress/OpenEdge ABL snippets
# define
snippet defbuf
	DEFINE BUFFER b_${1:TableName} FOR $1 ${0}.
snippet defvar
	DEFINE VARIABLE ${1:VariableName} AS ${0}.
snippet nl
	NO-LOCK
snippet ne
	NO-ERROR
snippet nle
	NO-LOCK NO-ERROR
snippet ini
	INITIAL ${0:?}
snippet nu
	NO-UNDO
snippet err
	ERROR
snippet ff
	FIND FIRST ${1:BufferName}
	${2:WHERE $1.${3}} ${0}
snippet input
	DEFINE INPUT PARAMETER ${1:ParamName} AS ${0}.
snippet output
	DEFINE OUTPUT PARAMETER ${1:ParamName} AS ${0:ParamType}.
snippet proc

	/******************************************************************************/

	PROCEDURE ${1:ProcName}:

		${0}

	END PROCEDURE. /* $1 */

	/******************************************************************************/

snippet alert
	MESSAGE "${1:MessageContent}" ${2:Data} VIEW-AS ALERT-BOX.
snippet if
	IF ${1:Condition}
	THEN ${2:Action}
	${3:ELSE ${4:OtherWise}}
snippet do
	DO${1: Clauses}:
		${0}
	END.
# datatypes
snippet int
	INTEGER
snippet char
	CHARACTER
snippet log
	LOGICAL
snippet dec
	DECIMAL
snippet sep
	/* ------------------------------------------------------------------------- */
./snippets/ps1.snippets	[[[1
101
# Snippets for
# Authored by Trevor Sullivan <trevor@trevorsullivan.net>

# PowerShell Class
snippet class
	class {
		[string] ${1:FirstName}
	}

# PowerShell Advanced Function
snippet function
	function ${1:name} {
		[CmdletBinding()]
		param (
			[Parameter(Mandatory = $true)]
			[string] ${2:Param}
		)

		begin {
		}

		process {
		}

		end {
		}
	}

# PowerShell Splatting
snippet splatting
	$Params = @{
		${1:Param1} = '${2:Value1}'
		${3:Param2} = '${4:Value2}'
	}
	${5:CommandName} @Params

# PowerShell Enumeration
snippet enum
	enum ${1:name} {
		${2:item1}
		${3:item2}
	}

# PowerShell if..then
snippet if
	if ($1) {
		$0
	}

# PowerShell if..else
snippet ife
	if ( $1 ) {
		${2}
	}
	else {
		${3}
	}

# PowerShell While Loop
snippet while
	while ($1) {
		$0
	}

# PowerShell Filter..Sort
snippet filtersort
	${1:command} | Where-Object -FilterScript { $PSItem.${2:property} -${3:operator} '${4:expression}' } | Sort-Object -Property ${5:sortproperty}

# PowerShell foreach
snippet foreach
	foreach ( $${1:iterator} in $${2:collection} ) {
		$0
	}

# PowerShell export-csv
snippet epcsv
	Export-CSV -NoTypeInformation -Path ${1:path}

# Powershell Comment Based Help
snippet help
	<#
	.SYNOPSIS
		${1:Short Description}
	.DESCRIPTION
		${2:Full Description}
	.PARAMETER ${3:Param1}
		${4: $3 usage}
	.EXAMPLE
		${5:Example}
	.NOTES
		${6:notes}
	.LINK
		${7:online help}
	#>

# Powershell switch statement
snippet switch
	switch ( ${1:test} ){
		${2:condition1} { ${3:action} }
		${4:condition2} { ${5:action} }
		default { ${6:action} }
./snippets/puppet.snippets	[[[1
245
# Snippets for use with VIM and http://www.vim.org/scripts/script.php?script_id=2540
#
# Please contact Jorge Vidal <im@jor.ge> for additions and feedback,
# see it in action @ http://www.devco.net/archives/2009/09/22/vim_and_puppet.php
# Many thanks to the original author R.I.Pienaar <rip@devco.net>

# Header using Puppet Strings (YARD tags) https://puppet.com/docs/puppet/latest/modules_documentation.html
# More info: https://github.com/puppetlabs/puppet-strings
snippet classheader
	# ${1:`vim_snippets#Filename(substitute(expand('%:p:s?\v.{-}/(\w+)/manifests/(.+)\.pp?\1/\2?'), '/', '::', 'g'), 'class-name')`}
	# ${2:A description of what this class does}
	#
	# @summary ${3:A short summary of the purpose of this class}
	#
	# @param ${4:parameter1}
	#   ${6:Explanation of what this parameter affects.}
	#
	# @example Simple use
	#   include $1
	#
	# @example Use with params
	#   class { '$1':
	#     $$4 => '${7:undef}',
	#   }
	#
	# @author ${8:`g:snips_author`} <${9:`g:snips_email`}>
	#
	# @note Copyright `strftime("%Y")` $8
	#
	class $1(
		${5:String} $$4 = undef,
	) {
		${0}
	}

snippet defheader
	# ${1:`vim_snippets#Filename(expand('%:p:s?.*modules/??:h:h'), 'define-name')`}
	# ${2:A description of what this define does}
	#
	# @summary ${3:A short summary of the purpose of this define}
	#
	# @param ${4:parameter1} [${5:String}]
	#   ${6:Explanation of what this parameter affects.}
	#
	# @example Simple use
	#   $1 { 'namevar':
	#     $$4 => '${7:undef}',
	#   }
	#
	# @author ${8:`g:snips_author`} <${9:`g:snips_email`}>
	#
	# @note Copyright `strftime("%Y")` $8
	#
	define $1(
		$$4 = undef,
	) {
		${0}
	}

# Language Constructs
snippet class
	class ${1:`vim_snippets#Filename('', 'name')`} {
		${0}
	}
snippet node
	node "${1:`vim_snippets#Filename('', 'fqdn')`}" {
		${0}
	}
snippet case
	case $${1:variable} {
		default: { ${0} }
	}
snippet ife
	if $${1:variable} {
		${2}
	} else {
		${0}
	}
snippet if
	if $${1:variable} {
		${0}
	}
snippet ifd
	if defined(${1:Resource}["${2:name}"]) {
		${0}
	}
snippet ifnd
	if !defined(${1:Resource}["${2:name}"]) {
		${0}
	}
snippet el
	else {
		${0}
	}
snippet ?
	? {
		"${1}"	=> ${0}
	  }
#
# blocks etc and general syntax sugar
snippet [
	[ ${1} ]
snippet >
	${1}	=> ${0}
snippet p:
	"puppet://puppet/${1:module name}/${0:file name}"
#
# Functions
snippet alert
	alert("${1:message}")
snippet crit
	crit("${1:message}")
snippet debug
	debug("${1:message}")
snippet defined
	defined(${1:Resource}["${2:name}"])
snippet emerg
	emerg("${1:message}")
snippet extlookup Simple extlookup
	extlookup("${1:variable}")
snippet extlookup Extlookup with defaults
	extlookup("${1:variable}", "${2:default}")
snippet extlookup Extlookup with defaults and custom data file
	extlookup("${1:variable}", "${2:default}", "${3:data source}")
snippet fail
	fail("${1:message}")
snippet info
	info("${1:message}")
snippet inline_template
	inline_template("<%= ${1} %>")
snippet notice
	notice("${1:message}")
snippet realize
	realize(${1:Resource}[${2:name}])
snippet regsubst
	regsubst(${1:hay stack}, ${2:needle}, "${3:replacement}")
snippet inc
	include ${1:classname}
snippet split
	split(${1:hay stack}, "${2:patten}")
snippet versioncmp
	versioncmp("${1:version}", "${2:version}")
snippet warning
	warning("${1:message}")
#
# Types
snippet cron
	cron { "${1:name}":
		command => "${2}",
		user    => "${3:root}",
		${4}    => ${0},
	}

snippet exec
	exec { "${1:name}":
		command => "${2:$1}",
		user    => "${3:root}",
		${4}    => ${0},
	}

snippet user
	user { "${1:user}":
		ensure      => present,
		comment     => "${2:$1}",
		managehome  => true,
		home        => "${0:/home/$1}",
	}

snippet group
	group { "${1:group}":
		ensure => ${0:present},
	}

snippet host
	host { "${1:hostname}":
		ip => ${0:127.0.0.1},
	}

snippet mailalias
	mailalias { "${1:localpart}":
		recipient => "${0:recipient}",
	}

snippet mount
	mount { "${1:destination path}":
		ensure	=> ${2:mounted},
		device	=> "${0:device name or path}",
	}

snippet notify
	notify { "${1:message}": }

snippet package
	package { "${1:package name}":
		ensure	=> ${0:present},
	}

snippet yumrepo
	yumrepo { "${1:repo name}":
		descr   => "${2:$1}",
		enabled => ${0:1},
	}

snippet define
	define ${1} (${2}) {
		${0}
	}

snippet service
	service { "${1:service}":
		ensure    => running,
		enable    => true,
		require   => [ Package["${2:package}"], File["${3:file}"], ],
		subscribe => [ File["${4:configfile1}"], File["${5:configfile2}"], Package["${6:package}"], ],
	}

snippet file
	file { "${1:filename}":
		ensure  => ${2:present},
		owner   => "${3:root}",
		group   => "${4:root}",
		mode    => "${5:0644}",
		source  => "puppet:///modules/${6:module}/${7:source}",
		content => template("${8:module}/${9:template}"),
		alias   => "${10:alias}",
		require => [ Package["${11:package}"], File["${12:file}"], ],
	}

snippet archive
	archive { "${1:filename}":
		ensure     => ${2:present},
		url        => "http://${3:url}",
		extension  => "${4:tgz}",
		target     => "${5:target}",
		checksum   => ${6:false},
		src_target => "${7:/tmp}",
	}

snippet firewall
	firewall { "${1:comment}":
		proto	=> ${2:tcp},
		action	=> ${3:accept},
		port	=> ${4},
	}

./snippets/purescript.snippets	[[[1
71
snippet mod
	module `substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`
		(
		) where

	import Prelude

	${0}
snippet imp
	import ${0:Data.List}
snippet impq
	import ${1:Data.List} as ${0:List}
snippet fn0
	${1:name} :: ${2:a}
	$1 = ${0:undefined}
snippet fn
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4}= ${0}
snippet fn1
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4}= ${0}
snippet fn2
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5}= ${0}
snippet fn3
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6}= ${0}
snippet case
	case ${1} of
		${2} -> ${0}
snippet let
	let
		${1} = ${2}
	in
		${3}
snippet where
	where
		${1} = ${0}
snippet testunit
	module Test.Main where

	import Prelude
	import Test.Unit (suite, test)
	import Test.Unit.Main (runTest)
	import Test.Unit.Assert as Assert

	main = runTest do
		suite "${1}" do
			test "${2:the tests run}" do
				Assert.equal
					"Hello, world!"
					"Hello, sailor!"
snippet if
	if ${1} then
		${2:${VISUAL}}
	else
		${0}
snippet doc
	{-| ${0}
	-}
snippet ty
	type ${1:Type} =
		${0}
snippet da
	data ${1:Type} =
		${0:$1}
snippet nty
	newtype ${1:Type} =
		${2:$1} ${0:Int}
snippet fi
	foreign import ${1} :: ${2}
./snippets/python.snippets	[[[1
523
snippet #!
	#!/usr/bin/env python3
snippet #!2
	#!/usr/bin/env python2
	# -*- coding: utf-8 -*-
snippet #!3
	#!/usr/bin/env python3
snippet imp
	import ${0:module}
snippet uni
	def __unicode__(self):
		${0:representation}
snippet from
	from ${1:package} import ${0:module}

# Module Docstring
snippet docs
	"""
	File: ${1:`vim_snippets#Filename('$1.py', 'foo.py')`}
	Author: `g:snips_author`
	Email: `g:snips_email`
	Github: `g:snips_github`
	Description: ${0}
	"""

# Unittest skip
snippet sk "skip unittests" b
	@unittest.skip(${1:skip_reason})

snippet wh
	while $1:
		${0:${VISUAL}}

# dowh - does the same as do...while in other languages
snippet dowh
	while True:
		${1}
		if $0:
			break

snippet with
	with ${1:expr} as ${2:var}:
		${0:${VISUAL}}

snippet awith
	async with ${1:expr} as ${2:var}:
		${0:${VISUAL}}

# New Class
snippet cl
	class ${1:ClassName}(${2:object}):
		"""${3:docstring for $1}"""
		def __init__(self, ${4:arg}):
			${5:super($1, self).__init__()}
			self.$4 = $4
			${0}
snippet cla
	class ${1:class_name}:
		"""${0:description}"""

snippet clai
	class ${1:class_name}:
		"""${2:description}"""
		def __init__(self, ${3:args}):
			${0}

# Data class
snippet dcl dataclass
	@dataclass
	class ${1:ClassName}:
		"""${2:description}"""
		${3:var_1}: ${4:int}
		${5:var_2}: ${6:float} = ${7:0}

		def ${8:total}(self): -> $6:
			return ${0:self.$3 * self.$5}

# New Function
snippet def
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${0}
snippet deff
	def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${0}
snippet adef
	async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		"""${3:docstring for $1}"""
		${0}
snippet adeff
	async def ${1:fname}(${2:`indent('.') ? 'self' : ''`}):
		${0}

# New Method
snippet defi
	def __init__(self, ${1:args}):
		${0}
snippet defm
	def ${1:mname}(self, ${2:arg}):
		${0}
snippet adefm
	async def ${1:mname}(self, ${2:arg}):
		${0}

# New Property
snippet property
	@property
	def ${1:foo}(self) -> ${2:type}:
		"""${3:doc}"""
		return self._$1

	@$1.setter
	def $1(self, value: $2):
		self._$1 = value

# Ifs
snippet if
	if $1:
		${0:${VISUAL}}
snippet el
	else:
		${0:${VISUAL}}
snippet ei
	elif $1:
		${0:${VISUAL}}

# Match
snippet match Structural pattern matching
	match ${1:expression}:
		case ${2:pattern_1}:
			${3:pass}
		case ${4:pattern_2}:
			${5:pass}

# Match with wildcard
snippet matchw Pattern matching with wildcard
	match ${1:expression}:
		case ${2:pattern_1}:
			${3:pass}
		case _:
			${0:pass}

# For
snippet for
	for ${1:item} in ${2:items}:
		${0}

# Encodes
snippet cutf8
	# -*- coding: utf-8 -*-
snippet clatin1
	# -*- coding: latin-1 -*-
snippet cascii
	# -*- coding: ascii -*-

# Lambda
snippet ld
	${1:var} = lambda ${2:vars} : ${0:action}

snippet ret
	return ${0}
snippet .
	self.
snippet sa self.attribute = attribute
	self.${1:attribute} = $1

snippet try Try/Except
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${0:raise $3}
snippet trye Try/Except/Else
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	else:
		${0}
snippet tryf Try/Except/Finally
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	finally:
		${0}
snippet tryef Try/Except/Else/Finally
	try:
		${1:${VISUAL}}
	except ${2:Exception} as ${3:e}:
		${4:raise $3}
	else:
		${5}
	finally:
		${0}

# if __name__ == '__main__':
snippet ifmain
	if __name__ == '__main__':
		${0:main()}
# __magic__
snippet _
	__${1:init}__

# debugger breakpoint
snippet br
	breakpoint()
# python debugger (pdb)
snippet pdb
	__import__('pdb').set_trace()
# bpython debugger (bpdb)
snippet bpdb
	__import__('bpdb').set_trace()
# ipython debugger (ipdb)
snippet ipdb
	__import__('ipdb').set_trace()
# embed ipython itself
snippet iem
	__import__('IPython').embed()
# remote python debugger (rpdb)
snippet rpdb
	__import__('rpdb').set_trace()
# web python debugger (wdb)
snippet wdb
	__import__('wdb').set_trace()
# ptpython
snippet ptpython
	__import__('ptpython.repl', fromlist=('repl')).embed(globals(), locals(), vi_mode=${1:False}, history_filename=${2:None})
# python console debugger (pudb)
snippet pudb
	__import__('pudb').set_trace()
# python console debugger remote (pudb)
snippet pudbr
	from pudb.remote import set_trace
	set_trace()
# pdb in nosetests
snippet nosetrace
	__import__('nose').tools.set_trace()
snippet pprint
	__import__('pprint').pprint(${1})

snippet "
	"""${0:doc}
	"""

# assertions
snippet a=
	self.assertEqual(${0}, ${1})
# test function/method
snippet test
	def test_${1:description}(${2:`indent('.') ? 'self' : ''`}):
		${0}
# test case
snippet testcase
	class ${1:ExampleCase}(unittest.TestCase):

		def test_${2:description}(self):
			${0}
# test given when then
snippet tgwt
	# given: ${1}
	# when: ${2}
	# then: ${3}
snippet fut
	from __future__ import ${0}

#getopt
snippet getopt
	try:
		# Short option syntax: "hv:"
		# Long option syntax: "help" or "verbose="
		opts, args = getopt.getopt(sys.argv[1:], "${1:short_options}", [${2:long_options}])

	except getopt.GetoptError, err:
		# Print debug info
		print str(err)
		${3:error_action}

	for option, argument in opts:
		if option in ("-h", "--help"):
			${0}
		elif option in ("-v", "--verbose"):
			verbose = argument

# argparse
snippet addp
	parser = ${VISUAL:argparse.}ArgumentParser()
snippet addsp
	${0:sub_parser} = parser.add_subparsers().add_parser("${1:name}")
snippet addarg
	parser.add_argument("${0:short_arg}", "${1:long_arg}", default=${2:None}, help="${3:Help text}")
snippet addnarg
	parser.add_argument("${0:arg}", nargs="${1:*}", default=${2:None}, help="${3:Help text}")
snippet addaarg
	parser.add_argument("${0:arg}", "${1:long_arg}", action="${2:store_true}", default=${3:False}, help="${4:Help text}")
snippet pargs
	"${VISUAL:return }"parser.parse_args()

# logging
# glog = get log
snippet glog
	import logging
	LOGGER = logging.getLogger(${0:__name__})
snippet le
	LOGGER.error(${0:msg})
# conflict with lambda=ld, therefor we change into Logger.debuG
snippet lg
	LOGGER.debug(${0:msg})
snippet lw
	LOGGER.warning(${0:msg})
snippet lc
	LOGGER.critical(${0:msg})
snippet li
	LOGGER.info(${0:msg})
snippet epydoc
	"""${1:Description}

	@param ${2:param}: ${3: Description}
	@type  $2: ${4: Type}

	@return: ${5: Description}
	@rtype : ${6: Type}

	@raise e: ${0: Description}
	"""
snippet dol
	def ${1:__init__}(self, *args, **kwargs):
		super(${0:ClassName}, self).$1(*args, **kwargs)
snippet kwg
	self.${1:var_name} = kwargs.get('$1', ${2:None})
snippet lkwg
	${1:var_name} = kwargs.get('$1', ${2:None})
snippet args
	*args${1:,}${0}
snippet kwargs
	**kwargs${1:,}${0}
snippet akw
	*args, **kwargs${1:,}${0}

# comprehensions
snippet lcp list comprehension
	[${1} for ${2} in ${3:${VISUAL}}]${0}

snippet dcp dict comprehension
	{${1}: ${2} for ${3} in ${4:${VISUAL}}}${0}

snippet scp set comprehension
	{${1} for ${2} in ${3:${VISUAL}}}${0}

snippet contain "methods for emulating a container type" b
	def __len__(self):
		${1:pass}

	def __getitem__(self, key):
		${2:pass}

	def __setitem__(self, key, value):
		${3:pass}

	def __delitem__(self, key):
		${4:pass}

	def __iter__(self):
		${5:pass}

	def __reversed__(self):
		${6:pass}

	def __contains__(self, item):
		${7:pass}

snippet context "context manager methods" b
	def __enter__(self):
		${1:pass}

	def __exit__(self, exc_type, exc_value, traceback):
		${2:pass}

snippet attr "methods for customizing attribute access" b
	def __getattr__(self, name):
		${1:pass}

	def __setattr__(self, name, value):
		${2:pass}

	def __delattr__(self, name):
		${3:pass}

snippet desc "methods implementing descriptors" b
	def __get__(self, instance, owner):
		${1:pass}

	def __set__(self, instance, value):
		${2:pass}

	def __delete__(self, instance):
		${3:pass}

snippet cmp "methods implementing rich comparison"
	def __eq__(self, other):
		${1:pass}

	def __ne__(self, other):
		${2:pass}

	def __lt__(self, other):
		${3:pass}

	def __le__(self, other):
		${4:pass}

	def __gt__(self, other):
		${5:pass}

	def __ge__(self, other):
		${6:pass}

	def __cmp__(self, other):
		${7:pass}

snippet repr "methods implementing string representation"
	def __repr__(self):
		${1:pass}

	def __str__(self):
		${2:pass}

	def __unicode__(self):
		${3:pass}

# note: reflected operands and augmented arithmeitc assignements have been
# intentionally ommited to reduce verbosity.
snippet numeric "methods for emulating a numeric type" b
	def __add__(self, other):
		${1:pass}

	def __sub__(self, other):
		${2:pass}

	def __mul__(self, other):
		${3:pass}

	def __div__(self, other):
		${4:pass}

	def __truediv__(self, other):
		${5:pass}

	def __floordiv__(self, other):
		${6:pass}

	def __mod__(self, other):
		${7:pass}

	def __divmod__(self, other):
		${8:pass}

	def __pow__(self, other):
		${9:pass}

	def __lshift__(self, other):
		${10:pass}

	def __rshift__(self, other):
		${11:pass}

	def __and__(self, other):
		${12:pass}

	def __xor__(self, other):
		${13:pass}

	def __or__(self, other):
		${14:pass}

	def __neg__(self):
		${15:pass}

	def __pos__(self):
		${16:pass}

	def __abs__(self):
		${17:pass}

	def __invert__(self):
		${18:pass}

	def __complex__(self):
		${19:pass}

	def __int__(self):
		${20:pass}

	def __long__(self):
		${21:pass}

	def __float__(self):
		${22:pass}

	def __oct__(self):
		${22:pass}

	def __hex__(self):
		${23:pass}

	def __index__(self):
		${24:pass}

	def __coerce__(self, other):
		${25:pass}

# Printing
snippet pr
	print($0)
snippet prs
	print("$0")
snippet prf
	print(f"$0")
snippet fpr
	print($0, file=${1:sys.stderr})
snippet fprs
	print("$0", file=${1:sys.stderr})
snippet fprf
	print(f"$0", file=${1:sys.stderr})
./snippets/r.snippets	[[[1
139
snippet #!
	#!/usr/bin/env Rscript

# includes
snippet lib
	library(${0:package})
snippet req
	require(${0:package})
snippet source
	source('${0:file}')

# conditionals
snippet if
	if ($1) {
		${0}
	}
snippet el
	else {
		${0}
	}
snippet ei
	else if ($1) {
		${0}
	}

# loops
snippet wh
	while(${1:true}) {
		${0}
	}
snippet wht
	while(true) {
		${0}
	}
snippet for
	for (${1:item} in ${2:list}) {
		${3}
	}
snippet foreach
	foreach (${1:item} = ${2:list}) {
		${3}
	}

# functions
snippet fun
	${1:name} <- function (${2:variables}) {
		${0}
	}
snippet ret
	return(${0})

# dataframes, lists, etc
snippet df
	${1:name}[${2:rows}, ${0:cols}]
snippet c
	c(${0:items})
snippet li
	list(${0:items})
snippet mat
	matrix(${1:data}, nrow = ${2:rows}, ncol = ${0:cols})

# apply functions
snippet apply
	apply(${1:array}, ${2:margin}, ${0:function})
snippet lapply
	lapply(${1:list}, ${0:function})
snippet sapply
	lapply(${1:list}, ${0:function})
snippet vapply
	vapply(${1:list}, ${2:function}, ${0:type})
snippet mapply
	mapply(${1:function}, ${0:...})
snippet tapply
	tapply(${1:vector}, ${2:index}, ${0:function})
snippet rapply
	rapply(${1:list}, ${0:function})

# plyr functions
snippet dd
	ddply(${1:frame}, ${2:variables}, ${0:function})
snippet dl
	dlply(${1:frame}, ${2:variables}, ${0:function})
snippet da
	daply(${1:frame}, ${2:variables}, ${0:function})
snippet d_
	d_ply(${1:frame}, ${2:variables}, ${0:function})

snippet ad
	adply(${1:array}, ${2:margin}, ${0:function})
snippet al
	alply(${1:array}, ${2:margin}, ${0:function})
snippet aa
	aaply(${1:array}, ${2:margin}, ${0:function})
snippet a_
	a_ply(${1:array}, ${2:margin}, ${0:function})

snippet ld
	ldply(${1:list}, ${0:function})
snippet ll
	llply(${1:list}, ${0:function})
snippet la
	laply(${1:list}, ${0:function})
snippet l_
	l_ply(${1:list}, ${0:function})

snippet	md
	mdply(${1:matrix}, ${0:function})
snippet	ml
	mlply(${1:matrix}, ${0:function})
snippet	ma
	maply(${1:matrix}, ${0:function})
snippet	m_
	m_ply(${1:matrix}, ${0:function})

# plot functions
snippet pl
	plot(${1:x}, ${0:y})
snippet ggp
	ggplot(${1:data}, aes(${0:aesthetics}))
snippet img
	${1:(jpeg,bmp,png,tiff)}(filename = '${2:filename}', width = ${3}, height = ${4}, unit = '${5}')
	${0:plot}
	dev.off()

# statistical test functions
snippet fis
	fisher.test(${1:x}, ${0:y})
snippet chi
	chisq.test(${1:x}, ${0:y})
snippet tt
	t.test(${1:x}, ${0:y})
snippet wil
	wilcox.test(${1:x}, ${0:y})
snippet cor
	cor.test(${1:x}, ${0:y})
snippet fte
	var.test(${1:x}, ${0:y})
snippet kvt
	kv.test(${1:x}, ${0:y})
./snippets/racket.snippets	[[[1
131
# Languages
snippet #r
	#lang racket
snippet #tr
	#lang typed/racket
snippet #rg
	#lang racket/gui
snippet #sb
	#lang scribble/base
snippet #d
	#lang datalog
snippet #wi
	#lang web-server/insta

# Defines
snippet def
	(define ${1} ${0})
snippet defun
	(define (${1})
		${0})
snippet defv "define-values"
	(define-values (${1}) (${0}))
snippet defm "define/match"
	(define/match (${1})
	  [(${2}) ${3}]
		${0})
snippet defs "define-syntax"
	(define-syntax (${1})
		${0})

# Conditionals
snippet if
	(if ${1} ${2} ${0})
snippet ifn
	(if (not ${1}) ${2} ${0})
snippet ifl
	(if ${1}
		(let (${2})
			${3})
		${0})
snippet ifnl
	(if (not ${1})
		(let (${2})
			${3})
		${0})
snippet ifb
	(if ${1}
		(begin
			${2})
		${0})
snippet ifnb
	(if (not ${1})
		(begin
			${2})
		${0})
snippet when
	(when ${1}
		${0})
snippet unless
	(unless ${1} ${2} ${0})
snippet cond
	(cond
		[(${1}) ${0}])
snippet conde
	(cond
		[(${1}) ${2}]
		[else ${0}])
snippet case
	(case ${1}
		[(${2}) ${0}])
snippet match
	(match ${1}
		[(${2}) ${0}])

# For iterations
snippet for
	(for ([${1}])
		${0})
snippet forl "for/list"
	(for/list ([${1}])
		${0})
snippet forf "for/fold"
	(for/fold
		([${1}])
		([${2}])
		${0})
snippet forfr "for/foldr"
	(for/foldr
		([${1}])
		([${2}])
		${0})
snippet fora "for/and"
	(for/and ([${1}])
		${0})
snippet foro "for/or"
	(for/or ([${1}])
		${0})
snippet fors "for/sum"
	(for/sum ([${1}])
		${0})
snippet forp "for/product"
	(for/product ([${1}])
		${0})
snippet forfi "for/first"
	(for/first ([${1}])
		${0})
snippet forla "for/last"
	(for/last ([${1}])
		${0})

snippet lambda
	(lambda (${1}) ${0})
snippet apply
	(apply ${1} ${0})
snippet map
	(map ${1} ${0})
snippet filter
	(filter ${1} ${0})

snippet req
	(require ${0})
snippet prov
	(provide ${0})

snippet let
	(let ([${1}]) ${0})
snippet letcc
	(let/cc here (set! ${1} here) ${0})
snippet begin
	(begin
		${0})
./snippets/rails.snippets	[[[1
487
snippet art
	assert_redirected_to ${1:action}: '${2:index}'
snippet artnp
	assert_redirected_to ${1:parent}_${2:child}_path(${3:@$1}, ${0:@$2})
snippet artnpp
	assert_redirected_to ${1:parent}_${2:child}_path(${0:@$1})
snippet artp
	assert_redirected_to ${1:model}_path(${0:@$1})
snippet artpp
	assert_redirected_to ${0:model}s_path
snippet asd
	assert_difference '${1:Model}.${2:count}', ${3:1} do
		${0}
	end
snippet asnd
	assert_no_difference '${1:Model}.${2:count}' do
		${0}
	end
snippet asre
	assert_response :${1:success}, @response.body
snippet asrj
	assert_rjs :${1:replace}, '${0:dom id}'
snippet ass assert_select(..)
	assert_select '${1:path}', ${2:text}: '${3:inner_html}' ${4:do}
		${0}
	end
snippet ba
	before_action :${0:method}
snippet bf
	before_filter :${0:method}
snippet bt
	belongs_to :${0:association}
snippet btp
	belongs_to :${1:association}, polymorphic: true
snippet crw
	cattr_accessor :${0:attr_names}
snippet defcreate
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new($1_params)

		respond_to do |format|
			if @$1.save
				flash[:notice] = '$2 was successfully created.'
				format.html { redirect_to(@$1) }
				format.json  { render json: @$1, status: :created, location: @$1 }
			else
				format.html { render action: 'new' }
				format.json  { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet defdestroy
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |format|
			format.html { redirect_to($1s_url) }
			format.json  { head :ok }
		end
	end
snippet defedit
	def edit
		@${1:model_class_name} = ${0:ModelClassName}.find(params[:id])
	end
snippet defindex
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |format|
			format.html # index.html.erb
			format.json  { render json: @$1s }
		end
	end
snippet defnew
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |format|
			format.html # new.html.erb
			format.json  { render json: @$1 }
		end
	end
snippet defshow
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			format.html # show.html.erb
			format.json  { render json: @$1 }
		end
	end
snippet defupdate
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |format|
			if @$1.update($1_params)
				flash[:notice] = '$2 was successfully updated.'
				format.html { redirect_to(@$1) }
				format.json  { head :ok }
			else
				format.html { render action: 'edit' }
				format.json  { render json: @$1.errors, status: :unprocessable_entity }
			end
		end
	end
snippet defparams
	def ${1:model_class_name}_params
		params.require(:$1).permit()
	end
snippet dele delegate .. to
	delegate :${1:methods}, to: :${0:object}
snippet dele delegate .. to .. prefix .. allow_nil
	delegate :${1:methods}, to: :${2:object}, prefix: :${3:prefix}, allow_nil: ${0:allow_nil}
snippet amc
	alias_method_chain :${1:method_name}, :${0:feature}
snippet flash
	flash[:${1:notice}] = '${0}'
snippet habtm
	has_and_belongs_to_many :${1:object}, join_table: '${2:table_name}', foreign_key: '${3}_id'
snippet hm
	has_many :${0:object}
snippet hmd
	has_many :${1:other}s, class_name: '${2:$1}', foreign_key: '${3:$1}_id', dependent: :destroy
snippet hmt
	has_many :${1:object}, through: :${0:object}
snippet ho
	has_one :${0:object}
snippet hod
	has_one :${1:object}, dependent: :${0:destroy}
snippet i18
	I18n.t('${1:type.key}')
snippet ist
	<%= image_submit_tag('${1:agree.png}', id: '${2:id}'${0}) %>
snippet log
	Rails.logger.${1:debug} ${0}
snippet log2
	RAILS_DEFAULT_LOGGER.${1:debug} ${0}
snippet logd
	logger.debug { '${1:message}' }
snippet loge
	logger.error { '${1:message}' }
snippet logf
	logger.fatal { '${1:message}' }
snippet logi
	logger.info { '${1:message}' }
snippet logw
	logger.warn { '${1:message}' }
snippet mapc
	${1:map}.${2:connect} '${0:controller/:action/:id}'
snippet mapca
	${1:map}.catch_all '*${2:anything}', controller: '${3:default}', action: '${4:error}'
snippet mapr
	${1:map}.resource :${0:resource}
snippet maprs
	${1:map}.resources :${0:resource}
snippet mapwo
	${1:map}.with_options ${2:controller}: '${3:thing}' do |$3|
		${0}
	end

###############################
#   model callback snippets   #
###############################

# before callback
snippet mbv
	before_validation :${0:method}
snippet mbc
	before_create :${0:method}
snippet mbu
	before_update :${0:method}
snippet mbs
	before_save :${0:method}
snippet mbd
	before_destroy :${0:method}

# after callback
snippet mav
	after_validation :${0:method}
snippet maf
	after_find :${0:method}
snippet mat
	after_touch :${0:method}
snippet macr
	after_create :${0:method}
snippet mau
	after_update :${0:method}
snippet mas
	after_save :${0:method}
snippet mad
	after_destroy :${0:method}

# around callback
snippet marc
	around_create :${0:method}
snippet maru
	around_update :${0:method}
snippet mars
	around_save :${0:method}
snippet mard
	around_destroy :${0:method}

snippet mcht
	change_table :${1:table_name} do |t|
		${0}
	end
snippet mp
	map(&:${0:id})
snippet mrw
	mattr_accessor :${0:attr_names}
snippet oa
	order('${0:field}')
snippet od
	order('${0:field} DESC')
snippet pa
	params[:${1:id}]
snippet ra
	render action: '${0:action}'
snippet ral
	render action: '${1:action}', layout: '${0:layoutname}'
snippet rest
	respond_to do |format|
		format.${1:html} { ${0} }
	end
snippet rf
	render file: '${0:filepath}'
snippet rfu
	render file: '${1:filepath}', use_full_path: ${0:false}
snippet ri
	render inline: "${0:<%= 'hello' %>}"
snippet ril
	render inline: "${1:<%= 'hello' %>}", locals: { ${2:name}: '${3:value}'${0} }
snippet rit
	render inline: "${1:<%= 'hello' %>}", type: ${0::rxml}
snippet rjson
	render json: '${0:text to render}'
snippet rl
	render layout: '${0:layoutname}'
snippet rn
	render nothing: ${0:true}
snippet rns
	render nothing: ${1:true}, status: ${0:401}
snippet rp
	render partial: '${0:item}'
snippet rpc
	render partial: '${1:item}', collection: ${0:@$1s}
snippet rpl
	render partial: '${1:item}', locals: { ${2:$1}: ${0:@$1} }
snippet rpo
	render partial: '${1:item}', object: ${0:@$1}
snippet rps
	render partial: '${1:item}', status: ${0:500}
snippet rt
	render text: '${0:text to render}'
snippet rtl
	render text: '${1:text to render}', layout: '${0:layoutname}'
snippet rtlt
	render text: '${1:text to render}', layout: ${0:true}
snippet rts
	render text: '${1:text to render}', status: ${0:401}
snippet ru
	render :update do |${1:page}|
		$1.${0}
	end
snippet rxml
	render xml: '${0:text to render}'
snippet sc
	scope :${1:name}, -> { where(${2:field}: ${0:value}) }
snippet sl
	scope :${1:name}, lambda do |${2:value}|
		where('${3:field = ?}', ${0:value})
	end
snippet sha1
	Digest::SHA1.hexdigest(${0:string})
snippet va validates_associated
	validates_associated :${0:attribute}
snippet va validates .., acceptance: true
	validates :${0:terms}, acceptance: true
snippet vc
	validates :${0:attribute}, confirmation: true
snippet ve
	validates :${1:attribute}, exclusion: { in: ${0:%w( mov avi )} }
snippet vf
	validates :${1:attribute}, format: { with: /${0:regex}/ }
snippet vi
	validates :${1:attribute}, inclusion: { in: %w(${0: mov avi }) }
snippet vl
	validates :${1:attribute}, length: { in: ${2:3}..${0:20} }
snippet vn
	validates :${0:attribute}, numericality: true
snippet vp
	validates :${0:attribute}, presence: true
snippet vu
	validates :${0:attribute}, uniqueness: true
snippet format
	format.${1:js|xml|html} { ${0} }
snippet wc
	where(${1:'conditions'}${0:, bind_var})
snippet wf
	where(${1:field}: ${0:value})
snippet xdelete
	xhr :delete, :${1:destroy}, id: ${2:1}
snippet xget
	xhr :get, :${1:show}, id: ${2:1}
snippet xpost
	xhr :post, :${1:create}, ${2:object}: ${3:object}
snippet xput
	xhr :put, :${1:update}, id: ${2:1}, ${3:object}: ${4:object}
snippet test
	test '${1:should do something}' do
		${0}
	end
###########################
#   migrations snippets   #
###########################
snippet mac
	add_column :${1:table_name}, :${2:column_name}, :${0:data_type}
snippet mai
	add_index :${1:table_name}, :${0:column_name}
snippet mrc
	remove_column :${1:table_name}, :${0:column_name}
snippet mrnc
	rename_column :${1:table_name}, :${2:old_column_name}, :${0:new_column_name}
snippet mcc
	change_column :${1:table}, :${2:column}, :${0:type}
snippet mnc
	t.${1:string} :${2:title}${3:, null: false}
snippet mct
	create_table :${1:table_name} do |t|
		${0}
	end
snippet mrev reversible do |dir| ... dir.up .. dir.down .. end
	reversible do |dir|
		dir.up do
			${0}
		end

		dir.down do
		end
	end
snippet cmm class Migration... < ApplicationModel .. self.table_name .. end
	class Migration${1:class_name} < ApplicationRecord
		self.table_name = :${2:model_name}s
	end
snippet migration class .. < ActiveRecord::Migration .. def up .. def down .. end
	class `substitute( substitute(vim_snippets#Filename(), '^\d\+_', '',''), '\(_\|^\)\(.\)', '\u\2', 'g')` < ActiveRecord::Migration
		def up
			${0}
		end

		def down
		end
	end
snippet migration class .. < ActiveRecord::Migration .. def change .. end
	class `substitute( substitute(vim_snippets#Filename(), '^\d\+_', '',''), '\(_\|^\)\(.\)', '\u\2', 'g')` < ActiveRecord::Migration
		def change
			${0}
		end
	end
snippet trc
	t.remove :${0:column}
snippet tre
	t.rename :${1:old_column_name}, :${2:new_column_name}
	${0}
snippet tref
	t.references :${0:model}
snippet tcb
	t.boolean :${1:title}
	${0}
snippet tcbi
	t.binary :${1:title}, limit: ${2:2}.megabytes
	${0}
snippet tcd
	t.decimal :${1:title}, precision: ${2:10}, scale: ${3:2}
	${0}
snippet tcda
	t.date :${1:title}
	${0}
snippet tcdt
	t.datetime :${1:title}
	${0}
snippet tcf
	t.float :${1:title}
	${0}
snippet tch
	t.change :${1:name}, :${2:string}, ${3:limit}: ${4:80}
	${0}
snippet tci
	t.integer :${1:title}
	${0}
snippet tcl
	t.integer :lock_version, null: false, default: 0
	${0}
snippet tcr
	t.references :${1:taggable}, polymorphic: { default: '${2:Photo}' }
	${0}
snippet tcs
	t.string :${1:title}
	${0}
snippet tct
	t.text :${1:title}
	${0}
snippet tcti
	t.time :${1:title}
	${0}
snippet tcts
	t.timestamp :${1:title}
	${0}
snippet tctss
	t.timestamps
	${0}
##########################
#     Rspec snippets     #
##########################
#ShouldaMatchers#ActionController
snippet isfp
	it { should filter_param :${0:key} }
snippet isrt
	it { should redirect_to ${0:url} }
snippet isrtp
	it { should render_template ${0} }
snippet isrwl
	it { should render_with_layout ${0} }
snippet isrf
	it { should rescue_from ${0:exception} }
snippet isrw
	it { should respond_with ${0:status} }
snippet isr
	it { should route(:${1:method}, '${0:path}') }
snippet isss
	it { should set_session :${0:key} }
snippet issf
	it { should set_the_flash('${0}') }
#ShouldaMatchers#ActiveModel
snippet isama
	it { should allow_mass_assignment_of :${0} }
snippet isav
	it { should allow_value(${1}).for :${0} }
snippet isee
	it { should ensure_exclusion_of :${0} }
snippet isei
	it { should ensure_inclusion_of :${0} }
snippet isel
	it { should ensure_length_of :${0} }
snippet isva
	it { should validate_acceptance_of :${0} }
snippet isvc
	it { should validate_confirmation_of :${0} }
snippet isvn
	it { should validate_numericality_of :${0} }
snippet isvp
	it { should validate_presence_of :${0} }
snippet isvu
	it { should validate_uniqueness_of :${0} }
#ShouldaMatchers#ActiveRecord
snippet isana
	it { should accept_nested_attributes_for :${0} }
snippet isbt
	it { should belong_to :${0} }
snippet isbtcc
	it { should belong_to(:${1}).counter_cache ${0:true} }
snippet ishbtm
	it { should have_and_belong_to_many :${0} }
snippet isbv
	it { should be_valid }
snippet ishc
	it { should have_db_column :${0} }
snippet ishi
	it { should have_db_index :${0} }
snippet ishm
	it { should have_many :${0} }
snippet ishmt
	it { should have_many(:${1}).through :${0} }
snippet isho
	it { should have_one :${0} }
snippet ishro
	it { should have_readonly_attribute :${0} }
snippet iss
	it { should serialize :${0} }
snippet isres
	it { should respond_to :${0} }
snippet isresw
	it { should respond_to(:${1}).with(${0}).arguments }
snippet super_call
	${1:super_class}.instance_method(:${0:method}).bind(self).call
./snippets/reason.snippets	[[[1
36
snippet doc
	/*
		${0}
	 */
snippet let
	let ${1} = ${0};
snippet fn
	let ${1} = (${2}) => {
		${0}
	};
snippet fun
	fun ${1} => ${0}
snippet ty
	type ${1} = ${0};
snippet mod
	module ${1} = {
		${0}
	};
snippet modty
	module type ${1} = {
		${0}
	};
snippet sw
	switch (${1}) {
	| ${2} => ${0}
	}
snippet |
	| ${1} => ${0}
snippet p
	|> ${0}
snippet if
	if (${1}) {
		${2}
	} else {
		${0}
	}
./snippets/rmd.snippets	[[[1
149
#
# Snipmate Snippets for Pandoc Markdown
#
# Many snippets have starred versions, i.e., versions
# that end with an asterisk (`*`). These snippets use
# vim's `"*` register---i.e., the contents of the
# system clipboard---to insert text.

extends markdown

# Insert Title Block
snippet %%
	% ${1:`Filename('', 'title')`}
	% ${2:`g:snips_author`}
	% ${3:`strftime("%d %B %Y")`}

	${4}
snippet %%*
	% ${1:`Filename('', @*)`}
	% ${2:`g:snips_author`}
	% ${3:`strftime("%d %b %Y")`}

	${4}

# library()
snippet req
	require(${1:}, quietly = TRUE)
# If Condition
snippet if
	if ( $1 )
	{
		${2:}
	}
snippet el
	else
	{
		${1:}
	}

# Function
snippet fun
	${1:funname} <- 			# ${2:}
		function
	(
	 	${3:}
	)
	{
	  ${4:}
	}
# repeat
snippet re
	repeat{
	  ${2:}
	  if($1) break
	}

# matrix
snippet ma
	matrix(NA, nrow = ${1:}, ncol = ${2:})

# data frame
snippet df
	data.frame(${1:}, header = TRUE)

snippet cmdarg
	args <- commandArgs(TRUE)
	if (length(args) == 0)
	    stop("Please give ${1:}!")
	if (!all(file.exists(args)))
	     stop("Couln't find input files!")

snippet getopt
	require('getopt', quietly = TRUE)
	opt_spec <- matrix(c(
					'help',     'h', 0, "logical", 	"Getting help",
					'file',     'f', 1, "character","File to process"
	                ), ncol = 5, byrow = TRUE)
	opt <- getopt(spec = opt_spec)
	if ( !is.null(opt$help) || is.null(commandArgs()) )   {
	    cat(getopt(spec = opt_spec, usage = TRUE, command = "yourCmd"))
	    q(status=0)
	}
	# some inital value
	if ( is.null(opt$???) )    { opt$??? <- ??? }

snippet optparse
	require("optparse", quietly = TRUE)
	option_list <-
	    list(make_option(c("-n", "--add_numbers"), action="store_true", default=FALSE,
	                     help="Print line number at the beginning of each line [default]")
	         )
	parser <- OptionParser(usage = "%prog [options] file", option_list=option_list)
	arguments <- parse_args(parser, positional_arguments = TRUE)
	opt <- arguments$options
	
	if(length(arguments$args) != 1) {
	    cat("Incorrect number of required positional arguments\n\n")
	    print_help(parser)
	    stop()
	} else {
	    file <- arguments$args
	}
	
	if( file.access(file) == -1) {
	    stop(sprintf("Specified file ( %s ) does not exist", file))
	} else {
	    file_text <- readLines(file)
	}

snippet #!
	#!/usr/bin/env Rscript

snippet debug
	# Development & Debugging, don't forget to uncomment afterwards!
	#--------------------------------------------------------------------------------
	#setwd("~/Projekte/${1:}")
	#opt <- list(${2:}
	#            )
	#--------------------------------------------------------------------------------


# Took from pandoc-plugin <<<<
# Underline with `=`s or `-`s
snippet #===
	#`repeat('=', strlen(getline(line(".") - 1)))`
	${1}
snippet #---
	#`repeat('-', strlen(getline(line(".") - 1)))`
	${1}

# >>>>

snippet r
	\`\`\`{r ${1:chung_tag}, echo = FALSE ${2:options}}
	${3:}
	\`\`\`
snippet ri
	\`{r ${1:}}\`

snippet copt
	\`\`\` {r setup, echo = FALSE}
		opts_chunk$set(fig.path='../figures/${1:}', cache.path='../cache/-'
		, fig.align='center', fig.show='hold', par=TRUE)	
		#opts_knit$set(upload.fun = imgur_upload) # upload images
	\`\`\`

	
# End of File ===================================================================
# vim: set noexpandtab:
./snippets/rst.snippets	[[[1
101
# rst

snippet :
	:${1:field name}: $0
snippet *
	*${1:Emphasis}* ${0}
snippet **
	**${1:Strong emphasis}** ${0}
snippet _
	\`${1:hyperlink-name}\`_
	.. _\`$1\`: ${0:link-block}
snippet =
	${1:Title}
	=====${2:=}
	${0}
snippet -
	${1:Title}
	-----${2:-}
	${0}
#some directive
snippet img:
	.. |${1:alias}| image:: ${0:img}
snippet fig:
	.. figure:: ${1:img}
		:alt: ${2:alter text}

		$0
snippet con:
	.. contents:: ${1:Table of Contents}

		${0:content}
snippet cod:
	.. code:: ${1:type}

		${0:write some code}
snippet tip:
	.. tip::
		${0:my tips}
snippet not:
	.. note::
		${0:my notes}
snippet	war:
	.. warning::
		${0:attention!}
snippet imp:
	.. important::
		${0:this is importatnt}
snippet att:
	.. attention::
		${0:hey!}
snippet dan:
	.. danger::
		${0:ah!}
snippet err:
	.. error::
		${0:Error occur}
snippet cau:
	.. caution::
		${0:Watch out!}
#Sphinx only
snippet sid:
	.. sidebar:: ${1:Title}

		${0}
snippet tod:
	.. todo::
		${0}
snippet lis:
	.. list-table:: ${1:Title}
		:header-rows: 1
		:stub-columns: 0

		* - ${0:R1C1}
		  - R1C2
		* - R2C1
		  - R2C2
snippet csv:
	.. csv-table:: ${1:Title}
		:header-rows: 1
		:stub-columns: 0

		${0:R1C1}, R1C2
		R2C1, R2C2
snippet toc:
	.. toctree::
		:maxdepth: 2

		${0}
snippet dow:
	:download:\`${1:text} <${0:path}>\`
snippet ref:
	:ref:\`${1:text} <${0:path}>\`
snippet doc:
	:doc:\`${1:text} <${0:path}>\`
# CJK optimize, CJK has no space between charaters
snippet *c
	\ *${1:Emphasis}*\ ${0}
snippet **c
	\ **${1:Strong emphasis}**\ ${0}

# vim:set list noet sts=0 sw=4 ts=4:
./snippets/ruby.snippets	[[[1
748
snippet enc
	# encoding: utf-8
snippet frozen
	# frozen_string_literal: true
snippet #!
	#!/usr/bin/env ruby
# New Block
snippet =b
	=begin rdoc
		${0}
	=end
snippet prot
	protected

	${0}
snippet priv
	private

	${0}
snippet y
	:yields: ${0:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU
snippet beg
	begin
		${0}
	rescue ${1:StandardError} => ${2:e}
	end
snippet req require
	require '${1}'
snippet reqr
	require_relative '${1}'
snippet #
	# =>
snippet case
	case ${1:object}
	when $2
		${0}
	end
snippet when
	when $1
		${0:${VISUAL}}
snippet def
	def ${1:method_name}
		${0}
	end
snippet defm
	def ${1:method}
		@$1 ||= ${0}
	end
snippet deft
	def test_${1:case_name}
		${0}
	end
snippet descendants
	class Class
		def descendants
			ObjectSpace.each_object(::Class).select { |klass| klass < self }
		end
	end
snippet if
	if $1
		${0:${VISUAL}}
	end
snippet ife
	if $1
		${2:${VISUAL}}
	else
		${0}
	end
snippet eif
	elsif $1
		${0:${VISUAL}}
snippet ifee
	if $1
		$2
	elsif $3
		$4
	else
		$0
	end
snippet unless
	unless $1
		${0:${VISUAL}}
	end
snippet unlesse
	unless $1
		$2
	else
		$0
	end
snippet unlesee
	unless $1
		$2
	elsif $3
		$4
	else
		$0
	end
snippet wh
	while $1
		${0:${VISUAL}}
	end
snippet for
	for ${1:e} in ${2:c}
		${0}
	end
snippet until
	until $1
		${0:${VISUAL}}
	end
snippet cla class .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${0}
	end
snippet clai class .. initialize .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		def initialize(${2:args})
			${0}
		end
	end
snippet cla< class .. < ParentClass .. initialize .. end
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < ${2:ParentClass}
		def initialize(${3:args})
			${0}
		end
	end
snippet blankslate class BlankSlate .. initialize .. end
	class ${0:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	end
snippet claself class << self .. end
	class << ${1:self}
		${0}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${0}
		end
	end
snippet mod module .. end
	module ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`}
		${0}
	end
# attr_reader
snippet r
	attr_reader :${0:attr_names}
# attr_writer
snippet w
	attr_writer :${0:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${0:attr_names}
snippet atp
	attr_protected :${0:attr_names}
snippet ata
	attr_accessible :${0:attr_names}
snippet ana
	accepts_nested_attributes_for :${0:association}
# ivc == instance variable cache
snippet ivc
	@${1:variable_name} ||= ${0:cached_value}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${0}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${0}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${0}
	end
# def initialize
snippet definit
	def initialize(${1:args})
		${0}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${0}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${0:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${0:del_methods}
snippet am
	alias_method :${1:new_name}, :${0:old_name}
snippet app
	if __FILE__ == \$PROGRAM_NAME
		${0}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{\$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${0}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{\$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${0}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${0} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${0} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:'path/to/file'}) { |${2:line}| ${0} }
snippet file File.read()
	File.read(${1:'path/to/file'})
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${0} }
snippet Dir Dir[".."]
	Dir[${1:'glob/**/*.rb'}]
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${0} }
snippet fil
	fill(${1:range}) { |${2:i}| ${0} }
# flatten_once()
snippet flao
	reduce(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2) }
snippet zip
	zip(${1:enums}) { |${2:row}| ${0} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${0} }
snippet ste
	step(${1:2}) { |${2:n}| ${0} }
snippet tim
	times { |${1:n}| ${0} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${0} }
snippet loo
	loop { ${0} }
snippet ea
	each { |${1:e}| ${0} }
snippet ead
	each do |${1:e}|
		${0}
	end
snippet eab
	each_byte { |${1:byte}| ${0} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${0} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${0} }
snippet eai
	each_index { |${1:i}| ${0} }
snippet eaid
	each_index do |${1:i}|
		${0}
	end
snippet eak
	each_key { |${1:key}| ${0} }
snippet eakd
	each_key do |${1:key}|
		${0}
	end
snippet eal
	each_line { |${1:line}| ${0} }
snippet eald
	each_line do |${1:line}|
		${0}
	end
snippet eap
	each_pair { |${1:name}, ${2:val}| ${0} }
snippet eapd
	each_pair do |${1:name}, ${2:val}|
		${0}
	end
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${0} }
snippet easd-
	each_slice(${1:2}) do |${2:group}|
		${0}
	end
snippet eav
	each_value { |${1:val}| ${0} }
snippet eavd
	each_value do |${1:val}|
		${0}
	end
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${0} }
snippet eawid
	each_with_index do |${1:e}, ${2:i}|
		${0}
	end
snippet eawo
	each_with_object(${1:init}) { |${2:e}, ${3:var}| ${0} }
snippet eawod
	each_with_object(${1:init}) do |${2:e}, ${3:var}|
		${0}
	end
snippet reve
	reverse_each { |${1:e}| ${0} }
snippet reved
	reverse_each do |${1:e}|
		${0}
	end
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${0} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${0}
	end
snippet red
	reduce(${1:init}) { |${2:mem}, ${3:var}| ${0} }
snippet redd
	reduce(${1:init}) do |${2:mem}, ${3:var}|
		${0}
	end
snippet map
	map { |${1:e}| ${0} }
snippet mapd
	map do |${1:e}|
		${0}
	end
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${0} }
snippet sor
	sort { |a, b| ${0} }
snippet sorb
	sort_by { |${1:e}| ${0} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${0} }
snippet any
	any? { |${1:e}| ${0} }
snippet cl
	classify { |${1:e}| ${0} }
snippet col
	collect { |${1:e}| ${0} }
snippet cold
	collect do |${1:e}|
		${0}
	end
snippet det
	detect { |${1:e}| ${0} }
snippet detd
	detect do |${1:e}|
		${0}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${0} }
snippet fin
	find { |${1:e}| ${0} }
snippet find
	find do |${1:e}|
		${0}
	end
snippet fina
	find_all { |${1:e}| ${0} }
snippet finad
	find_all do |${1:e}|
		${0}
	end
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${0} }
snippet grepv
	select { |${1:line}| $1 !~ ${2:/pattern/} }${0}
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${0} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${0} }
snippet scad
	scan(${1:/pattern/}) do |${2:match}|
		${0}
	end
snippet max
	max { |a, b| ${0} }
snippet min
	min { |a, b| ${0} }
snippet par
	partition { |${1:e}| ${0} }
snippet pard
	partition do |${1:e}|
		${0}
	end
snippet rej
	reject { |${1:e}| ${0} }
snippet rejd
	reject do |${1:e}|
		${0}
	end
snippet sel
	select { |${1:e}| ${0} }
snippet seld
	select do |${1:e}|
		${0}
	end
snippet lam
	lambda { |${1:args}| ${0} }
snippet ->
	-> { ${0} }
snippet ->a
	->(${1:args}) { ${0} }
# I'm pretty sure that ruby users expect do to expand to do .. end
snippet do
	do
		${0}
	end
# this is for one or more variables. typing a ", " is that cheap that it may
# not be worth adding another snippet. should 0/1 placeholders change order?
# its a good idea to think about the var name, so use it first
snippet dov
	do |${1:v}|
		${2}
	end
snippet :
	${1:key}: ${2:'value'}
snippet ope
	open('${1:path/or/url/or/pipe}', '${2:w}') { |${3:io}| ${0} }
# path_from_here()
snippet fpath
	File.join(File.dirname(__FILE__), *['${1:rel path here}'])
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${0}
	end
# option_parse {}
snippet optp
	require 'optparse'

	options = { ${0:default: 'args'} }

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename(\$PROGRAM_NAME)}"
	end
snippet opt
	opts.on('-${1:o}', '--${2:long-option-name}', ${3:String}, '${4:Option description.}') do |${5:opt}|
		${0}
	end
snippet tc
	require 'test/unit'

	require '${1:library_file_name}'

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${0}
		end
	end
snippet ts
	require 'test/unit'

	require 'tc_${1:test_case_file}'
	require 'tc_${2:test_case_file}'
snippet as
	assert ${1:test}, '${2:Failure message.}'
snippet ase
	assert_equal ${1:expected}, ${2:actual}
snippet asne
	assert_not_equal ${1:unexpected}, ${2:actual}
snippet asid
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2**-20}
snippet asi
	assert_includes ${1:collection}, ${2:object}
snippet asio
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
snippet asko
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
snippet asn
	assert_nil ${1:instance}
snippet asnn
	assert_not_nil ${1:instance}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})
snippet aso
	assert_operator ${1:left}, :${2:operator}, ${3:right}
snippet asr
	assert_raises(${1:StandardError}) { ${0} }
snippet asrd
	assert_raises ${1:StandardError} do
		${0}
	end
snippet asnr
	assert_nothing_raised(${1:StandardError}) { ${0} }
snippet asnrd
	assert_nothing_raised ${1:StandardError} do
		${0}
	end
snippet asrt
	assert_respond_to ${1:object}, :${2:method}
snippet ass assert_same(..)
	assert_same ${1:expected}, ${2:actual}
snippet asss assert_send(..)
	assert_send [${1:object}, :${2:message}, ${3:args}]
snippet asns
	assert_not_same ${1:unexpected}, ${2:actual}
snippet ast
	assert_throws :${1:expected}, -> { ${0} }
snippet astd
	assert_throws :${1:expected} do
		${0}
	end
snippet asnt
	assert_nothing_thrown { ${0} }
snippet asntd
	assert_nothing_thrown do
		${0}
	end
snippet fl
	flunk '${1:Failure message.}'
snippet rf
	refute ${1:test}, '${2:Failure message.}'
snippet rfe
	refute_equal ${1:unexpected}, ${2:actual}
snippet rfko
	refute_kind_of ${1:UnexpectedKind}, ${2:actual_instance}
snippet rfn
	refute_nil ${1:instance}
snippet rfo
	refute_operator ${1:left}, :${2:operator}, ${3:right}
snippet rfi
	refute_includes ${1:collection}, ${2:object}
snippet rfid
	refute_in_delta ${1:unexpected_float}, ${2:actual_float}, ${3:2**-20}
snippet rfio
	refute_instance_of ${1:UnexpectedClass}, ${2:actual_instance}
snippet rfs
	refute_same ${1:unexpected}, ${2:actual}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${0}
	end
snippet rep
	results.report('${1:name}:') { TESTS.times { ${0} } }
# Marshal.dump(.., file)
snippet Md
	File.open('${1:path/to/file.dump}', 'wb') { |${2:file}| Marshal.dump(${3:obj}, $2) }
# Mashal.load(obj)
snippet Ml
	File.open('${1:path/to/file.dump}', 'rb') { |${2:file}| Marshal.load($2) }
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))
snippet Pn-
	PStore.new('${1:file_name.pstore}')
snippet tra
	transaction(${1:true}) { ${0} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read('${1:path/to/file}'))
# xpath(..) { .. }
snippet xpa
	elements.each('${1://Xpath}') do |${2:node}|
		${0}
	end
# class_from_name()
snippet clafn
	split('::').inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`vim_snippets#Filename()`} do
		${0}
	end
snippet tas
	desc '${1:Task description}'
	task ${2:task_name: [:dependent, :tasks]} do
		${0}
	end
# block
snippet b
	{ |${1:var}| ${0} }
snippet begin
	begin
		fail 'A test exception.'
	rescue StandardError => e
		puts e.message
		puts e.backtrace.inspect
	else
		# other exception
	ensure
		# always executed
	end

#debugging
snippet debug
	require 'byebug'; byebug
snippet dbg
	require 'debug'; debugger
snippet debug19
	require 'debugger'; debugger
snippet debug18
	require 'ruby-debug'; debugger
snippet pry
	require 'pry'; binding.pry
snippet strf
	strftime('${1:%Y-%m-%d %H:%M:%S %z}')${0}
#
# Minitest snippets
#
snippet mb
	must_be ${0}
snippet wb
	wont_be ${0}
snippet mbe
	must_be_empty
snippet wbe
	wont_be_empty
snippet mbio
	must_be_instance_of ${0:Class}
snippet wbio
	wont_be_instance_of ${0:Class}
snippet mbko
	must_be_kind_of ${0:Class}
snippet wbko
	wont_be_kind_of ${0:Class}
snippet mbn
	must_be_nil
snippet wbn
	wont_be_nil
snippet mbsa
	must_be_same_as ${0:other}
snippet wbsa
	wont_be_same_as ${0:other}
snippet mbsi
	-> { ${0} }.must_be_silent
snippet mbwd
	must_be_within_delta ${1:0.1}, ${2:0.1}
snippet wbwd
	wont_be_within_delta ${1:0.1}, ${2:0.1}
snippet mbwe
	must_be_within_epsilon ${1:0.1}, ${2:0.1}
snippet wbwe
	wont_be_within_epsilon ${1:0.1}, ${2:0.1}
snippet me
	must_equal ${0:other}
snippet we
	wont_equal ${0:other}
snippet mi
	must_include ${0:what}
snippet wi
	wont_include ${0:what}
snippet mm
	must_match /${0:regex}/
snippet wm
	wont_match /${0:regex}/
snippet mout
	-> { ${1} }.must_output '${0}'
snippet mra
	-> { ${1} }.must_raise ${0:StandardError}
snippet mrt
	must_respond_to :${0:method}
snippet wrt
	wont_respond_to :${0:method}
snippet msend
	must_send [ ${1:what}, :${2:method}, ${3:args} ]
snippet mthrow
	-> { throw :${1:error} }.must_throw :${2:error}
##########################
#     Rspec snippets     #
##########################
snippet desc
	describe ${1:`substitute(substitute(vim_snippets#Filename(), '_spec$', '', ''), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet rdesc
	RSpec.describe ${1:`substitute(substitute(vim_snippets#Filename(), '_spec$', '', ''), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet descm
	describe '${1:#method}' do
		${0:pending 'Not implemented'}
	end
snippet cont
	context '${1:message}' do
		${0}
	end
snippet bef
	before :${1:each} do
		${0}
	end
snippet aft
	after :${1:each} do
		${0}
	end
snippet let
	let(:${1:object}) { ${0} }
snippet let!
	let!(:${1:object}) { ${0} }
snippet subj
	subject { ${0} }
snippet s.
	subject.${0:method}
snippet spec
	specify { subject.${0} }
snippet exp
	expect(${1:object}).to ${0}
snippet expb
	expect { ${1:object} }.to ${0}
snippet experr
	expect { ${1:object} }.to raise_error ${2:StandardError}, /${0:message_regex}/
snippet allow
	allow(${1:object}).to ${0}
snippet shared
	shared_examples ${0:'shared examples name'}
snippet ibl
	it_behaves_like ${0:'shared examples name'}
snippet it
	it '${1:spec_name}' do
		${0}
	end
snippet its
	its(:${1:method}) { should ${0} }
snippet is
	it { should ${0} }
snippet isn
	it { should_not ${0} }
snippet iexp
	it { expect(${1:object}).${2} ${0} }
snippet iexpb
	it { expect { ${1:object} }.${2} ${0} }
snippet iiexp
	it { is_expected.to ${0} }
snippet iiexpn
	it { is_expected.not_to ${0} }
snippet agg
	aggregate_failures '${1:message}' do
		${0}
	end
./snippets/rust.snippets	[[[1
252
#################
# Rust Snippets #
#################

# Functions
snippet fn "Function definition"
	fn ${1:function_name}(${2})${3} {
		${0}
	}
snippet pfn "Function definition"
	pub fn ${1:function_name}(${2})${3} {
		${0}
	}
snippet afn "Async function definition"
	async fn ${1:function_name}(${2})${3} {
		${0}
	}
snippet pafn "Async function definition"
	pub async fn ${1:function_name}(${2})${3} {
		${0}
	}
snippet bench "Bench function" b
	#[bench]
	fn ${1:bench_function_name}(b: &mut test::Bencher) {
		b.iter(|| {
			${0}
		})
	}
snippet new "Constructor function"
	pub fn new(${2}) -> ${1:Self} {
		$1 { ${3} }
	}
snippet main "Main function"
	pub fn main() {
		${0}
	}
snippet let "let variable declaration with type inference"
	let ${1} = ${2};
snippet lett "let variable declaration with explicit type annotation"
	let ${1}: ${2} = ${3};
snippet letm "let mut variable declaration with type inference"
	let mut ${1} = ${2};
snippet lettm "let mut variable declaration with explicit type annotation"
	let mut ${1}: ${2} = ${3};
snippet pri "print!"
	print!("${1}");
snippet pri, "print! with format param"
	print!("${1}{${2}}", ${3});
snippet pln "println!"
	println!("${1}");
snippet pln, "println! with format param"
	println!("${1}{${2}}", ${3});
snippet fmt "format!"
	format!("${1}{${2}}", ${3});
snippet d "dbg! debugging macro"
	dbg!(${0:${VISUAL}})
snippet d; "dbg! debugging macro statement"
	dbg!(&${1});
	${0}
# Modules
snippet ec "extern crate"
	extern crate ${1:sync};
snippet ecl "extern crate log"
	#[macro_use]
	extern crate log;
snippet mod
	mod ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	} /* $1 */
# Testing
snippet as "assert!"
	assert!(${1:predicate});
snippet ase "assert_eq!"
	assert_eq!(${1:expected}, ${2:actual});
snippet test "Unit test function"
	#[test]
	fn ${1:function_name}_test() {
		${0}
	}
snippet testmod "Test module" b
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}
snippet ig "#[ignore]"
	#[ignore]
# Attributes
snippet allow "allow lint attribute" b
	#[allow(${1:unused_variables})]
snippet cfg "cfg attribute" b
	#[cfg(${1:target_os = "linux"})]
snippet feat "feature attribute" b
	#![feature(${1:plugin})]
snippet der "#[derive(..)]" b
	#[derive(${1:Debug})]
snippet attr "#[..]" b
	#[${1:inline}]
snippet crate "Define create meta attributes"
	// Crate name
	#![crate_name = "${1:crate_name}"]
	// Additional metadata attributes
	#![desc = "${2:Description.}"]
	#![license = "${3:BSD}"]
	#![comment = "${4:Comment.}"]
	// Specify the output type
	#![crate_type = "${5:lib}"]
# Common types
snippet opt "Option<T>"
	Option<${1:i32}>
snippet res "Result<T, E>"
	Result<${1:&str}, ${2:()}>
# Control structures
snippet if
	if ${1} {
		${0:${VISUAL}}
	}
snippet ife "if / else"
	if ${1} {
		${2:${VISUAL}}
	} else {
		${0}
	}
snippet ifl "if let (...)"
	if let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
snippet el "else"
	else {
		${0:${VISUAL}}
	}
snippet eli "else if"
	else if ${1} {
		${0:${VISUAL}}
	}
snippet mat "match pattern"
	match ${1} {
		${2} => ${3}
	}
snippet case "Case clause of pattern match"
	${1:_} => ${2:expression}
snippet = "=> "
	=> $0
snippet loop "loop {}" b
	loop {
		${0:${VISUAL}}
	}
snippet wh "while loop"
	while $1 {
		${0:${VISUAL}}
	}
snippet whl "while let (...)"
	while let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
snippet for "for ... in ... loop"
	for ${1:i} in ${2} {
		${0}
	}
# TODO commenting
snippet todo "TODO comment"
	// TODO: $0
snippet fixme "FIXME comment"
	// FIXME: $0
# Struct
snippet st "Struct definition"
	struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	}
snippet impl "Struct/Trait implementation"
	impl ${1:Type/Trait}${2: for $3} {
		${0}
	}
snippet stn "Struct with new constructor"
	pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
		${0}
	}

	impl$2 $1$2 {
		pub fn new(${4}) -> Self {
			$1 { ${5} }
		}
	}
snippet ty "Type alias"
	type ${1:NewName} = $2;
snippet enum "enum definition"
	enum ${1:Name} {
		${2},
	}
snippet penum "pub enum definition"
	pub enum ${1:Name} {
		${2},
	}
# Traits
snippet trait "Trait definition"
	trait ${1:Name} {
		${0}
	}
snippet drop "Drop trait implementation (destructor)"
	impl Drop for $1 {
		fn drop(&mut self) {
			${0}
		}
	}
# Statics
snippet ss "static string declaration"
	static ${1}: &'static str = "${0}";
snippet stat "static item declaration"
	static ${1}: ${2:usize} = ${0};
# Concurrency
snippet spawn "spawn a thread"
	thread::spawn(${1:move }|| {
		${0}
	});
snippet chan "Declare (Sender, Receiver) pair of asynchronous channel()"
	let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();
# Implementations
snippet asref "AsRef trait implementation"
	impl AsRef<${1:Ref}> for ${2:Type} {
		fn as_ref(&self) -> &${3:$1} {
			&self.${0:field}
		}
	}
snippet asmut "AsMut trait implementation"
	impl AsMut<${1:Ref}> for ${2:Type} {
		fn as_mut(&mut self) -> &mut ${3:$1} {
			&mut self.${0:field}
		}
	}
snippet fd "Struct field definition" w
	${1:name}: ${2:Type},
snippet || "Closure, anonymous function (inline)" i
	${1:move }|$2| { $3 }
snippet |} "Closure, anonymous function (block)" i
	${1:move }|$2| {
		$3
	}
snippet macro "macro_rules!" b
	macro_rules! ${1:name} {
		(${2:matcher}) => (
			$3
		)
	}
snippet boxp "Box::new()"
	Box::new(${0:${VISUAL}})
snippet rc "Rc::new()"
	Rc::new(${0:${VISUAL}})
snippet unim "unimplemented!()"
	unimplemented!()
snippet use "use ...;" b
	use ${1:std::$2};
./snippets/sass.snippets	[[[1
1243
snippet $
	$${1:variable}: ${0:value}
snippet imp
	@import '${0}'
snippet mix
	=${1:name}(${2})
		${0}
snippet inc
	+${1:mixin}(${2})
snippet ext
	@extend ${0}
snippet fun
	@function ${1:name}(${2:args})
		${0}
snippet if
	@if $1
		${0:${VISUAL}}
snippet ife
	@if $1
		${2:${VISUAL}}
	@else
		${0}
snippet eif
	@else if $1
		${0:${VISUAL}}
snippet for
	@for ${1:$i} from ${2:1} through ${3:3}
		${0}
snippet each
	@each ${1:$item} in ${2:items}
		${0}
snippet while
	@while ${1:$i} ${2:>} ${3:0}
		${0:${VISUAL}}
snippet !
	 !important
snippet ac
	align-content: ${0}
snippet ac:s
	align-content: start
snippet ac:e
	align-content: end
snippet ac:c
	align-content: center
snippet ac:fs
	align-content: flex-start
snippet ac:fe
	align-content: flex-end
snippet ac:sb
	align-content: space-between
snippet ac:sa
	align-content: space-around
snippet ac:se
	align-content: space-evenly
snippet ac:st
	align-content: stretch
snippet ac:b
	align-content: baseline
snippet ac:fb
	align-content: first baseline
snippet ac:lb
	align-content: last baseline
snippet ai
	align-items: ${0}
snippet ai:s
	align-items: start
snippet ai:e
	align-items: end
snippet ai:c
	align-items: center
snippet ai:fs
	align-items: flex-start
snippet ai:fe
	align-items: flex-end
snippet ai:st
	align-items: stretch
snippet ai:b
	align-items: baseline
snippet ai:fb
	align-items: first baseline
snippet ai:lb
	align-items: last baseline
snippet as
	align-self: ${0}
snippet as:s
	align-self: start
snippet as:e
	align-self: end
snippet as:c
	align-self: center
snippet as:st
	align-self: stretch
snippet as:fs
	align-self: flex-start
snippet as:fe
	align-self: flex-end
snippet as:b
	align-self: baseline
snippet as:fb
	align-self: first baseline
snippet as:lb
	align-self: last baseline
snippet bdi:m+
	-moz-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:m
	-moz-border-image: ${0}
snippet bdrz:m
	-moz-border-radius: ${0}
snippet bxsh:m+
	-moz-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}
snippet bxsh:m
	-moz-box-shadow: ${0}
snippet bdi:w+
	-webkit-border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:w
	-webkit-border-image: ${0}
snippet bdrz:w
	-webkit-border-radius: ${0}
snippet bxsh:w+
	-webkit-box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}
snippet bxsh:w
	-webkit-box-shadow: ${0}
snippet @f
	@font-face
		font-family: ${1}
		src: url('${0}')
snippet @i
	@import url('${0}')
snippet @m
	@media ${1:print}
		${0}
snippet bg+
	background: #${1:fff} url('${2}') ${3:0} ${4:0} ${0:no-repeat}
snippet bga
	background-attachment: ${0}
snippet bga:f
	background-attachment: fixed
snippet bga:s
	background-attachment: scroll
snippet bgbk
	background-break: ${0}
snippet bgbk:bb
	background-break: bounding-box
snippet bgbk:c
	background-break: continuous
snippet bgbk:eb
	background-break: each-box
snippet bgcp
	background-clip: ${0}
snippet bgcp:bb
	background-clip: border-box
snippet bgcp:cb
	background-clip: content-box
snippet bgcp:nc
	background-clip: no-clip
snippet bgcp:pb
	background-clip: padding-box
snippet bgc
	background-color: #${0:fff}
snippet bgc:t
	background-color: transparent
snippet bgi
	background-image: url('${0}')
snippet bgi:n
	background-image: none
snippet bgo
	background-origin: ${0}
snippet bgo:bb
	background-origin: border-box
snippet bgo:cb
	background-origin: content-box
snippet bgo:pb
	background-origin: padding-box
snippet bgpx
	background-position-x: ${0}
snippet bgpy
	background-position-y: ${0}
snippet bgp
	background-position: ${1:0} ${0:0}
snippet bgr
	background-repeat: ${0}
snippet bgr:n
	background-repeat: no-repeat
snippet bgr:x
	background-repeat: repeat-x
snippet bgr:y
	background-repeat: repeat-y
snippet bgr:r
	background-repeat: repeat
snippet bgz
	background-size: ${0}
snippet bgz:a
	background-size: auto
snippet bgz:ct
	background-size: contain
snippet bgz:cv
	background-size: cover
snippet bg
	background: ${0}
snippet bg:ie
	filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')
snippet bg:n
	background: none
snippet bd+
	border: ${1:1px} ${2:solid} #${0:000}
snippet bdb+
	border-bottom: ${1:1px} ${2:solid} #${0:000}
snippet bdbc
	border-bottom-color: #${0:000}
snippet bdbi
	border-bottom-image: url('${0}')
snippet bdbi:n
	border-bottom-image: none
snippet bdbli
	border-bottom-left-image: url('${0}')
snippet bdbli:c
	border-bottom-left-image: continue
snippet bdbli:n
	border-bottom-left-image: none
snippet bdblrz
	border-bottom-left-radius: ${0}
snippet bdbri
	border-bottom-right-image: url('${0}')
snippet bdbri:c
	border-bottom-right-image: continue
snippet bdbri:n
	border-bottom-right-image: none
snippet bdbrrz
	border-bottom-right-radius: ${0}
snippet bdbs
	border-bottom-style: ${0}
snippet bdbs:n
	border-bottom-style: none
snippet bdbw
	border-bottom-width: ${0}
snippet bdb
	border-bottom: ${0}
snippet bdb:n
	border-bottom: none
snippet bdbk
	border-break: ${0}
snippet bdbk:c
	border-break: close
snippet bdcl
	border-collapse: ${0}
snippet bdcl:c
	border-collapse: collapse
snippet bdcl:s
	border-collapse: separate
snippet bdc
	border-color: #${0:000}
snippet bdci
	border-corner-image: url('${0}')
snippet bdci:c
	border-corner-image: continue
snippet bdci:n
	border-corner-image: none
snippet bdf
	border-fit: ${0}
snippet bdf:c
	border-fit: clip
snippet bdf:of
	border-fit: overwrite
snippet bdf:ow
	border-fit: overwrite
snippet bdf:r
	border-fit: repeat
snippet bdf:sc
	border-fit: scale
snippet bdf:sp
	border-fit: space
snippet bdf:st
	border-fit: stretch
snippet bdi
	border-image: url('${1}') ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:n
	border-image: none
snippet bdl+
	border-left: ${1:1px} ${2:solid} #${0:000}
snippet bdlc
	border-left-color: #${0:000}
snippet bdli
	border-left-image: url('${0}')
snippet bdli:n
	border-left-image: none
snippet bdls
	border-left-style: ${0}
snippet bdls:n
	border-left-style: none
snippet bdlw
	border-left-width: ${0}
snippet bdl
	border-left: ${0}
snippet bdl:n
	border-left: none
snippet bdlt
	border-length: ${0}
snippet bdlt:a
	border-length: auto
snippet bdrz
	border-radius: ${0}
snippet bdr+
	border-right: ${1:1px} ${2:solid} #${0:000}
snippet bdrc
	border-right-color: #${0:000}
snippet bdri
	border-right-image: url('${0}')
snippet bdri:n
	border-right-image: none
snippet bdrs
	border-right-style: ${0}
snippet bdrs:n
	border-right-style: none
snippet bdrw
	border-right-width: ${0}
snippet bdr
	border-right: ${0}
snippet bdr:n
	border-right: none
snippet bdsp
	border-spacing: ${0}
snippet bds
	border-style: ${0}
snippet bds:ds
	border-style: dashed
snippet bds:dtds
	border-style: dot-dash
snippet bds:dtdtds
	border-style: dot-dot-dash
snippet bds:dt
	border-style: dotted
snippet bds:db
	border-style: double
snippet bds:g
	border-style: groove
snippet bds:h
	border-style: hidden
snippet bds:i
	border-style: inset
snippet bds:n
	border-style: none
snippet bds:o
	border-style: outset
snippet bds:r
	border-style: ridge
snippet bds:s
	border-style: solid
snippet bds:w
	border-style: wave
snippet bdt+
	border-top: ${1:1px} ${2:solid} #${0:000}
snippet bdtc
	border-top-color: #${0:000}
snippet bdti
	border-top-image: url('${0}')
snippet bdti:n
	border-top-image: none
snippet bdtli
	border-top-left-image: url('${0}')
snippet bdtli:c
	border-corner-image: continue
snippet bdtli:n
	border-corner-image: none
snippet bdtlrz
	border-top-left-radius: ${0}
snippet bdtri
	border-top-right-image: url('${0}')
snippet bdtri:c
	border-top-right-image: continue
snippet bdtri:n
	border-top-right-image: none
snippet bdtrrz
	border-top-right-radius: ${0}
snippet bdts
	border-top-style: ${0}
snippet bdts:n
	border-top-style: none
snippet bdtw
	border-top-width: ${0}
snippet bdt
	border-top: ${0}
snippet bdt:n
	border-top: none
snippet bdw
	border-width: ${0}
snippet bd
	border: ${0}
snippet bd:n
	border: none
snippet b
	bottom: ${0}
snippet b:a
	bottom: auto
snippet bxsh+
	box-shadow: ${1:0} ${2:0} ${3:0} #${0:000}
snippet bxsh
	box-shadow: ${0}
snippet bxsh:n
	box-shadow: none
snippet bxz
	box-sizing: ${0}
snippet bxz:bb
	box-sizing: border-box
snippet bxz:cb
	box-sizing: content-box
snippet cps
	caption-side: ${0}
snippet cps:b
	caption-side: bottom
snippet cps:t
	caption-side: top
snippet cl
	clear: ${0}
snippet cl:b
	clear: both
snippet cl:l
	clear: left
snippet cl:n
	clear: none
snippet cl:r
	clear: right
snippet cp
	clip: ${0}
snippet cp:a
	clip: auto
snippet cp:r
	clip: rect(${1:0} ${2:0} ${3:0} ${0:0})
snippet c
	color: #${0:000}
snippet ct
	content: ${0}
snippet ct:a
	content: attr(${0})
snippet ct:cq
	content: close-quote
snippet ct:c
	content: counter(${0})
snippet ct:cs
	content: counters(${0})
snippet ct:ncq
	content: no-close-quote
snippet ct:noq
	content: no-open-quote
snippet ct:n
	content: normal
snippet ct:oq
	content: open-quote
snippet coi
	counter-increment: ${0}
snippet cor
	counter-reset: ${0}
snippet cur
	cursor: ${0}
snippet cur:a
	cursor: auto
snippet cur:c
	cursor: crosshair
snippet cur:d
	cursor: default
snippet cur:ha
	cursor: hand
snippet cur:he
	cursor: help
snippet cur:m
	cursor: move
snippet cur:p
	cursor: pointer
snippet cur:t
	cursor: text
snippet d
	display: ${0}
snippet d:mib
	display: -moz-inline-box
snippet d:mis
	display: -moz-inline-stack
snippet d:b
	display: block
snippet d:cp
	display: compact
snippet d:g
	display: grid
snippet d:f
	display: flex
snippet d:ib
	display: inline-block
snippet d:itb
	display: inline-table
snippet d:i
	display: inline
snippet d:li
	display: list-item
snippet d:n
	display: none
snippet d:ri
	display: run-in
snippet d:tbcp
	display: table-caption
snippet d:tbc
	display: table-cell
snippet d:tbclg
	display: table-column-group
snippet d:tbcl
	display: table-column
snippet d:tbfg
	display: table-footer-group
snippet d:tbhg
	display: table-header-group
snippet d:tbrg
	display: table-row-group
snippet d:tbr
	display: table-row
snippet d:tb
	display: table
snippet ec
	empty-cells: ${0}
snippet ec:h
	empty-cells: hide
snippet ec:s
	empty-cells: show
snippet exp
	expression()
snippet fl
	float: ${0}
snippet fl:l
	float: left
snippet fl:n
	float: none
snippet fl:r
	float: right
snippet f+
	font: ${1:1em} ${2:Arial},${0:sans-serif}
snippet fef
	font-effect: ${0}
snippet fef:eb
	font-effect: emboss
snippet fef:eg
	font-effect: engrave
snippet fef:n
	font-effect: none
snippet fef:o
	font-effect: outline
snippet femp
	font-emphasize-position: ${0}
snippet femp:a
	font-emphasize-position: after
snippet femp:b
	font-emphasize-position: before
snippet fems
	font-emphasize-style: ${0}
snippet fems:ac
	font-emphasize-style: accent
snippet fems:c
	font-emphasize-style: circle
snippet fems:ds
	font-emphasize-style: disc
snippet fems:dt
	font-emphasize-style: dot
snippet fems:n
	font-emphasize-style: none
snippet fem
	font-emphasize: ${0}
snippet ff
	font-family: ${0}
snippet ff:c
	font-family: ${0:'Monotype Corsiva','Comic Sans MS'},cursive
snippet ff:f
	font-family: ${0:Capitals,Impact},fantasy
snippet ff:m
	font-family: ${0:Monaco,'Courier New'},monospace
snippet ff:ss
	font-family: ${0:Helvetica,Arial},sans-serif
snippet ff:s
	font-family: ${0:Georgia,'Times New Roman'},serif
snippet fza
	font-size-adjust: ${0}
snippet fza:n
	font-size-adjust: none
snippet fz
	font-size: ${0}
snippet fsm
	font-smooth: ${0}
snippet fsm:aw
	font-smooth: always
snippet fsm:a
	font-smooth: auto
snippet fsm:n
	font-smooth: never
snippet fst
	font-stretch: ${0}
snippet fst:c
	font-stretch: condensed
snippet fst:e
	font-stretch: expanded
snippet fst:ec
	font-stretch: extra-condensed
snippet fst:ee
	font-stretch: extra-expanded
snippet fst:n
	font-stretch: normal
snippet fst:sc
	font-stretch: semi-condensed
snippet fst:se
	font-stretch: semi-expanded
snippet fst:uc
	font-stretch: ultra-condensed
snippet fst:ue
	font-stretch: ultra-expanded
snippet fs
	font-style: ${0}
snippet fs:i
	font-style: italic
snippet fs:n
	font-style: normal
snippet fs:o
	font-style: oblique
snippet fv
	font-variant: ${0}
snippet fv:n
	font-variant: normal
snippet fv:sc
	font-variant: small-caps
snippet fw
	font-weight: ${0}
snippet fw:b
	font-weight: bold
snippet fw:br
	font-weight: bolder
snippet fw:lr
	font-weight: lighter
snippet fw:n
	font-weight: normal
snippet f
	font: ${0}
snippet g
	grid: ${0}
snippet gaf
	grid-auto-flow: ${0}
snippet gaf+
	grid-auto-flow: ${1:row} ${0:dense}
snippet gaf:r
	grid-auto-flow: row
snippet gaf:c
	grid-auto-flow: column
snippet gaf:d
	grid-auto-flow: dense
snippet gaf:rd
	grid-auto-flow: row dense
snippet gaf:cd
	grid-auto-flow: column dense
snippet gar
	grid-auto-rows: ${0}
snippet gar:a
	grid-auto-rows: auto
snippet gar:mac
	grid-auto-rows: max-content
snippet gar:mic
	grid-auto-rows: min-content
snippet gac
	grid-auto-columns: ${0}
snippet gac:a
	grid-auto-columns: auto
snippet gac:mac
	grid-auto-columns: max-content
snippet gac:mic
	grid-auto-columns: min-content
snippet gt
	grid-template: ${0}
snippet gt+
	grid-template: ${1} / ${0}
snippet gtr
	grid-template-rows: ${0}
snippet gtc
	grid-template-columns: ${0}
snippet gta
	grid-template-areas: ${0}
snippet gg
	grid-gap: ${0}
snippet gg+
	grid-gap: ${1} ${0}
snippet gg:0
	grid-gap: 0
snippet grg
	grid-row-gap: ${0}
snippet grg:0
	grid-row-gap: 0
snippet gcg
	grid-column-gap: ${0}
snippet gcg:0
	grid-column-gap: 0
snippet gr
	grid-row: ${1} / ${0}
snippet grs
	grid-row-start: ${0}
snippet gre
	grid-row-end: ${0}
snippet gc
	grid-column: ${1} / ${0}
snippet gcs
	grid-column-start: ${0}
snippet gce
	grid-column-end: ${0}
snippet h
	height: ${0}
snippet h:a
	height: auto
snippet jc
	justify-content: ${0}
snippet jc:s
	justify-content: start
snippet jc:e
	justify-content: end
snippet jc:c
	justify-content: center
snippet jc:fs
	justify-content: flex-start
snippet jc:fe
	justify-content: flex-end
snippet jc:sb
	justify-content: space-between
snippet jc:sa
	justify-content: space-around
snippet jc:se
	justify-content: space-evenly
snippet jc:st
	justify-content: stretch
snippet jc:l
	justify-content: left
snippet jc:r
	justify-content: right
snippet ji
	justify-items: ${0}
snippet ji:s
	justify-items: start
snippet ji:e
	justify-items: end
snippet ji:c
	justify-items: center
snippet ji:st
	justify-items: stretch
snippet js
	justify-self: ${0}
snippet js:s
	justify-self: start
snippet js:e
	justify-self: end
snippet js:c
	justify-self: center
snippet js:st
	justify-self: stretch
snippet l
	left: ${0}
snippet l:a
	left: auto
snippet lts
	letter-spacing: ${0}
snippet lh
	line-height: ${0}
snippet lisi
	list-style-image: url('${0}')
snippet lisi:n
	list-style-image: none
snippet lisp
	list-style-position: ${0}
snippet lisp:i
	list-style-position: inside
snippet lisp:o
	list-style-position: outside
snippet list
	list-style-type: ${0}
snippet list:c
	list-style-type: circle
snippet list:dclz
	list-style-type: decimal-leading-zero
snippet list:dc
	list-style-type: decimal
snippet list:d
	list-style-type: disc
snippet list:lr
	list-style-type: lower-roman
snippet list:n
	list-style-type: none
snippet list:s
	list-style-type: square
snippet list:ur
	list-style-type: upper-roman
snippet lis
	list-style: ${0}
snippet lis:n
	list-style: none
snippet mb
	margin-bottom: ${0}
snippet mb:a
	margin-bottom: auto
snippet ml
	margin-left: ${0}
snippet ml:a
	margin-left: auto
snippet mr
	margin-right: ${0}
snippet mr:a
	margin-right: auto
snippet mt
	margin-top: ${0}
snippet mt:a
	margin-top: auto
snippet m
	margin: ${0}
snippet m:4
	margin: ${1:0} ${2:0} ${3:0} ${0:0}
snippet m:3
	margin: ${1:0} ${2:0} ${0:0}
snippet m:2
	margin: ${1:0} ${0:0}
snippet m:0
	margin: 0
snippet m:a
	margin: auto
snippet mah
	max-height: ${0}
snippet mah:n
	max-height: none
snippet maw
	max-width: ${0}
snippet maw:n
	max-width: none
snippet mih
	min-height: ${0}
snippet miw
	min-width: ${0}
snippet op
	opacity: ${0}
snippet op:ie
	filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})
snippet op:ms
	-ms-filter: 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'
snippet orp
	orphans: ${0}
snippet o+
	outline: ${1:1px} ${2:solid} #${0:000}
snippet oc
	outline-color: ${0:#000}
snippet oc:i
	outline-color: invert
snippet oo
	outline-offset: ${0}
snippet os
	outline-style: ${0}
snippet ow
	outline-width: ${0}
snippet o
	outline: ${0}
snippet o:n
	outline: none
snippet ovs
	overflow-style: ${0}
snippet ovs:a
	overflow-style: auto
snippet ovs:mq
	overflow-style: marquee
snippet ovs:mv
	overflow-style: move
snippet ovs:p
	overflow-style: panner
snippet ovs:s
	overflow-style: scrollbar
snippet ovx
	overflow-x: ${0}
snippet ovx:a
	overflow-x: auto
snippet ovx:h
	overflow-x: hidden
snippet ovx:s
	overflow-x: scroll
snippet ovx:v
	overflow-x: visible
snippet ovy
	overflow-y: ${0}
snippet ovy:a
	overflow-y: auto
snippet ovy:h
	overflow-y: hidden
snippet ovy:s
	overflow-y: scroll
snippet ovy:v
	overflow-y: visible
snippet ov
	overflow: ${0}
snippet ov:a
	overflow: auto
snippet ov:h
	overflow: hidden
snippet ov:s
	overflow: scroll
snippet ov:v
	overflow: visible
snippet pb
	padding-bottom: ${0}
snippet pl
	padding-left: ${0}
snippet pr
	padding-right: ${0}
snippet pt
	padding-top: ${0}
snippet p
	padding: ${0}
snippet p:4
	padding: ${1:0} ${2:0} ${3:0} ${0:0}
snippet p:3
	padding: ${1:0} ${2:0} ${0:0}
snippet p:2
	padding: ${1:0} ${0:0}
snippet p:0
	padding: 0
snippet pc
	place-content: ${0}
snippet pc+
	place-content: ${1} ${0}
snippet pc:s
	place-content: start
snippet pc:e
	place-content: end
snippet pc:c
	place-content: center
snippet pc:fs
	place-content: flex-start
snippet pc:fe
	place-content: flex-end
snippet pc:sb
	place-content: space-between
snippet pc:sa
	place-content: space-around
snippet pc:se
	place-content: space-evenly
snippet pc:st
	place-content: stretch
snippet pgba
	page-break-after: ${0}
snippet pgba:aw
	page-break-after: always
snippet pgba:a
	page-break-after: auto
snippet pgba:l
	page-break-after: left
snippet pgba:r
	page-break-after: right
snippet pgbb
	page-break-before: ${0}
snippet pgbb:aw
	page-break-before: always
snippet pgbb:a
	page-break-before: auto
snippet pgbb:l
	page-break-before: left
snippet pgbb:r
	page-break-before: right
snippet pgbi
	page-break-inside: ${0}
snippet pgbi:a
	page-break-inside: auto
snippet pgbi:av
	page-break-inside: avoid
snippet pi
	place-items: ${0}
snippet pi+
	place-items: ${1:stretch} ${0:stretch}
snippet pi:s
	place-items: start
snippet pi:e
	place-items: end
snippet pi:c
	place-items: center
snippet pi:st
	place-items: stretch
snippet pos
	position: ${0}
snippet pos:a
	position: absolute
snippet pos:f
	position: fixed
snippet pos:r
	position: relative
snippet pos:s
	position: static
snippet ps
	place-self: ${0}
snippet ps+
	place-self: ${1:stretch} ${0:stretch}
snippet ps:s
	place-self: start
snippet ps:e
	place-self: end
snippet ps:c
	place-self: center
snippet ps:st
	place-self: stretch
snippet q
	quotes: ${0}
snippet q:en
	quotes: '\201C' '\201D' '\2018' '\2019'
snippet q:n
	quotes: none
snippet q:ru
	quotes: '\00AB' '\00BB' '\201E' '\201C'
snippet rz
	resize: ${0}
snippet rz:b
	resize: both
snippet rz:h
	resize: horizontal
snippet rz:n
	resize: none
snippet rz:v
	resize: vertical
snippet r
	right: ${0}
snippet r:a
	right: auto
snippet tbl
	table-layout: ${0}
snippet tbl:a
	table-layout: auto
snippet tbl:f
	table-layout: fixed
snippet tal
	text-align-last: ${0}
snippet tal:a
	text-align-last: auto
snippet tal:c
	text-align-last: center
snippet tal:l
	text-align-last: left
snippet tal:r
	text-align-last: right
snippet ta
	text-align: ${0}
snippet ta:c
	text-align: center
snippet ta:l
	text-align: left
snippet ta:r
	text-align: right
snippet td
	text-decoration: ${0}
snippet td:l
	text-decoration: line-through
snippet td:n
	text-decoration: none
snippet td:o
	text-decoration: overline
snippet td:u
	text-decoration: underline
snippet te
	text-emphasis: ${0}
snippet te:ac
	text-emphasis: accent
snippet te:a
	text-emphasis: after
snippet te:b
	text-emphasis: before
snippet te:c
	text-emphasis: circle
snippet te:ds
	text-emphasis: disc
snippet te:dt
	text-emphasis: dot
snippet te:n
	text-emphasis: none
snippet th
	text-height: ${0}
snippet th:a
	text-height: auto
snippet th:f
	text-height: font-size
snippet th:m
	text-height: max-size
snippet th:t
	text-height: text-size
snippet ti
	text-indent: ${0}
snippet ti:-
	text-indent: -9999px
snippet tj
	text-justify: ${0}
snippet tj:a
	text-justify: auto
snippet tj:d
	text-justify: distribute
snippet tj:ic
	text-justify: inter-cluster
snippet tj:ii
	text-justify: inter-ideograph
snippet tj:iw
	text-justify: inter-word
snippet tj:k
	text-justify: kashida
snippet tj:t
	text-justify: tibetan
snippet to+
	text-outline: ${1:0} ${2:0} #${0:000}
snippet to
	text-outline: ${0}
snippet to:n
	text-outline: none
snippet tr
	text-replace: ${0}
snippet tr:n
	text-replace: none
snippet tsh+
	text-shadow: ${1:0} ${2:0} ${3:0} #${0:000}
snippet tsh
	text-shadow: ${0}
snippet tsh:n
	text-shadow: none
snippet tt
	text-transform: ${0}
snippet tt:c
	text-transform: capitalize
snippet tt:l
	text-transform: lowercase
snippet tt:n
	text-transform: none
snippet tt:u
	text-transform: uppercase
snippet tw
	text-wrap: ${0}
snippet tw:no
	text-wrap: none
snippet tw:n
	text-wrap: normal
snippet tw:s
	text-wrap: suppress
snippet tw:u
	text-wrap: unrestricted
snippet t
	top: ${0}
snippet t:a
	top: auto
snippet va
	vertical-align: ${0}
snippet va:bl
	vertical-align: baseline
snippet va:b
	vertical-align: bottom
snippet va:m
	vertical-align: middle
snippet va:sub
	vertical-align: sub
snippet va:sup
	vertical-align: super
snippet va:tb
	vertical-align: text-bottom
snippet va:tt
	vertical-align: text-top
snippet va:t
	vertical-align: top
snippet v
	visibility: ${0}
snippet v:c
	visibility: collapse
snippet v:h
	visibility: hidden
snippet v:v
	visibility: visible
snippet whsc
	white-space-collapse: ${0}
snippet whsc:ba
	white-space-collapse: break-all
snippet whsc:bs
	white-space-collapse: break-strict
snippet whsc:k
	white-space-collapse: keep-all
snippet whsc:l
	white-space-collapse: loose
snippet whsc:n
	white-space-collapse: normal
snippet whs
	white-space: ${0}
snippet whs:n
	white-space: normal
snippet whs:nw
	white-space: nowrap
snippet whs:pl
	white-space: pre-line
snippet whs:pw
	white-space: pre-wrap
snippet whs:p
	white-space: pre
snippet wid
	widows: ${0}
snippet w
	width: ${0}
snippet w:a
	width: auto
snippet wob
	word-break: ${0}
snippet wob:ba
	word-break: break-all
snippet wob:bs
	word-break: break-strict
snippet wob:k
	word-break: keep-all
snippet wob:l
	word-break: loose
snippet wob:n
	word-break: normal
snippet wos
	word-spacing: ${0}
snippet wow
	word-wrap: ${0}
snippet wow:no
	word-wrap: none
snippet wow:n
	word-wrap: normal
snippet wow:s
	word-wrap: suppress
snippet wow:u
	word-wrap: unrestricted
snippet z
	z-index: ${0}
snippet z:a
	z-index: auto
snippet zoo
	zoom: 1
snippet :h
	:hover
snippet :fc
	:first-child
snippet :lc
	:last-child
snippet :nc
	:nth-child(${0})
snippet :nlc
	:nth-last-child(${0})
snippet :oc
	:only-child
snippet :a
	:after
snippet :b
	:before
snippet ::a
	::after
snippet ::b
	::before
./snippets/scala.snippets	[[[1
364
################################################################
# © Copyright 2011 Konstantin Gorodinskiy. All Rights Reserved.#
# Do What The Fuck You Want To Public License, Version 2.      #
# See http://sam.zoy.org/wtfpl/COPYING for more details.       #
################################################################
# Scala lang
#if
snippet if
	if (${1})
		${0:${VISUAL}}
#if not
snippet ifn
	if (!${1})
		${0:${VISUAL}}
#if-else
snippet ife
	if (${1})
		${2:${VISUAL}}
	else
		${0}
#if-else-if
snippet ifelif
	if (${1})
		${2:${VISUAL}}
	else if (${3})
		${0:${VISUAL}}
snippet eif
	else if (${3})
		${0:${VISUAL}}
#while loop
snippet wh
	while (${1:obj}) {
		${0:${VISUAL}}
	}
#for loop(classic)
snippet for
	for (${1:item} <- ${2:obj}) {
		${0}
	}
#for loop(indexed)
snippet fori
	for (${1:i} <- ${2:0} to ${3:obj}.length) {
		${0}
	}
#for comprehension
snippet fory
	for {
		${1:item} <- ${2:obj}
	} yield ${0}
#exceptions
snippet try
	try {
		${1:${VISUAL}}
	} catch {
		case e: FileNotFoundException => ${2}
		case e: IOException => ${3}
	} finally {
		${0}
	}
#match
snippet mat
	${1:${VISUAL}} match {
		case ${2} => ${0}
	}
snippet match
	${1: obj} match {
		case ${2:e} => ${3}
		case _ => ${0}
	}
#case
snippet case
	case ${1:${VISUAL}} => ${0}
############################
# methods and arguments
#
#arg
snippet arg
	${1:a}: ${2:T}${0:, arg}
#args
snippet args
	${1:args}: ${0:T}*
#def
snippet def
	def ${1:name}(${2:arg}) = ${0:}
#private def
snippet prdef
	private def ${1:name}(${2:arg}) = ${0:}
#override def
snippet ovdef
	override def ${1:name}(${2:arg}) = ${0:}
#first class function(see scalabook p 188)
snippet fcf
	(${1:a}: ${2:T}) => $1 ${0}
snippet =>
	${1:name} => ${0}
#recursion
snippet rec
	def ${1:name}(${0:arg}) =
		if($2) $2
		else $1($2)
#curried method
snippet crdef
	def ${1:name}(${2:arg})(${3:arg}) = ${0:}
#main method
#check validity of T
snippet main
	def main(args: Array[String]):${1:T} = ${0:}
############################
# basic types(general purpose)
# you might want to use basic types snippets

#1
snippet T Double
	dbl
#2
snippet T Int
	int
#3
snippet T Long
	lng
#4
snippet T Char
	chr
#5
snippet T String
	str
#6
snippet T Array
	arr
#7
snippet T Buffer
	buf
#8
snippet T List
	list
#9
snippet T Tuple
	tpl
#10
snippet T Set
	set
#11
snippet T Map
	map
#12
snippet T HashSet
	hset
#13
snippet T HashMap
	hmap
#14
snippet T Boolean
	bool
#end

#named snippets for types
snippet bool
	Boolean
snippet anyr
	AnyRef
snippet dbl
	Double
snippet int
	Int
snippet str
	String
snippet chr
	Char
snippet lng
	Long
snippet arr
	Array${1:[T]}${0:()}
snippet buf
	Buffer${1:[T]}${0:()}
snippet list
	List${1:[T]}${0:()}
snippet tpl
	Tuple${1:2}[${2:T},${0:T}]
snippet set
	Set${1:[T]}${0:()}
snippet hset
	HashSet${1:[T]}${0:()}
snippet mhset
	mutable.HashSet${1:[T]}${0:()}
#for maps
snippet keyval
	${1:key}->${2:val}${0:, keyval}
snippet map
	Map[${1:T},${2:T}]${0:(keyval)}
snippet hmap
	HashMap[${1:T},${2:T}]${0:(keyval)}
snippet mmap
	mutable.Map[${1:T},${2:T}]${0:(keyval)}
snippet mhmap
	mutable.HashMap[${1:T},${2:T}]${0:(keyval)}
#TODO add TreeMap and TreeSet
#asInstanceOf[]
snippet as
	${1:name}.asInstanceOf[${2:T}]
#isInstanceOf[]
snippet is
	${1:name}.isInstanceOf[${2:T}]

#collections methods

#scope() with one arg
snippet (a
	(${1:a} => ${0})
#scope() with two args
snippet {(
	{(${1:a},${2:b}) =>
		${0}
	}
#filter
snippet filter
	${0:name}.filter (a
#map function
snippet mapf
	${0:name}.map (a
#flatmap
snippet flatmap
	${1:name}.flatMap${0:[T]}(a
#fold left
snippet fldl
	${1:name}.foldLeft(${0:first}) {(
#fold right
snippet fldr
	${1:name}.foldRight(${0:first}) {(
#fold left operator(if u wanna reduce readability of ur code)
#use wildcard symbols
snippet /:
	(${1:first}/:${2:name})(${0})
#fold right operator
snippet :\
	(${1:first}:\${2:name})(${0})
#reduce left
snippet redl
	${1:name}.reduceLeft[${0:T}] {(
#reduce right
snippet redr
	${1:name}.reduceRight[${0:T}] {(
#zipWithIndex(safe way).
#see http://daily-scala.blogspot.com/2010/05/zipwithindex.html
snippet zipwi
	${0:name}.view.zipWithIndex
#split
snippet spl
	${1:name}.split("${0:,}")
#end
snippet val
	val ${1:name}${2:: T} = ${0:value}
snippet var
	var ${1:name}${2:: T} = ${0:value}
############################
# classes
#
#extends
snippet extends
	extends ${0:what}
#with
snippet with
	with ${1:what}${0: with}
#auxiliary constructor(a. this)
snippet athis
	def this(arg) = this(arg)
#abstract class
snippet abstract
	abstract class ${1:name}${2:(arg)}${3: extends }${4: with} {
		${5:override def toString = "$1"}
		${0}
	}
#class
snippet class
	class ${1:name}${2:(arg)}${3: extends }${4: with} {
		${5:override def toString = "$1"}
		${0}
	}
#object
snippet object
	object ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}
#trait
snippet trait
	trait ${1:name}${2: extends }${3: with} {
		${0:}
	}
#class with trait Ordered(page 265)
snippet ordered
	class ${1:name}${2:(arg)} extends Ordered[$1] ${3: with} {
		${4:override def toString = "$1"}
		def compare(that: $1) = ${5:this - that}
		${0}
	}
#case class
snippet casecl
	case class ${1:name}${2:(arg)}${3: extends }${4: with} ${0:}
############################
# testing
#
#scalatest imports
snippet scalatest
	${1:import org.scalatest.Suite}
	${0:import org.scalatest.FunSuite}
#assert
snippet assert
	assert(${1:a} === ${0:b})
#ensuring(p 296)
snippet ensuring
	ifel ensuring(${1:a}==${0:b})
#expect
snippet expect
	expect(${1:what}) {
		${0}
	}
#intercept
snippet intercept
	intercept[${1:IllegalArgumentException}] {
		${0}
	}
#test
snippet test
	test("${1:description}") {
		${0}
	}
#suite
snippet suite
	class ${0:name} extends Suite {
		def test() {
	}
#funsuite
snippet fsuite
	class ${1:name} extends FunSuite {
		test("${0:description}") {
	}
############################
# SBT
#
snippet webproject
	import sbt._

	class ${1:Name}(info: ProjectInfo) extends DefaultWebProject(info) {
		val liftVersion = "${0:2.3}"

		override def libraryDependencies = Set(

		) ++ super.libraryDependencies

		val snapshots = ScalaToolsSnapshots
	}
#depencies
snippet liftjar
	"net.liftweb" %% "${0:lib}" % liftVersion % "compile->default",
snippet jettyjar
	"org.mortbay.jetty" % "jetty" % "${0:version}" % "test->default",
############################
# Lift
#
#lift imports
snippet liftimports
	import _root_.net.liftweb.http._
	import S._
	import _root_.net.liftweb.util._
	import Helpers._
	import _root_.scala.xml._
#TODO LIFT,SBT,WEB.XML,HTML snippets
./snippets/scheme.snippets	[[[1
36
snippet +
	(+ ${1}
		${0})

snippet -
	(- ${1}
		${0})

snippet /
	(/ ${1}
		${0})

snippet *
	(* ${1}
		${0})

# Definition
snippet def
	(define (${1:name})
			${0:definition})

# Definition with lambda
snippet defl
	(define ${1:name}
		(lambda (x)(${0:definition})))

# Condition
snippet cond
	(cond ((${1:predicate}) (${2:action}))
		((${3:predicate}) (${0:action})))

# If statement
snippet if
	(if (${1:predicate})
		(${2:true-action})
		(${0:false-action}))
./snippets/scss.snippets	[[[1
44
extends css

snippet $
	$${1:variable}: ${0:value};
snippet imp
	@import '${0}';
snippet mix
	@mixin ${1:name}(${2}) {
		${0}
	}
snippet inc
	@include ${1:mixin}(${2});
snippet ext
	@extend ${0};
snippet fun
	@function ${1:name}(${2:args}) {
		${0}
	}
snippet if
	@if $1 {
		${0}
	}
snippet ife
	@if $1 {
		${2}
	} @else {
		${0}
	}
snippet eif
	@else if $1 {
		${0}
	}
snippet for
	@for ${1:$i} from ${2:1} through ${3:3} {
		${0}
	}
snippet each
	@each ${1:$item} in ${2:items} {
		${0}
	}
snippet while
	@while ${1:$i} ${2:>} ${3:0} {
		${0}
	}
./snippets/sh.snippets	[[[1
110
# Shebang
snippet #!
	#!/bin/sh

snippet s#!
	#!/bin/sh
	set -eu

snippet safe
	set -eu

snippet bash
	#!/usr/bin/env bash

snippet sbash
	#!/usr/bin/env bash
	set -euo pipefail
	IFS=$'\n\t'

snippet if
	if [ $1 ]; then
		${0:${VISUAL}}
	fi
snippet elif
	elif [ $1 ]; then
		${0:${VISUAL}}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${0:${VISUAL}}
	done
snippet fori
	for ${1:needle} in ${2:haystack} ; do
		${0:${VISUAL}}
	done
snippet wh
	while [ $1 ]; do
		${0:${VISUAL}}
	done
snippet wht
	while true; do
		${0:${VISUAL}}
	done
snippet until
	until [ $1 ]; do
		${0:${VISUAL}}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${0};;
	esac
snippet go
	while getopts '${1:o}' ${2:opts}
	do
		case $$2 in
		${3:o0})
			${0:#staments};;
		esac
	done
# Set SCRIPT_DIR variable to directory script is located.
snippet sdir
	SCRIPT_DIR="\$( cd "\$( dirname "\${BASH_SOURCE[0]}" )" && pwd )"
# getopt
snippet getopt
	__ScriptVersion="${1:version}"

	#===  FUNCTION  ================================================================
	#         NAME:  usage
	#  DESCRIPTION:  Display usage information.
	#===============================================================================
	function usage ()
	{
		echo "Usage :  \$${0:0} [options] [--]

	    Options:
	    -h|help       Display this message
	    -v|version    Display script version"

	}    # ----------  end of function usage  ----------

	#-----------------------------------------------------------------------
	#  Handle command line arguments
	#-----------------------------------------------------------------------

	while getopts ":hv" opt
	do
	  case \$opt in

		h|help     )  usage; exit 0   ;;

		v|version  )  echo "\$${0:0} -- Version \$__ScriptVersion"; exit 0   ;;

		* )  echo -e "\\n  Option does not exist : \$OPTARG\\n"
			  usage; exit 1   ;;

	  esac    # --- end of case ---
	done
	shift \$(($OPTIND-1))
snippet root
	if [ \$(id -u) -ne 0 ]; then exec sudo \$0; fi

snippet fun-sh
	${1:function_name}() {
		$0
	}

snippet fun
	function ${1:function_name}() {
		$0
	}
./snippets/simplemvcf.snippets	[[[1
122
snippet sm_controller
	<?php
		namespace Controllers;
		use Core\View;
		use Core\Controller;

		class ${1:class_name} extends Controller
		{
			public function __construct()
			{
				parent::__construct();
			}

			public function index()
			{
				${2:}
			}
		}
snippet sm_model
	<?php 
		namespace Models;
	 
		use Core\Model;
	  
		class ${1:class_name} extends Model 
		{    
			function __construct()
			{
				parent::__construct();
			}  
		}
snippet sm_model_crud
	<?php 
		namespace Models;

		use Core\Model;

		class ${1:class_name} extends Model 
		{    
			private $${2:table};
			function __construct()
			{
				parent::__construct();
			}  
			
			public function getRow($where)
			{
				return $this->db->select('SELECT * FROM '.$table.' WHERE ${3:where}', $data);
			}

			public function getRows($where)
			{
				return $this->db->select('SELECT * FROM '.$table.');
			}

			public function insert($data)
			{
				$this->db->insert($table, $data);
			}

			public function update($data, $where)
			{
				$this->db->update($table ,$data, $where);
			}

			public function delete($where)
			{
				$this->db->delete($table, $where);
			}
		}
snippet sm_render
	View::render('${1:view}', $${2:array});
snippet sm_render_template
	View::renderTemplate('${1:part}', $${2:array});

# database
snippet sm_db_select
	$this->db->select(${1:sql}, ${2:where});

snippet sm_db_insert
	$this->db->insert(${1:table}, ${2:data});

snippet sm_db_update
	$this->db->update(${1:table}, ${2:data}, ${3:where});

snippet sm_db_delete
	$this->db->delete(${1:table}, ${2:where});

snippet sm_db_truncate
	$this->db->delete(${1:table});

#session
snippet sm_session_set
	Session::set(${1:key}, ${2:value});

snippet sm_session_get
	Session::get(${1:key});

snippet sm_session_pull
	Session::pull(${1:key});

snippet sm_session_id
	Session::id();

snippet sm_session_destroy
	Session::set(${1:key});
	
snippet sm_session_display
	Session::display();

#url
snippet sm_url_redirect
	Url:redirect('${1:path}');

snippet sm_url_previous
	Url:previous();

snippet sm_url_templatepath
	Url:templatePath();

snippet sm_url_autolink
	Url:autolink('${1:string}');
./snippets/slim.snippets	[[[1
63
snippet pry
	- binding.pry
snippet renp
	= render partial: '${0}'
# Forms
# =====
snippet fieldset
	fieldset
		legend ${1}
snippet css
	link rel="stylesheet" href="${1:style.css}" type="text/css" media="${2:all}"
snippet script
	script src="${1:script.js}" type="text/javascript"
# Some useful Unicode entities
# ============================
# Non-Breaking Space
snippet nbs
	&nbsp;
# ←
snippet left
	&#x2190;
# →
snippet right
	&#x2192;
# ↑
snippet up
	&#x2191;
# ↓
snippet down
	&#x2193;
# ↩
snippet return
	&#x21A9;
# ⇤
snippet backtab
	&#x21E4;
# ⇥
snippet tab
	&#x21E5;
# ⇧
snippet shift
	&#x21E7;
# ⌃
snippet ctrl
	&#x2303;
# ⌅
snippet enter
	&#x2305;
# ⌘
snippet cmd
	&#x2318;
# ⌥
snippet option
	&#x2325;
# ⌦
snippet delete
	&#x2326;
# ⌫
snippet backspace
	&#x232B;
# ⎋
snippet esc
	&#x238B;
./snippets/smarty.snippets	[[[1
139
# snippets for smarty3

extends html
extends javascript
extends css

# https://www.smarty.net/docs/en/language.function.if.tpl
snippet if "{if cond} ... {/if}"
	{if ${1}}
		${0:${VISUAL}}
	{/if}

snippet ifn "{if !cond} ... {/if}"
	{if ${1}}
		${0:${VISUAL}}
	{/if}

snippet ife "{if cond} ... {else} ... {/if}"
	{if ${1}}
		${0:${VISUAL}}
	{else}
		${2}
	{/if}

snippet eif "{elseif cond} ... {/if}"
	{elseif ${1}}
		${0:${VISUAL}}
	{/if}

snippet el "{else} ... {/if}"
	{else}
		${1}
	{/if}

# https://www.smarty.net/docs/en/language.function.for.tpl
snippet for "The {for} tag is used to create simple loops."
	{for $${1:var}=${2:start} to ${3:end}${4: step ${5}}${6: max=${7}}}
		${0:${VISUAL}}
	{/for}

snippet forelse "The {for}{forelse} tag is used to create simple loops."
	{for $${1:var}=${2:start} to ${3:end}${4: step ${5}}${6: max=${7}}}
		${0:${VISUAL}}
	{forelse}
		${8}
	{/for}

# https://www.smarty.net/docs/en/language.function.foreach.tpl
snippet foreach "{foreach} is used for looping over arrays of data."
	{foreach $${1:array_variable} as $${2:var_or_key}${3: => $${4:itemvar}}}
		${0:${VISUAL}}
	{/foreach}

snippet foreach2 "[Smarty2] {foreach} is used for looping over arrays of data."
	{foreach from=$${1:collection} item='${2}'${3: key='${4}'}${5: name='${6}'}}
		${0:${VISUAL}}
	{/foreach}

snippet foreachelse "{foreach} is used for looping over arrays of data."
	{foreach $${1:array_variable} as $${2:var_or_key}${3: => $${4:itemvar}}}
		${0:${VISUAL}}
	{foreachelse}
		${5}
	{/foreach}

snippet wh "{while} loops in Smarty have much the same flexibility as PHP while statements, with a few added features for the template engine. Every {while} must be paired with a matching {/while}. All PHP conditionals and functions are recognized, such as ||, or, &&, and, is_array(), etc."
	{while ${1}}
		${0:${VISUAL}}
	{/while}



# https://www.smarty.net/docs/en/language.function.append.tpl
#snippet append implemented in UltiSnips format

# https://www.smarty.net/docs/en/language.function.assign.tpl
#snippet assign implemented in UltiSnips format

# https://www.smarty.net/docs/en/language.function.block.tpl
snippet block "{block} is used to define a named area of template source for template inheritance."
	{block name='${1}'}
		${0:${VISUAL}}
	{/block}

# https://www.smarty.net/docs/en/language.function.call.tpl
snippet call "{call} is used to call a template function defined by the {function} tag just like a plugin function."
	{call name=${1}${2: assign=${3}}${4: variables}}

# https://www.smarty.net/docs/en/language.function.capture.tpl
snippet capture "{capture} is used to collect the output of the template between the tags into a variable instead of displaying it. Any content between {capture name='foo'} and {/capture} is collected into the variable specified in the name attribute. "
	{capture name='${1}'${2: assign='${3}' }${4: append='${5:array_variable}'}}
		${0:${VISUAL}}
	{/capture}

# https://www.smarty.net/docs/en/language.function.config.load.tpl
#snippet config_load implemented in UltiSnips format

# https://www.smarty.net/docs/en/language.function.extends.tpl
snippet extends "{extends} tags are used in child templates in template inheritance for extending parent templates."
	{extends file='${1}'}

# https://www.smarty.net/docs/en/language.function.function.tpl
snippet function "{function} is used to create functions within a template and call them just like a plugin function. Instead of writing a plugin that generates presentational content, keeping it in the template is often a more manageable choice. It also simplifies data traversal, such as deeply nested menus."
	{function name='${1}' ${2:variables}}
		${0:${VISUAL}}
	{/function}

# https://www.smarty.net/docs/en/language.function.include.tpl
#snippet include implemented in UltiSnips format

# https://www.smarty.net/docs/en/language.function.literal.tpl
snippet literal "{literal} tags allow a block of data to be taken literally. This is typically used around Javascript or stylesheet blocks where {curly braces} would interfere with the template delimiter syntax"
	{literal}
		${0:${VISUAL}}
	{/literal}

# https://www.smarty.net/docs/en/language.function.nocache.tpl
snippet nocache "{nocache} is used to disable caching of a template section. Every {nocache} must be paired with a matching {/nocache}."
	{nocache}
		${0:${VISUAL}}
	{/nocache}

# https://www.smarty.net/docs/en/language.function.section.tpl
snippet section "A {section} is for looping over sequentially indexed arrays of data, unlike {foreach} which is used to loop over a single associative array. Every {section} tag must be paired with a closing {/section} tag."
	{section name='${1}'${2: loop='${3}'}${4: start=${5}}${6: step=${7}}${8: max=${9}}${10: show=${11}}}
		${0:${VISUAL}}
	{/section}

# https://www.smarty.net/docs/en/language.function.setfilter.tpl
snippet setfilter "The {setfilter}...{/setfilter} block tag allows the definition of template instance's variable filters."
	{setfilter ${1:filters}}
		${0:${VISUAL}}
	{/setfilter}

# https://www.smarty.net/docs/en/language.function.strip.tpl
snippet strip "Anything within {strip}{/strip} tags are stripped of the extra spaces or carriage returns at the beginnings and ends of the lines before they are displayed. This way you can keep your templates readable, and not worry about extra white space causing problems."
	{strip}
		${0:${VISUAL}}
	{/strip}
./snippets/snippets.snippets	[[[1
8
# snippets for making snippets :)
snippet snip
	snippet ${1:trigger} "${2:description}"
		${0:${VISUAL}}
snippet v
	{VISUAL}
snippet $
	${${1:1}:${0:text}}
./snippets/sql.snippets	[[[1
26
snippet tbl
	create table ${1:table} (
		${0:columns}
	);
snippet col
	${1:name}	${2:type}	${3:default ''}	${0:not null}
snippet ccol
	${1:name}	varchar2(${2:size})	${3:default ''}	${0:not null}
snippet ncol
	${1:name}	number	${3:default 0}	${0:not null}
snippet dcol
	${1:name}	date	${3:default sysdate}	${0:not null}
snippet ind
	create index ${0:$1_$2} on ${1:table}(${2:column});
snippet uind
	create unique index ${1:name} on ${2:table}(${0:column});
snippet tblcom
	comment on table ${1:table} is '${0:comment}';
snippet colcom
	comment on column ${1:table}.${2:column} is '${0:comment}';
snippet addcol
	alter table ${1:table} add (${2:column} ${0:type});
snippet seq
	create sequence ${1:name} start with ${2:1} increment by ${3:1} minvalue ${0:1};
snippet s*
	select * from ${0:table}
./snippets/stylus.snippets	[[[1
1221
snippet !
	!important
snippet ac
	align-content ${0}
snippet ac:s
	align-content start
snippet ac:e
	align-content end
snippet ac:c
	align-content center
snippet ac:fs
	align-content flex-start
snippet ac:fe
	align-content flex-end
snippet ac:sb
	align-content space-between
snippet ac:sa
	align-content space-around
snippet ac:se
	align-content space-evenly
snippet ac:st
	align-content stretch
snippet ac:b
	align-content baseline
snippet ac:fb
	align-content first baseline
snippet ac:lb
	align-content last baseline
snippet ai
	align-items ${0}
snippet ai:s
	align-items start
snippet ai:e
	align-items end
snippet ai:c
	align-items center
snippet ai:fs
	align-items flex-start
snippet ai:fe
	align-items flex-end
snippet ai:st
	align-items stretch
snippet ai:b
	align-items baseline
snippet ai:fb
	align-items first baseline
snippet ai:lb
	align-items last baseline
snippet as
	align-self ${0}
snippet as:s
	align-self start
snippet as:e
	align-self end
snippet as:c
	align-self center
snippet as:st
	align-self stretch
snippet as:fs
	align-self flex-start
snippet as:fe
	align-self flex-end
snippet as:b
	align-self baseline
snippet as:fb
	align-self first baseline
snippet as:lb
	align-self last baseline
snippet bdi:m+
	-moz-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:m
	-moz-border-image ${0}
snippet bdrz:m
	-moz-border-radius ${0}
snippet bxsh:m+
	-moz-box-shadow ${1:0} ${2:0} ${3:0} ${0}
snippet bxsh:m
	-moz-box-shadow ${0}
snippet bdi:w+
	-webkit-border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:w
	-webkit-border-image ${0}
snippet bdrz:w
	-webkit-border-radius ${0}
snippet bxsh:w+
	-webkit-box-shadow ${1:0} ${2:0} ${3:0} ${0}
snippet bxsh:w
	-webkit-box-shadow ${0}
snippet @f
	@font-face ${0}
snippet @i
	@import '${0}'
snippet @r
	@require '${0}'
snippet @m
	@media ${1:screen}
snippet @msmw
	@media screen and (min-width: ${0}px)
snippet @ext
	@extend .${1}
	${0}
snippet bg+
	background ${1} url(${2}) ${3:0} ${4:0} ${0:no-repeat}
snippet bga
	background-attachment ${0}
snippet bga:f
	background-attachment fixed
snippet bga:s
	background-attachment scroll
snippet bgbk
	background-break ${0}
snippet bgbk:bb
	background-break bounding-box
snippet bgbk:c
	background-break continuous
snippet bgbk:eb
	background-break each-box
snippet bgcp
	background-clip ${0}
snippet bgcp:bb
	background-clip border-box
snippet bgcp:cb
	background-clip content-box
snippet bgcp:nc
	background-clip no-clip
snippet bgcp:pb
	background-clip padding-box
snippet bgc
	background-color ${0}
snippet bgc:t
	background-color transparent
snippet bgi
	background-image url(${0})
snippet bgi:n
	background-image none
snippet bgo
	background-origin ${0}
snippet bgo:bb
	background-origin border-box
snippet bgo:cb
	background-origin content-box
snippet bgo:pb
	background-origin padding-box
snippet bgpx
	background-position-x ${0}
snippet bgpy
	background-position-y ${0}
snippet bgp
	background-position ${1:0} ${0:0}
snippet bgr
	background-repeat ${0}
snippet bgr:n
	background-repeat no-repeat
snippet bgr:x
	background-repeat repeat-x
snippet bgr:y
	background-repeat repeat-y
snippet bgr:r
	background-repeat repeat
snippet bgz
	background-size ${0}
snippet bgz:a
	background-size auto
snippet bgz:ct
	background-size contain
snippet bgz:cv
	background-size cover
snippet bg
	background ${0}
snippet bg:ie
	filter progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1}',sizingMethod='${0:crop}')
snippet bg:n
	background none
snippet bd+
	border ${1:1px} ${2:solid} ${0}
snippet bdb+
	border-bottom ${1:1px} ${2:solid} ${0}
snippet bdbc
	border-bottom-color ${0}
snippet bdbi
	border-bottom-image url(${0})
snippet bdbi:n
	border-bottom-image none
snippet bdbli
	border-bottom-left-image url(${0})
snippet bdbli:c
	border-bottom-left-image continue
snippet bdbli:n
	border-bottom-left-image none
snippet bdblrz
	border-bottom-left-radius ${0}
snippet bdbri
	border-bottom-right-image url(${0})
snippet bdbri:c
	border-bottom-right-image continue
snippet bdbri:n
	border-bottom-right-image none
snippet bdbrrz
	border-bottom-right-radius ${0}
snippet bdbs
	border-bottom-style ${0}
snippet bdbs:n
	border-bottom-style none
snippet bdbw
	border-bottom-width ${0}
snippet bdb
	border-bottom ${0}
snippet bdb:n
	border-bottom none
snippet bdbk
	border-break ${0}
snippet bdbk:c
	border-break close
snippet bdcl
	border-collapse ${0}
snippet bdcl:c
	border-collapse collapse
snippet bdcl:s
	border-collapse separate
snippet bdc
	border-color ${0}
snippet bdci
	border-corner-image url(${0})
snippet bdci:c
	border-corner-image continue
snippet bdci:n
	border-corner-image none
snippet bdf
	border-fit ${0}
snippet bdf:c
	border-fit clip
snippet bdf:of
	border-fit overwrite
snippet bdf:ow
	border-fit overwrite
snippet bdf:r
	border-fit repeat
snippet bdf:sc
	border-fit scale
snippet bdf:sp
	border-fit space
snippet bdf:st
	border-fit stretch
snippet bdi
	border-image url(${1}) ${2:0} ${3:0} ${4:0} ${5:0} ${6:stretch} ${0:stretch}
snippet bdi:n
	border-image none
snippet bdl+
	border-left ${1:1px} ${2:solid} ${0}
snippet bdlc
	border-left-color ${0}
snippet bdli
	border-left-image url(${0})
snippet bdli:n
	border-left-image none
snippet bdls
	border-left-style ${0}
snippet bdls:n
	border-left-style none
snippet bdlw
	border-left-width ${0}
snippet bdl
	border-left ${0}
snippet bdl:n
	border-left none
snippet bdlt
	border-length ${0}
snippet bdlt:a
	border-length auto
snippet bdrz
	border-radius ${0}
snippet bdr+
	border-right ${1:1px} ${2:solid} ${0}
snippet bdrc
	border-right-color ${0}
snippet bdri
	border-right-image url(${0})
snippet bdri:n
	border-right-image none
snippet bdrs
	border-right-style ${0}
snippet bdrs:n
	border-right-style none
snippet bdrw
	border-right-width ${0}
snippet bdr
	border-right ${0}
snippet bdr:n
	border-right none
snippet bdsp
	border-spacing ${0}
snippet bds
	border-style ${0}
snippet bds:ds
	border-style dashed
snippet bds:dtds
	border-style dot-dash
snippet bds:dtdtds
	border-style dot-dot-dash
snippet bds:dt
	border-style dotted
snippet bds:db
	border-style double
snippet bds:g
	border-style groove
snippet bds:h
	border-style hidden
snippet bds:i
	border-style inset
snippet bds:n
	border-style none
snippet bds:o
	border-style outset
snippet bds:r
	border-style ridge
snippet bds:s
	border-style solid
snippet bds:w
	border-style wave
snippet bdt+
	border-top ${1:1px} ${2:solid} ${0}
snippet bdtc
	border-top-color ${0}
snippet bdti
	border-top-image url(${0})
snippet bdti:n
	border-top-image none
snippet bdtli
	border-top-left-image url(${0})
snippet bdtli:c
	border-corner-image continue
snippet bdtli:n
	border-corner-image none
snippet bdtlrz
	border-top-left-radius ${0}
snippet bdtri
	border-top-right-image url(${0})
snippet bdtri:c
	border-top-right-image continue
snippet bdtri:n
	border-top-right-image none
snippet bdtrrz
	border-top-right-radius ${0}
snippet bdts
	border-top-style ${0}
snippet bdts:n
	border-top-style none
snippet bdtw
	border-top-width ${0}
snippet bdt
	border-top ${0}
snippet bdt:n
	border-top none
snippet bdw
	border-width ${0}
snippet bd
	border ${0}
snippet bd:n
	border none
snippet b
	bottom ${0}
snippet b:a
	bottom auto
snippet bxsh+
	box-shadow ${1:0} ${2:0} ${3:0} ${0}
snippet bxsh
	box-shadow ${0}
snippet bxsh:n
	box-shadow none
snippet bxz
	box-sizing ${0}
snippet bxz:bb
	box-sizing border-box
snippet bxz:cb
	box-sizing content-box
snippet cps
	caption-side ${0}
snippet cps:b
	caption-side bottom
snippet cps:t
	caption-side top
snippet cl
	clear ${0}
snippet cl:b
	clear both
snippet cl:l
	clear left
snippet cl:n
	clear none
snippet cl:r
	clear right
snippet cp
	clip ${0}
snippet cp:a
	clip auto
snippet cp:r
	clip rect(${1:0} ${2:0} ${3:0} ${0:0})
snippet c
	color ${0}
snippet ct
	content ${0}
snippet ct:a
	content attr(${0})
snippet ct:cq
	content close-quote
snippet ct:c
	content counter(${0})
snippet ct:cs
	content counters(${0})
snippet ct:ncq
	content no-close-quote
snippet ct:noq
	content no-open-quote
snippet ct:n
	content normal
snippet ct:oq
	content open-quote
snippet coi
	counter-increment ${0}
snippet cor
	counter-reset ${0}
snippet cur
	cursor ${0}
snippet cur:a
	cursor auto
snippet cur:c
	cursor crosshair
snippet cur:d
	cursor default
snippet cur:ha
	cursor hand
snippet cur:he
	cursor help
snippet cur:m
	cursor move
snippet cur:p
	cursor pointer
snippet cur:t
	cursor text
snippet d
	display ${0}
snippet d:mib
	display -moz-inline-box
snippet d:mis
	display -moz-inline-stack
snippet d:b
	display block
snippet d:cp
	display compact
snippet d:g
	display grid
snippet d:f
	display flex
snippet d:ib
	display inline-block
snippet d:itb
	display inline-table
snippet d:i
	display inline
snippet d:li
	display list-item
snippet d:n
	display none
snippet d:ri
	display run-in
snippet d:tbcp
	display table-caption
snippet d:tbc
	display table-cell
snippet d:tbclg
	display table-column-group
snippet d:tbcl
	display table-column
snippet d:tbfg
	display table-footer-group
snippet d:tbhg
	display table-header-group
snippet d:tbrg
	display table-row-group
snippet d:tbr
	display table-row
snippet d:tb
	display table
snippet ec
	empty-cells ${0}
snippet ec:h
	empty-cells hide
snippet ec:s
	empty-cells show
snippet exp
	expression()
snippet fl
	float ${0}
snippet fl:l
	float left
snippet fl:n
	float none
snippet fl:r
	float right
snippet f+
	font ${1:1em} ${2:Arial},${0:sans-serif}
snippet fef
	font-effect ${0}
snippet fef:eb
	font-effect emboss
snippet fef:eg
	font-effect engrave
snippet fef:n
	font-effect none
snippet fef:o
	font-effect outline
snippet femp
	font-emphasize-position ${0}
snippet femp:a
	font-emphasize-position after
snippet femp:b
	font-emphasize-position before
snippet fems
	font-emphasize-style ${0}
snippet fems:ac
	font-emphasize-style accent
snippet fems:c
	font-emphasize-style circle
snippet fems:ds
	font-emphasize-style disc
snippet fems:dt
	font-emphasize-style dot
snippet fems:n
	font-emphasize-style none
snippet fem
	font-emphasize ${0}
snippet ff
	font-family ${0}
snippet ff:c
	font-family ${0:'Monotype Corsiva','Comic Sans MS'},cursive
snippet ff:f
	font-family ${0:Capitals,Impact},fantasy
snippet ff:m
	font-family ${0:Monaco,'Courier New'},monospace
snippet ff:ss
	font-family ${0:Helvetica,Arial},sans-serif
snippet ff:s
	font-family ${0:Georgia,'Times New Roman'},serif
snippet fza
	font-size-adjust ${0}
snippet fza:n
	font-size-adjust none
snippet fz
	font-size ${0}
snippet fsm
	font-smooth ${0}
snippet fsm:aw
	font-smooth always
snippet fsm:a
	font-smooth auto
snippet fsm:n
	font-smooth never
snippet fst
	font-stretch ${0}
snippet fst:c
	font-stretch condensed
snippet fst:e
	font-stretch expanded
snippet fst:ec
	font-stretch extra-condensed
snippet fst:ee
	font-stretch extra-expanded
snippet fst:n
	font-stretch normal
snippet fst:sc
	font-stretch semi-condensed
snippet fst:se
	font-stretch semi-expanded
snippet fst:uc
	font-stretch ultra-condensed
snippet fst:ue
	font-stretch ultra-expanded
snippet fs
	font-style ${0}
snippet fs:i
	font-style italic
snippet fs:n
	font-style normal
snippet fs:o
	font-style oblique
snippet fv
	font-variant ${0}
snippet fv:n
	font-variant normal
snippet fv:sc
	font-variant small-caps
snippet fw
	font-weight ${0}
snippet fw:b
	font-weight bold
snippet fw:br
	font-weight bolder
snippet fw:lr
	font-weight lighter
snippet fw:n
	font-weight normal
snippet f
	font ${0}
snippet g
	grid ${0}
snippet gaf
	grid-auto-flow ${0}
snippet gaf+
	grid-auto-flow ${1:row} ${0:dense}
snippet gaf:r
	grid-auto-flow row
snippet gaf:c
	grid-auto-flow column
snippet gaf:d
	grid-auto-flow dense
snippet gaf:rd
	grid-auto-flow row dense
snippet gaf:cd
	grid-auto-flow column dense
snippet gar
	grid-auto-rows ${0}
snippet gar:a
	grid-auto-rows auto
snippet gar:mac
	grid-auto-rows max-content
snippet gar:mic
	grid-auto-rows min-content
snippet gac
	grid-auto-columns ${0}
snippet gac:a
	grid-auto-columns auto
snippet gac:mac
	grid-auto-columns max-content
snippet gac:mic
	grid-auto-columns min-content
snippet gt
	grid-template ${0}
snippet gt+
	grid-template ${1} / ${0}
snippet gtr
	grid-template-rows ${0}
snippet gtc
	grid-template-columns ${0}
snippet gta
	grid-template-areas ${0}
snippet gg
	grid-gap ${0}
snippet gg+
	grid-gap ${1} ${0}
snippet gg:0
	grid-gap 0
snippet grg
	grid-row-gap ${0}
snippet grg:0
	grid-row-gap 0
snippet gcg
	grid-column-gap ${0}
snippet gcg:0
	grid-column-gap 0
snippet gr
	grid-row ${1} / ${0}
snippet grs
	grid-row-start ${0}
snippet gre
	grid-row-end ${0}
snippet gc
	grid-column ${1} / ${0}
snippet gcs
	grid-column-start ${0}
snippet gce
	grid-column-end ${0}
snippet h
	height ${0}
snippet h:a
	height auto
snippet l
	left ${0}
snippet l:a
	left auto
snippet lts
	letter-spacing ${0}
snippet lh
	line-height ${0}
snippet lisi
	list-style-image url(${0})
snippet lisi:n
	list-style-image none
snippet lisp
	list-style-position ${0}
snippet lisp:i
	list-style-position inside
snippet lisp:o
	list-style-position outside
snippet list
	list-style-type ${0}
snippet list:c
	list-style-type circle
snippet list:dclz
	list-style-type decimal-leading-zero
snippet list:dc
	list-style-type decimal
snippet list:d
	list-style-type disc
snippet list:lr
	list-style-type lower-roman
snippet list:n
	list-style-type none
snippet list:s
	list-style-type square
snippet list:ur
	list-style-type upper-roman
snippet lis
	list-style ${0}
snippet lis:n
	list-style none
snippet mb
	margin-bottom ${0}
snippet mb:a
	margin-bottom auto
snippet ml
	margin-left ${0}
snippet ml:a
	margin-left auto
snippet mr
	margin-right ${0}
snippet mr:a
	margin-right auto
snippet mt
	margin-top ${0}
snippet mt:a
	margin-top auto
snippet m
	margin ${0}
snippet m:4
	margin ${1:0} ${2:0} ${3:0} ${0:0}
snippet m:3
	margin ${1:0} ${2:0} ${0:0}
snippet m:2
	margin ${1:0} ${0:0}
snippet m:0
	margin 0
snippet m:a
	margin auto
snippet mah
	max-height ${0}
snippet mah:n
	max-height none
snippet maw
	max-width ${0}
snippet maw:n
	max-width none
snippet mih
	min-height ${0}
snippet miw
	min-width ${0}
snippet op
	opacity ${0}
snippet op:ie
	filter progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})
snippet op:ms
	-ms-filter 'progid:DXImageTransform.Microsoft.Alpha(Opacity=${0:100})'
snippet orp
	orphans ${0}
snippet o+
	outline ${1:1px} ${2:solid} ${0}
snippet oc
	outline-color ${0}
snippet oc:i
	outline-color invert
snippet oo
	outline-offset ${0}
snippet os
	outline-style ${0}
snippet ow
	outline-width ${0}
snippet o
	outline ${0}
snippet o:n
	outline none
snippet ovs
	overflow-style ${0}
snippet ovs:a
	overflow-style auto
snippet ovs:mq
	overflow-style marquee
snippet ovs:mv
	overflow-style move
snippet ovs:p
	overflow-style panner
snippet ovs:s
	overflow-style scrollbar
snippet ovx
	overflow-x ${0}
snippet ovx:a
	overflow-x auto
snippet ovx:h
	overflow-x hidden
snippet ovx:s
	overflow-x scroll
snippet ovx:v
	overflow-x visible
snippet ovy
	overflow-y ${0}
snippet ovy:a
	overflow-y auto
snippet ovy:h
	overflow-y hidden
snippet ovy:s
	overflow-y scroll
snippet ovy:v
	overflow-y visible
snippet ov
	overflow ${0}
snippet ov:a
	overflow auto
snippet ov:h
	overflow hidden
snippet ov:s
	overflow scroll
snippet ov:v
	overflow visible
snippet pb
	padding-bottom ${0}
snippet pl
	padding-left ${0}
snippet pr
	padding-right ${0}
snippet pt
	padding-top ${0}
snippet p
	padding ${0}
snippet p:4
	padding ${1:0} ${2:0} ${3:0} ${0:0}
snippet p:3
	padding ${1:0} ${2:0} ${0:0}
snippet p:2
	padding ${1:0} ${0:0}
snippet p:0
	padding 0
snippet pc
	place-content ${0}
snippet pc+
	place-content ${1} ${0}
snippet pc:s
	place-content start
snippet pc:e
	place-content end
snippet pc:c
	place-content center
snippet pc:fs
	place-content flex-start
snippet pc:fe
	place-content flex-end
snippet pc:sb
	place-content space-between
snippet pc:sa
	place-content space-around
snippet pc:se
	place-content space-evenly
snippet pc:st
	place-content stretch
snippet pgba
	page-break-after ${0}
snippet pgba:aw
	page-break-after always
snippet pgba:a
	page-break-after auto
snippet pgba:l
	page-break-after left
snippet pgba:r
	page-break-after right
snippet pgbb
	page-break-before ${0}
snippet pgbb:aw
	page-break-before always
snippet pgbb:a
	page-break-before auto
snippet pgbb:l
	page-break-before left
snippet pgbb:r
	page-break-before right
snippet pgbi
	page-break-inside ${0}
snippet pgbi:a
	page-break-inside auto
snippet pgbi:av
	page-break-inside avoid
snippet pi
	place-items ${0}
snippet pi+
	place-items ${1:stretch} ${0:stretch}
snippet pi:s
	place-items start
snippet pi:e
	place-items end
snippet pi:c
	place-items center
snippet pi:st
	place-items stretch
snippet pos
	position ${0}
snippet pos:a
	position absolute
snippet pos:f
	position fixed
snippet pos:r
	position relative
snippet pos:s
	position static
snippet ps
	place-self ${0}
snippet ps+
	place-self ${1:stretch} ${0:stretch}
snippet ps:s
	place-self start
snippet ps:e
	place-self end
snippet ps:c
	place-self center
snippet ps:st
	place-self stretch
snippet q
	quotes ${0}
snippet q:en
	quotes '\201C' '\201D' '\2018' '\2019'
snippet q:n
	quotes none
snippet q:ru
	quotes '\00AB' '\00BB' '\201E' '\201C'
snippet rz
	resize ${0}
snippet rz:b
	resize both
snippet rz:h
	resize horizontal
snippet rz:n
	resize none
snippet rz:v
	resize vertical
snippet r
	right ${0}
snippet r:a
	right auto
snippet tbl
	table-layout ${0}
snippet tbl:a
	table-layout auto
snippet tbl:f
	table-layout fixed
snippet tal
	text-align-last ${0}
snippet tal:a
	text-align-last auto
snippet tal:c
	text-align-last center
snippet tal:l
	text-align-last left
snippet tal:r
	text-align-last right
snippet ta
	text-align ${0}
snippet ta:c
	text-align center
snippet ta:l
	text-align left
snippet ta:r
	text-align right
snippet td
	text-decoration ${0}
snippet td:l
	text-decoration line-through
snippet td:n
	text-decoration none
snippet td:o
	text-decoration overline
snippet td:u
	text-decoration underline
snippet te
	text-emphasis ${0}
snippet te:ac
	text-emphasis accent
snippet te:a
	text-emphasis after
snippet te:b
	text-emphasis before
snippet te:c
	text-emphasis circle
snippet te:ds
	text-emphasis disc
snippet te:dt
	text-emphasis dot
snippet te:n
	text-emphasis none
snippet th
	text-height ${0}
snippet th:a
	text-height auto
snippet th:f
	text-height font-size
snippet th:m
	text-height max-size
snippet th:t
	text-height text-size
snippet ti
	text-indent ${0}
snippet ti:-
	text-indent -9999px
snippet tj
	text-justify ${0}
snippet tj:a
	text-justify auto
snippet tj:d
	text-justify distribute
snippet tj:ic
	text-justify inter-cluster
snippet tj:ii
	text-justify inter-ideograph
snippet tj:iw
	text-justify inter-word
snippet tj:k
	text-justify kashida
snippet tj:t
	text-justify tibetan
snippet to+
	text-outline ${1:0} ${2:0} ${0}
snippet to
	text-outline ${0}
snippet to:n
	text-outline none
snippet tr
	text-replace ${0}
snippet tr:n
	text-replace none
snippet tsh+
	text-shadow ${1:0} ${2:0} ${3:0} ${0}
snippet tsh
	text-shadow ${0}
snippet tsh:n
	text-shadow none
snippet tt
	text-transform ${0}
snippet tt:c
	text-transform capitalize
snippet tt:l
	text-transform lowercase
snippet tt:n
	text-transform none
snippet tt:u
	text-transform uppercase
snippet tw
	text-wrap ${0}
snippet tw:no
	text-wrap none
snippet tw:n
	text-wrap normal
snippet tw:s
	text-wrap suppress
snippet tw:u
	text-wrap unrestricted
snippet t
	top ${0}
snippet t:a
	top auto
snippet va
	vertical-align ${0}
snippet va:bl
	vertical-align baseline
snippet va:b
	vertical-align bottom
snippet va:m
	vertical-align middle
snippet va:sub
	vertical-align sub
snippet va:sup
	vertical-align super
snippet va:tb
	vertical-align text-bottom
snippet va:tt
	vertical-align text-top
snippet va:t
	vertical-align top
snippet v
	visibility ${0}
snippet v:c
	visibility collapse
snippet v:h
	visibility hidden
snippet v:v
	visibility visible
snippet whsc
	white-space-collapse ${0}
snippet whsc:ba
	white-space-collapse break-all
snippet whsc:bs
	white-space-collapse break-strict
snippet whsc:k
	white-space-collapse keep-all
snippet whsc:l
	white-space-collapse loose
snippet whsc:n
	white-space-collapse normal
snippet whs
	white-space ${0}
snippet whs:n
	white-space normal
snippet whs:nw
	white-space nowrap
snippet whs:pl
	white-space pre-line
snippet whs:pw
	white-space pre-wrap
snippet whs:p
	white-space pre
snippet wid
	widows ${0}
snippet w
	width ${0}
snippet w:a
	width auto
snippet wob
	word-break ${0}
snippet wob:ba
	word-break break-all
snippet wob:bs
	word-break break-strict
snippet wob:k
	word-break keep-all
snippet wob:l
	word-break loose
snippet wob:n
	word-break normal
snippet wos
	word-spacing ${0}
snippet wow
	word-wrap ${0}
snippet wow:no
	word-wrap none
snippet wow:n
	word-wrap normal
snippet wow:s
	word-wrap suppress
snippet wow:u
	word-wrap unrestricted
snippet z
	z-index ${0}
snippet z:a
	z-index auto
snippet zoo
	zoom 1
snippet :h
	:hover
snippet :fc
	:first-child
snippet :lc
	:last-child
snippet :nc
	:nth-child(${0})
snippet :nlc
	:nth-last-child(${0})
snippet :oc
	:only-child
snippet :a
	:after
snippet :b
	:before
snippet ::a
	::after
snippet ::b
	::before
snippet if
	if ${0}
snippet mix
	${1}(${0})
snippet for
	for ${1:i} in ${0}
snippet keyf
	@keyframes ${0}
snippet jc
	justify-content ${0}
snippet jc:s
	justify-content start
snippet jc:e
	justify-content end
snippet jc:c
	justify-content center
snippet jc:fs
	justify-content flex-start
snippet jc:fe
	justify-content flex-end
snippet jc:sb
	justify-content space-between
snippet jc:sa
	justify-content space-around
snippet jc:se
	justify-content space-evenly
snippet jc:st
	justify-content space-evenly
snippet jc:l
	justify-content left
snippet jc:r
	justify-content right
snippet ji
	justify-items ${0}
snippet ji:s
	justify-items start
snippet ji:e
	justify-items end
snippet ji:c
	justify-items center
snippet ji:st
	justify-items stretch
snippet js
	justify-self ${0}
snippet js:s
	justify-self start
snippet js:e
	justify-self end
snippet js:c
	justify-self center
snippet js:st
	justify-self stretch
./snippets/supercollider.snippets	[[[1
22
snippet b
	(
		${0}
	)
snippet if
	if (${1}) {
		${0}
	}
snippet ife
	if (${1}) {
		${2}
	} {
		${0}
	}
snippet for
	for (${1:1}, ${2:10}) { |i|
		${0}
	}
snippet sdef
	SynthDef(\\${1:synthName}, {${2}
		${0}
	}).add;
./snippets/svelte.snippets	[[[1
1
extends html, javascript, css
./snippets/systemverilog.snippets	[[[1
73
extends verilog

# Foreach Loop
snippet forea
	foreach (${1}) begin
		${0}
	end
# Do-while statement
snippet dowh
	do begin
		${0}
	end while (${1});
# Combinational always block
snippet alc
	always_comb begin ${1:: statement_label}
		${0}
	end $1
# Sequential logic
snippet alff
	always_ff @(posedge ${1:clk}) begin ${2:: statement_label}
		${0}
	end $2
# Latched logic
snippet all
	always_latch begin ${1:: statement_label}
		${0}
	end $1
# Class
snippet cl
	class ${1:class_name};
		// data or class properties
		${0}

		// initialization
		function new();
		endfunction : new

	endclass : $1
# Typedef structure
snippet types
	typedef struct {
		${0}
	} ${1:name_t};
# Program block
snippet prog
	program ${1:program_name} ();
		${0}
	endprogram : $1
# Interface block
snippet intf
	interface ${1:program_name} ();
		// nets
		${0}
		// clocking

		// modports

	endinterface : $1
# Clocking Block
snippet clock
	clocking ${1:clocking_name} @(${2:posedge} ${3:clk});
		${0}
	endclocking : $1
# Covergroup construct
snippet cg
	covergroup ${1:group_name} @(${2:posedge} ${3:clk});
		${0}
	endgroup : $1
# Package declaration
snippet pkg
	package ${1:package_name};
		${0}
	endpackage : $1
./snippets/tcl.snippets	[[[1
96
# #!/usr/bin/env tclsh
snippet #!
	#!/usr/bin/env tclsh

# Process
snippet pro
	proc ${1:function_name} {${2:args}} {
		${0}
	}
#xif
snippet xif
	${1:expr}? ${2:true} : ${0:false}
# Conditional
snippet if
	if {${1}} {
		${0}
	}
# Conditional if..else
snippet ife
	if {${1}} {
		${2}
	} else {
		${0:# else...}
	}
snippet eif
	elseif {${1}} {
		${0}
	}
# Conditional if..elsif..else
snippet ifee
	if {${1}} {
		${2}
	} elseif {${3}} {
		${4:# elsif...}
	} else {
		${0:# else...}
	}
# If catch then
snippet ifc
	if { [catch {${1:#do something...}} ${2:err}] } {
		${0:# handle failure...}
	}
# Catch
snippet catch
	catch {${1}} ${2:err} ${0:options}
# While Loop
snippet wh
	while {${1}} {
		${0}
	}
# For Loop
snippet for
	for {set ${2:var} 0} {$$2 < ${1:count}} {${3:incr} $2} {
		${0}
	}
# Foreach Loop
snippet fore
	foreach ${1:x} {${2:#list}} {
		${0}
	}
# after ms script...
snippet af
	after ${1:ms} ${0:#do something}
# after cancel id
snippet afc
	after cancel ${0:id or script}
# after idle
snippet afi
	after idle ${0:script}
# after info id
snippet afin
	after info ${0:id}
# Expr
snippet exp
	expr {${0:#expression here}}
# Switch
snippet sw
	switch ${1:var} {
		${3:pattern 1} {
			${0:#do something}
		}
		default {
			${2:#do something}
		}
	}
# Case
snippet ca
	${1:pattern} {
		${2:#do something}
	}
# Namespace eval
snippet ns
	namespace eval ${1:path} {${0:#script...}}
# Namespace current
snippet nsc
	namespace current
./snippets/tex.snippets	[[[1
437
#version 1
#PREAMBLE
#documentclass without options
snippet dcl \documentclass{}
	\\documentclass{${1:class}} ${0}
#documentclass with options
snippet dclo \documentclass[]{}
	\\documentclass[${1:options}]{${2:class}} ${0}

snippet tmplt "Template"
	\\documentclass{${1:article}}

	\\usepackage{import}
	\\usepackage{pdfpages}
	\\usepackage{transparent}
	\\usepackage{xcolor}
	$2
	
	\\newcommand{\incfig}[2][1]{%
		    \def\svgwidth{#1\columnwidth}
		    \import{./figures/}{#2.pdf_tex}
	}
	$3
	\\pdfsuppresswarningpagegroup=1
	
	\\begin{document}
		    $0
	\\end{document}

#newcommand
snippet nc \newcommand
	\\newcommand{\\${1:cmd}}[${2:opt}]{${3:realcmd}} ${0}
#usepackage
snippet up \usepackage
	\\usepackage[${1:options}]{${2:package}} ${0}
#newunicodechar
snippet nuc \newunicodechar
	\\newunicodechar{${1}}{${2:\\ensuremath}${3:tex-substitute}}} ${0}
#DeclareMathOperator
snippet dmo \DeclareMathOperator
	\\DeclareMathOperator{${1}}{${2}} ${0}

#DOCUMENT
# \begin{}...\end{}
snippet begin \begin{} ... \end{} block
	\\begin{${1:env}}
		${0:${VISUAL}}
	\\end{$1}

# Maketitle
snippet mkt maketitle
	\\maketitle
	
# Tabular
snippet tab tabular (or arbitrary) environment
	\\begin{${1:tabular}}{${2:c}}
		${0:${VISUAL}}
	\\end{$1}
snippet thm thm (or arbitrary) environment with optional argument
	\\begin[${1:author}]{${2:thm}}
		${0:${VISUAL}}
	\\end{$2}
snippet center center environment
	\\begin{center}
		${0:${VISUAL}}
	\\end{center}
# Align(ed)
snippet ali align(ed) environment
	\\begin{align${1:ed}}
		\\label{eq:${2}}
		${0:${VISUAL}}
	\\end{align$1}
# Gather(ed)
snippet gat gather(ed) environment
	\\begin{gather${1:ed}}
		${0:${VISUAL}}
	\\end{gather$1}
# Equation
snippet eq equation environment
	\\begin{equation}
		${0:${VISUAL}}
	\\end{equation}
# Equation
snippet eql Labeled equation environment
	\\begin{equation}
		\\label{eq:${2}}
		${0:${VISUAL}}
	\\end{equation}
# Equation
snippet eq* unnumbered equation environment
	\\begin{equation*}
		${0:${VISUAL}}
	\\end{equation*}
# Unnumbered Equation
snippet \ unnumbered equation: \[ ... \]
	\\[
		${0:${VISUAL}}
	\\]
# Equation array
snippet eqnarray eqnarray environment
	\\begin{eqnarray}
		${0:${VISUAL}}
	\\end{eqnarray}
# Label
snippet lab \label
	\\label{${1:eq:}${2:fig:}${3:tab:}${0}}
# Enumerate
snippet enum enumerate environment
	\\begin{enumerate}
		\\item ${0}
	\\end{enumerate}
snippet enuma enumerate environment
	\\begin{enumerate}[(a)]
		\\item ${0}
	\\end{enumerate}
snippet enumi enumerate environment
	\\begin{enumerate}[(i)]
		\\item ${0}
	\\end{enumerate}
# Itemize
snippet item itemize environment
	\\begin{itemize}
		\\item ${0}
	\\end{itemize}
snippet it \item
	\\item ${1:${VISUAL}}
# Description
snippet desc description environment
	\\begin{description}
		\\item[${1}] ${0}
	\\end{description}
# Endless new item
snippet ]i \item (recursive)
	\\item ${1}
		${0:]i}
# Matrix
snippet mat smart matrix environment
	\\begin{${1:p/b/v/V/B/small}matrix}
		${0:${VISUAL}}
	\\end{$1matrix}
# Cases
snippet cas cases environment
	\\begin{cases}
		${1:equation}, &\\text{ if }${2:case}\\
		${0:${VISUAL}}
	\\end{cases}
# Split
snippet spl split environment
	\\begin{split}
		${0:${VISUAL}}
	\\end{split}
# Part
snippet part document \part
	\\part{${1:part name}} % (fold)%
	\\label{prt:${2:$1}}
	${0}
	% part $2 (end)
# Chapter
snippet cha \chapter
	\\chapter{${1:chapter name}}%
	\\label{cha:${2:$1}}
	${0}
# Section
snippet sec \section
	\\section{${1:section name}}%
	\\label{sec:${2:$1}}
	${0}
# Section without number
snippet sec* \section*
	\\section*{${1:section name}}%
	\\label{sec:${2:$1}}
	${0}
# Sub Section
snippet sub \subsection
	\\subsection{${1:subsection name}}%
	\\label{sub:${2:$1}}
	${0}
# Sub Section without number
snippet sub* \subsection*
	\\subsection*{${1:subsection name}}%
	\\label{sub:${2:$1}}
	${0}
# Sub Sub Section
snippet ssub \subsubsection
	\\subsubsection{${1:subsubsection name}}%
	\\label{ssub:${2:$1}}
	${0}
# Sub Sub Section without number
snippet ssub* \subsubsection*
	\\subsubsection*{${1:subsubsection name}}%
	\\label{ssub:${2:$1}}
	${0}
# Paragraph
snippet par \paragraph
	\\paragraph{${1:paragraph name}}%
	\\label{par:${2:$1}}
	${0}
# Sub Paragraph
snippet subp \subparagraph
	\\subparagraph{${1:subparagraph name}}%
	\\label{subp:${2:$1}}
	${0}
snippet ni \noindent
	\\noindent
	${0}
#References
snippet itd description \item
	\\item[${1:description}] ${0:item}
snippet figure reference to a figure
	${1:Figure}~\\ref{${2:fig:}}
snippet table reference to a table
	${1:Table}~\\ref{${2:tab:}}
snippet listing reference to a listing
	${1:Listing}~\\ref{${2:list}}
snippet section reference to a section
	${1:Section}~\\ref{sec:${2}} ${0}
snippet page reference to a page
	${1:page}~\\pageref{${2}} ${0}
snippet index \index
	\\index{${1:index}} ${0}
#Citations
snippet citen \citen
	\\citen{${1}} ${0}
# natbib citations
snippet citep \citep
	\\citep{${1}} ${0}
snippet citet \citet
	\\citet{${1}} ${0}
snippet cite \cite[]{}
	\\cite[${1}]{${2}} ${0}
snippet citea \citeauthor
	\\citeauthor{${1}} ${0}
snippet citey \citeyear
	\\citeyear{${1}} ${0}
snippet fcite \footcite[]{}
	\\footcite[${1}]{${2}}${0}
#Formating text: italic, bold, underline, small capital, emphase ..
snippet ita italic text
	\\textit{${1:${VISUAL:text}}}${0}
snippet bf bold face text
	\\textbf{${1:${VISUAL:text}}}${0}
snippet under underline text
	\\underline{${1:${VISUAL:text}}}${0}
snippet over overline text
	\\overline{${1:${VISUAL:text}}}${0}
snippet emp emphasize text
	\\emph{${1:${VISUAL:text}}}${0}
snippet sc small caps text
	\\textsc{${1:${VISUAL:text}}}${0}
#Choosing font
snippet sf sans serife text
	\\textsf{${1:${VISUAL:text}}}${0}
snippet rm roman font text
	\\textrm{${1:${VISUAL:text}}}${0}
snippet tt typewriter (monospace) text
	\\texttt{${1:${VISUAL:text}}}${0}
snippet tsub subscripted text
	\\textsubscript{${1:${VISUAL:text}}}${0}
snippet tsup superscripted text
	\\textsuperscript{${1:${VISUAL:text}}}${0}
#Math font
snippet mf mathfrak
	\\mathfrak{${1:${VISUAL:text}}}${0}
snippet mc mathcal
	\\mathcal{${1:${VISUAL:text}}}${0}
snippet ms mathscr
	\\mathscr{${1:${VISUAL:text}}}${0}
#misc
snippet ft \footnote
	\\footnote{${1:${VISUAL:text}}}${0}
snippet fig figure environment (includegraphics)
	\\begin{figure}
	\\begin{center}
		\\includegraphics[scale=${1}]{Figures/${2}}
	\\end{center}
	\\caption{${3}}
	\\label{fig:${4}}
	\\end{figure}
	${0}
snippet tikz figure environment (tikzpicture)
	\\begin{figure}[htpb]
	\\begin{center}
	\\begin{tikzpicture}[scale=${1:1}, transform shape]
		${2}
	\\end{tikzpicture}
	\\end{center}
	\\caption{${3}}%
	\\label{fig:${4}}
	\\end{figure}
	${0}
snippet subfig subfigure environment
	\\begin{subfigure}[${1}]{${2:\\textwidth}}
	\\begin{center}
		${3}
	\\end{center}
	\\caption{${4}}
	\\label{fig:${5}}
	\\end{subfigure}
	${0}
snippet tikzcd tikzcd environment in equation
	\\begin{equation}
	\\begin{tikzcd}
		${1}
	\\end{tikzcd}
	\\end{equation}
	${0}
snippet tikzcd* tikzcd environment in equation*
	\\begin{equation*}
	\\begin{tikzcd}
		${1}
	\\end{tikzcd}
	\\end{equation*}
	${0}
#math
snippet stackrel \stackrel{}{}
	\\stackrel{${1:above}}{${2:below}} ${0}
snippet frac \frac{}{}
	\\frac{${1:num}}{${2:denom}} ${0}
snippet sum \sum^{}_{}
	\\sum^{${1:n}}_{${2:i=1}} ${0}
snippet lim \lim_{}
	\\lim_{${1:n \\to \\infty}} ${0}
snippet frame frame environment
	\\begin{frame}[${1:t}]
		\frametitle{${2:title}}
		\framesubtitle{${3:subtitle}}
		${0:${VISUAL}}
	\\end{frame}
snippet block block environment
	\\begin{block}{${1:title}}
		${0:${VISUAL}}
	\\end{block}
snippet alert alert text
	\\alert{${1:${VISUAL:text}}} ${0}
snippet alertblock alertblock environment
	\\begin{alertblock}{${1:title}}
		${0:${VISUAL}}
	\\end{alertblock}
snippet example exampleblock environment
	\\begin{exampleblock}{${1:title}}
		${0:${VISUAL}}
	\\end{exampleblock}
snippet col2 two-column environment
	\\begin{columns}
		\\begin{column}{0.5\\textwidth}
			${1}
		\\end{column}
		\\begin{column}{0.5\\textwidth}
			${0}
		\\end{column}
	\\end{columns}
snippet multicol2 two-column environment with multicol
	\\begin{multicols}{2}
		${1}
		\columnbreak
		${0}
	\\end{multicols}
snippet \{ \{ \}
	\\{ ${0} \\}
#delimiter
snippet lr left right
	\\left${1} ${0:${VISUAL}} \\right$1
snippet lr( left( right)
	\\left( ${0:${VISUAL}} \\right)
snippet lr| left| right|
	\\left| ${0:${VISUAL}} \\right|
snippet lr{ left\{ right\}
	\\left\\{ ${0:${VISUAL}} \\right\\}
snippet lr[ left[ right]
	\\left[ ${0:${VISUAL}} \\right]
snippet lra langle rangle
	\\langle ${0:${VISUAL}} \\rangle
# Code listings
snippet lst
	\\begin{listing}[language=${1:language}]
		${0:${VISUAL}}
	\\end{listing}
snippet lsi
	\\lstinline|${1}| ${0}
# Hyperlinks
snippet url
	\\url{${1}} ${0}
snippet href
	\\href{${1}}{${2}} ${0}
# URL from Clipboard.
snippet urlc
	\\url{`@+`} ${0}
snippet hrefc
	\\href{`@+`}{${1}} ${0}
# enquote from package csquotes
snippet enq enquote
	\\enquote{${1:${VISUAL:text}}} ${0}
# Time derivative
snippet ddt time derivative
	\\frac{d}{dt} {$1} {$0}
# Limit
snippet lim limit
	\\lim_{{$1}} {{$2}} {$0}
# Partial derivative
snippet pdv partial derivation
	\\frac{\\partial {$1}}{\\partial {$2}} {$0}
# Second order partial derivative
snippet ppdv second partial derivation
	\\frac{\\partial^2 {$1}}{\\partial {$2} \\partial {$3}} {$0}
# Ordinary derivative
snippet dv derivative
	\\frac{d {$1}}{d {$2}} {$0}
# Summation
snippet summ summation
	\\sum_{{$1}} {$0}
# Shorthand for time derivative
snippet dot dot
	\\dot{{$1}} {$0}
# Shorthand for second order time derivative
snippet ddot ddot
	\\ddot{{$1}} {$0}
# Vector
snippet vec vector
	\\vec{{$1}} {$0}
# Bar
snippet bar bar
	\\bar{{$1}} {$0}
# Cross product
snippet \x cross product
	\\times {$0}
# Dot product
snippet . dot product
	\\cdot {$0}
# Integral
snippet int integral
	\\int_{{$1}}^{{$2}} {$3} \\: d{$4} {$0}
# Right arrow
snippet ra rightarrow
	\\rightarrow {$0}
# Long right arrow
snippet lra longrightarrow
	\\longrightarrow {$0}
./snippets/textile.snippets	[[[1
30
# Jekyll post header
snippet header
	---
	title: ${1:title}
	layout: post
	date: ${2:date} ${0:hour:minute:second} -05:00
	---

# Image
snippet img
	!${1:url}(${2:title}):${0:link}!

# Table
snippet |
	|${1}|

# Link
snippet link
	"${1:link text}":${0:url}

# Acronym
snippet (
	(${1:Expand acronym})

# Footnote
snippet fn
	[${1:ref number}] ${0}

	fn$1. ${2:footnote}

./snippets/twig.snippets	[[[1
177
# Tags
snippet apply "twig apply"
	{% apply ${1} %}
		${0}
	{% endapply %}
snippet autoescape "twig autoescape"
	{% autoescape %}
		${0}
	{% endautoescape %}
snippet endautoescape "twig endautoescape"
	{% endautoescape %}${0}
snippet bl "twig block"
	{% block ${1} %}
		${0}
	{% endblock %}
snippet block "twig block"
	{% block ${1} %}
		${0}
	{% endblock %}
snippet endblock "twig endblock"
	{% endblock %}${0}
snippet cache "twig cache"
	{% cache %}
		${0}
	{% endcache %}
snippet endcache "twig endcache"
	{% endcache %}${0}
snippet css "twig css"
	{% css %}
		${0}
	{% endcss %}
snippet endcss "twig endcss"
	{% endcss %}${0}
snippet dd "twig dd"
	{% dd ${1} %}${0}
snippet do "twig do"
	{% do ${1} %}${0}
snippet embed "twig embed"
	{% embed "${1}" %}
		${0}
	{% endembed %}
snippet endembed "twig endembed"
	{% endembed %}${0}
snippet exit "twig exit"
	{% exit ${1} %}
snippet extends "twig extends"
	{% extends "${1}" %}${0}
snippet ext "twig extends"
	{% extends "${1}" %}${0}
snippet for "twig for"
	{% for ${1} in ${2} %}
		${0}
	{% endfor %}
snippet fore "twig for else"
	{% for ${1} in ${2} %}
		${3}
	{% else %}
		${0}
	{% endfor %}
snippet endfor "twig endfor"
	{% endfor %}${0}
snippet from "twig from"
	{% from "${1}" import ${2} %}${0}
snippet header "twig header"
	{% header "${1}" %}${0}
snippet hook "twig hook"
	{% hook "${1}" %}${0}
snippet html "twig html"
	{% html %}
		${0}
	{% endhtml %}
snippet endhtml "twig endhtml"
	{% endhtml %}${0}
snippet if "twig if"
	{% if ${1} %}
		${0}
	{% endif %}
snippet ife "twig if else"
	{% if ${1} %}
		${2}
	{% else %}
		${0}
	{% endif %}
snippet el "twig else"
	{% else %}
snippet eif "twig elseif"
	{% elseif ${1} %}
		${0}
snippet endif "twig endif"
	{% endif %}${0}
snippet import "twig import"
	{% import "${1}" as ${2} %}${0}
snippet include "twig include"
	{% include "${1}" %}${0}
snippet includewith "twig include with parameters"
	{% include "${1}" with ${2} %}${0}
snippet js "twig js"
	{% js %}
		${0}
	{% endjs %}
snippet endjs "twig endjs"
	{% endjs %}${0}
snippet macro "twig macro"
	{% macro ${1}(${2}) %}
		${0}
	{% endmacro %}
snippet endmacro "twig endmacro"
	{% endmacro %}${0}
snippet namespace "twig namespace"
	{% namespace "${1}" %}
		${0}
	{% endnamespace %}
snippet endnamespace "twig endnamespace"
	{% endnamespace %}${0}
snippet nav "twig nav"
	{% nav ${1} in ${2} %}
		${0}
	{% endnav %}
snippet endnav "twig endnav"
	{% endnav %}${0}
snippet paginate "twig paginate"
	{% paginate ${1} as ${2} %}${0}
snippet redirect "twig redirect"
	{% redirect "${1}" %}${0}
snippet requireguest "twig requireguest"
	{% requireGuest %}${0}
snippet requirelogin "twig requirelogin"
	{% requireLogin %}${0}
snippet requirepermission "twig requirepermission"
	{% requirePermission "${1}" %}${0}
snippet set "twig set"
	{% set ${1} = ${2} %}${0}
snippet setb "twig set block"
	{% set ${1} %}
		${0}
	{% endset %}
snippet endset "twig endset"
	{% endset %}${0}
snippet switch "twig switch"
	{% switch ${1} %}
		{% case "${2}" %}
			${0}
		{% default %}
			
	{% endswitch %}
snippet case "twig switch case"
	{% case "${1}" %}
		${0}
snippet default "twig switch default"
	{% default %}
		${0}
snippet endswitch "twig endswitch"
	{% endswitch %}${0}
snippet use "twig use"
	{% use "${1}" %}${0}
snippet verbatim "twig verbatim"
	{% verbatim %}
		${0}
	{% endverbatim %}
snippet endverbatim "twig endverbatim"
	{% endverbatim %}${0}
snippet with "twig with"
	{% with %}
		${0}
	{% endwith %}
snippet endwith "twig endwith"
	{% endwith %}${0}

# Functions
snippet dump "twig dump"
	<pre>
		{{ dump(${1}) }}
	</pre>

# Filters
snippet translate "twig translate"
	{{ "${1}"|t }}${0}
./snippets/typescript.snippets	[[[1
67
extends javascript

snippet tconst "ts const"
	const ${1}: ${2:any} = ${3};
	${0}
snippet tlet "ts let"
	let ${1}: ${2:any} = ${3};
	${0}
snippet tvar "ts var"
	var ${1}: ${2:any} = ${3};
	${0}
snippet + "ts create field"
	${1}: ${0:any}
snippet #+ "ts create private field using #"
	#${1}: ${0:any}
snippet tpfi "ts create public field"
	public ${1}: ${0:any}
snippet tprfi "ts create private field"
	private ${1}: ${0:any}
snippet tprofi "ts create protected field"
	protected ${1}: ${0:any}
snippet int "interface"
	interface ${1} {
		${2}: ${3:any};
		${0}
	}
snippet intx "interface extends"
	interface ${1} extends ${2} {
		${3}: ${4:any};
		${0}
	}
snippet tfun "ts function"
	function ${1}(${2}): ${3:any} {
		${0}
	}
snippet tpmet "ts public method"
	public ${1}(${2}): ${3:any} {
		${0}
	}
snippet tpsmet "ts public static method"
	public static ${1}(${2}): ${3:any} {
		${0}
	}
snippet tprmet "ts private method"
	private ${1}(${2}): ${3:any} {
		${0}
	}
snippet tpromet "ts protected method"
	protected ${1}(${2}): ${3:any} {
		${0}
	}
snippet tcla "ts class"
	class ${1} {
		${2}
		constructor(public ${3}: ${4: any}) {
			${5}
		}
		${0}
	}
snippet tclax "ts class extends"
	class ${1} extends ${2} {
		${3}
		constructor(public ${4}: ${5: any}) {
			${6}
		}
		${0}
	}
./snippets/typescriptreact.snippets	[[[1
1
extends typescript
./snippets/verilog.snippets	[[[1
99
# if statement
snippet if
	if (${1}) begin
		${0}
	end
# If/else statements
snippet ife
	if (${1}) begin
		${2}
	end
	else begin
		${3}
	end
# Else if statement
snippet eif
	else if (${1}) begin
		${0}
	end
#Else statement
snippet el
	else begin
		${0}
	end
# While statement
snippet wh
	while (${1}) begin
		${0}
	end
# Repeat Loop
snippet rep
	repeat (${1}) begin
		${0}
	end
# Case statement
snippet case
	case (${1:/* variable */})
		${2:/* value */}: begin
			${3}
		end
		default: begin
			${4}
		end
	endcase
# CaseZ statement
snippet casez
	casez (${1:/* variable */})
		${2:/* value */}: begin
			${3}
		end
		default: begin
			${4}
		end
	endcase
# Always block
snippet al
	always @(${1:/* sensitive list */}) begin
		${0}
	end
# Module block
snippet mod
	module ${1:`vim_snippets#Filename('$1', 'name')`} (${2});
		${0}
	endmodule
# For
snippet for
	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) begin
		${4}
	end
# Forever
snippet forev
	forever begin
		${0}
	end
# Function
snippet fun
	function ${1:void} ${2:name}(${3});
		${0}
	endfunction: $2
# Task
snippet task
	task ${1:name}(${2});
		${0}
	endtask: $1
# Initial 
snippet ini
	initial begin
		${0}
	end
# typedef struct packed
snippet tdsp
	typedef struct packed {
		int ${2:data};
	} ${1:`vim_snippets#Filename('$1_t', 'name')`};
# typedef eum
snippet tde
	typedef enum ${2:logic[15:0]}
	{
		${3:REG = 16'h0000}
	} ${1:my_dest_t};
./snippets/vhdl.snippets	[[[1
137
#
## Libraries

snippet lib
	library ${1}
	use $1.${2}

# Standard Libraries
snippet libs
	library IEEE;
	use IEEE.std_logic_1164.ALL;
	use IEEE.numeric_std.ALL;

# Xilinx Library
snippet libx
	library UNISIM;
	use UNISIM.VCOMPONENTS.ALL;

## Entity Declaration
snippet ent
	entity ${1:`vim_snippets#Filename()`} is
		generic (
			${2}
		);
		port (
			${3}
		);
	end entity $1;

## Architecture
snippet arc
	architecture ${1:behav} of ${2:`vim_snippets#Filename()`} is

		${3}

	begin


	end $1;

## Declarations
# std_logic
snippet st
	signal ${1} : std_logic;
# std_logic_vector
snippet sv
	signal ${1} : std_logic_vector (${2} downto 0);
# std_logic in
snippet ist
	${1} : in std_logic;
# std_logic_vector in
snippet isv
	${1} : in std_logic_vector (${2} downto 0);
# std_logic out
snippet ost
	${1} : out std_logic;
# std_logic_vector out
snippet osv
	${1} : out std_logic_vector (${2} downto 0);
# unsigned
snippet un
	signal ${1} : unsigned (${2} downto 0);
## Process Statements
# process
snippet pr
	process (${1})
	begin
		${2}
	end process;
# process with clock
snippet prc
	process (${1:clk})
	begin
		if rising_edge ($1) then
			${2}
		end if;
	end process;
# process with clock and reset
snippet prcr
	process (${1:clk}, ${2:nrst})
	begin
		if ($2 = '${3:0}') then
			${4}
		elsif rising_edge($1) then
			${5}
		end if;
	end process;
# process all
snippet pra
	process (${1:all})
	begin
		${2}
	end process;
## Control Statements
# if
snippet if
	if ${1} then
		${2}
	end if;
# if
snippet ife
	if ${1} then
		${2}
	else
		${3}
	end if;
# else
snippet el
	else
		${1}
# if
snippet eif
	elsif ${1} then
		${2}
# case
snippet ca
	case ${1} is
		${2}
	end case;
# when
snippet wh
	when ${1} =>
		${2}
# for
snippet for
	for ${1:i} in ${2} ${3:to} ${4} loop
		${5}
	end loop;
# while
snippet wh
	while ${1} loop
		${2}
	end loop;
## Misc
# others
snippet oth
	(others => '${1:0}');
./snippets/vim.snippets	[[[1
85
snippet header standard Vim script file header
	" File: ${1:`expand('%:t')`}
	" Author: ${2:`g:snips_author`}
	" Description: ${3}
	${0:" Last Modified: `strftime("%B %d, %Y")`}
snippet guard script reload guard
	if exists('${1:did_`vim_snippets#Filename()`}') || &cp${2: || version < 700}
		finish
	endif
	let $1 = 1${0}
snippet f function
	fun! ${1:`expand('%') =~ 'autoload' ? substitute(matchstr(expand('%:p'),'autoload/\zs.*\ze.vim'),'[/\\]','#','g').'#' : ''`}${2:function_name}(${3})
		${0}
	endf
snippet t try ... catch statement
	try
		${1:${VISUAL}}
	catch ${2}
		${0}
	endtry
snippet for for ... in loop
	for ${1} in ${2}
		${0:${VISUAL}}
	endfor
snippet forkv for [key, value] in loop
	for [${1},${2}] in items(${3})
		${0}
		unlet $1 $2
	endfor
snippet wh while loop
	while ${1}
		${0:${VISUAL}}
	endw
snippet if if statement
	if ${1}
		${0:${VISUAL}}
	endif
snippet ife if ... else statement
	if ${1}
		${2:${VISUAL}}
	else
		${0}
	endif
snippet au augroup ... autocmd block
	augroup ${1:AU_NAME}
		autocmd!
		autocmd ${2:BufRead,BufNewFile} ${3:*.ext,*.ext3|<buffer[=N]>} ${0}
	augroup END
snippet auv augroupvisual ... autocmd block with visual placeholder
	augroup ${1:AU_NAME}
		autocmd!
		${0:${VISUAL}}
	augroup END
snippet bun Vundle.vim Plugin definition
	Plugin '${0}'
snippet plug vim-plug Plugin definition
	Plug '${0}'
snippet plugdo vim-plug Plugin definition with { 'do': '' }
	Plug '${1}', { 'do': '${0}' }
snippet plugon vim-plug Plugin definition with { 'on': '' }
	Plug '${1}', { 'on': '${0}' }
snippet plugfor vim-plug Plugin definition with { 'for': '' }
	Plug '${1}', { 'for': '${0}' }
snippet plugbr vim-plug Plugin definition with { 'branch': '' }
	Plug '${1}', { 'branch': '${0}' }
snippet plugtag vim-plug Plugin definition with { 'tag': '' }
	Plug '${1}', { 'tag': '${0}' }
snippet let
	let ${1:variable} = ${0: value}
snippet se
	set ${1:setting};
snippet set
	set ${1:setting} = ${0:value}
snippet nn
	nnoremap ${1} ${2}<CR>
snippet no
	noremap ${1} ${2}
snippet vm
	vmap ${1} ${2}
snippet im
	imap ${1} ${2}
snippet exe
	execute ${1}
snippet filename
	`Filename()`
./snippets/vue.snippets	[[[1
208
# This snippet file enables vue files to use tabs for html, js and css. It also
# includes some vue-specific html-like snippets, as well as some general
# boilerplate code for vue.

extends html, javascript, css

# These snippets form a port of Sarah Drasner's vue-sublime-snippets

# some html-like snippets

snippet slot
	<slot></slot>

snippet template
	<template></template>

snippet transition
	<transition></transition>

# The following snippets create more complex boilerplate code.

snippet vbase
	<template>
		<div>

		</div>
	</template>

	<script>
		export default{
			${0}
		}
	</script>

	<style scoped>

	</style>

snippet vimport:c
	import ${1:Name} from './components/$1.vue';

	export default {
		components: {
			$1
		}
	}

snippet vactions
	actions: {
		${1:updateValue}({commit}, ${2:payload}) {
			commit($1, $2);
		}
	},

# Add in js animation hooks
snippet vanim:js:el
	<transition
	  @before-enter="beforeEnter"
	  @enter="enter"
	  @after-enter="afterEnter"
	  @enter-cancelled="enterCancelled"

	  @before-Leave="beforeLeave"
	  @leave="leave"
	  @after-leave="afterLeave"
	  @leave-cancelled="leaveCancelled"
	  :css="false">

	 </transition>

snippet vanim:js:method
	methods: {
		beforeEnter(el) {
			console.log('beforeEnter');
		},
		enter(el, done) {
			console.log('enter');
			done();
		},
		afterEnter(el) {
			console.log('afterEnter');
		},
		enterCancelled(el, done) {
			console.log('enterCancelled');
		},
		beforeLeave(el) {
			console.log('beforeLeave');
		},
		leave(el, done) {
			console.log('leave');
			done();
		},
		afterLeave(el) {
			console.log('afterLeave');
		},
		leaveCancelled(el, done) {
			console.log('leaveCancelled');
		}
	}

snippet vcl
	@click="${1}"

snippet vdata
	data() {
		return {
			${1:key}: ${2:value}
		};
	},

snippet vmounted
	mounted() {
		console.log('mounted');
	},

snippet vmethods
	methods: {
		${1:method}() {
			console.log('method');
		}
	},

snippet vcomputed
	computed: {
		${1:fnName}() {
			return;
		}
	},

snippet vfilter
	filters: {
		${1:fnName}: function(${2:value}) {
			return;
		}
	},

snippet vfor
	<div v-for="${1:item} in ${2:items}" :key="$1.id">
		{{ $1 }}
	</div>

snippet vgetters
	getters: {
		${1:value}: state => {
			return state.$1;
		}
	},

snippet vimport
	import ${1:New} from './components/$1.vue';

snippet vkeep
	<keep-alive>
		<component :is="">
			<p>default</p>
		</component>
	</keep-alive>

snippet vmixin
	const ${1:mixinName} = {
		mounted() {
			console.log('hello from mixin!')
		},
	}
	const ${2:Component} = Vue.extend({
		mixins: [$1]
	})

snippet vmutations
	mutations: {
		${1:updateValue}(state, ${3:payload}) => {
			state.${2:value} = $3;
		}
	},

snippet vprops:d
	${1:propName}: {
	  type: ${2:Number},
	  default: ${0}
	},

snippet vprops
	${1:propName}: {
		type: ${2:Number}
	},

snippet vstore
	import Vue from 'vue';
	import Vuex from 'vuex';

	Vue.use(Vuex);

	export const store = new Vuex.Store({
		state: {
			${1:key}: ${2:value}
		}
	});


# vue-i18n snippets https://github.com/kazupon/vue-i18n

snippet trans
	$t('$1')

# Translation with parameter
snippet transc
	$t('$1', { $2: $3 })

./snippets/xml.snippets	[[[1
12
# xml declaration
snippet xml
	<?xml version="1.0" encoding="UTF-8"?>
# tag
snippet t
	<${1:}>
		${2}
	</$1>
# inline tag
snippet ti
	<${1:}>${2}</$1>

./snippets/xslt.snippets	[[[1
97
snippet apply-templates with-param
	<xsl:apply-templates select="${1:*}">
		<xsl:with-param name="${2:param}">${3}</xsl:with-param>${4}
	</xsl:apply-templates>

snippet apply-templates sort-by
	<xsl:apply-templates select="${1:*}">
		<xsl:sort select="${2:node}" order="${3:ascending}" data-type="${4:text}">${5}
	</xsl:apply-templates>

snippet apply-templates plain
	<xsl:apply-templates select="${1:*}" />

snippet attribute blank
	<xsl:attribute name="${1:name}">${2}</xsl:attribute>

snippet attribute value-of
	<xsl:attribute name="${1:name}">
		<xsl:value-of select="${2:*}" />
	</xsl:attribute>

snippet call-template
	<xsl:call-template name="${1:template}" />

snippet call-template with-param
	<xsl:call-template name="${1:template}">
		<xsl:with-param name="${2:param}">${3}</xsl:with-param>${4}
	</xsl:call-template>

snippet choose
	<xsl:choose>
		<xsl:when test="${1:value}">
			${2}
		</xsl:when>
	</xsl:choose>

snippet copy-of
	<xsl:copy-of select="${1:*}" />

snippet for-each
	<xsl:for-each select="${1:*}">${2}
	</xsl:for-each>

snippet if
	<xsl:if test="${1:test}">${2}
	</xsl:if>

snippet import
	<xsl:import href="${1:stylesheet}" />

snippet include
	<xsl:include href="${1:stylesheet}" />

snippet otherwise
	<xsl:otherwise>${0}
	</xsl:otherwise>

snippet param
	<xsl:param name="${1:name}">${2}
	</xsl:param>

snippet stylesheet
	<xsl:stylesheet version="1.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform">${0}
	</xsl:stylesheet>

snippet template
	<xsl:template match="${1:*}">${0}
	</xsl:template>

snippet template named
	<xsl:template name="${1:name}">${0}
	</xsl:template>

snippet text
	<xsl:text>${0}</xsl:text>

snippet value-of
	<xsl:value-of select="${1:*}" />

snippet variable blank
	<xsl:variable name="${1:name}">${0}
	</xsl:variable>

snippet variable select
	<xsl:variable select="${1:*}" />

snippet when
	<xsl:when test="${1:test}">${0}
	</xsl:when>

snippet with-param
	<xsl:with-param name="${1:name}">${0}</xsl:with-param>

snippet with-param select
	<xsl:with-param name="${1:name}" select="${0:*}" />

./snippets/yii-chtml.snippets	[[[1
248
#--------------------Yii CHtml---------------------------------
#Yii CHtml::radioButton
snippet yhrb
	echo CHtml::radioButton('${1:name}', ${2:false},array(${3:optionName}=>${0:optionValue} );

#Yii CHtml::asset
snippet yhass
	echo CHtml::asset('${0:path}');

#Yii CHtml::activeLabelEx
snippet yhale
	echo CHtml::activeLabelEx(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::encodeArray
snippet yheca
	echo CHtml::encodeArray(array(${0}));

#Yii CHtml::normalizeUrl
snippet yhnurl
	echo CHtml::normalizeUrl(array('${0}'));

#Yii CHtml::resetButton
snippet yhsb
	echo CHtml::submitButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::linkButton
snippet yhlinkb
	echo CHtml::linkButton('${1:lable}',array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::activeTextArea
snippet yhata
	echo CHtml::activeTextArea(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::ajaxButton
snippet yhajb
	echo CHtml::ajaxButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));

#Yii CHtml::activeId
snippet yhai
	echo CHtml::activeId(${1:model}, '${0:attribute}');

#Yii CHtml::activeCheckBox
snippet yhacb
	echo CHtml::activeCheckBox(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeHiddenField
snippet yhahf
	echo CHtml::activeHiddenField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::encode
snippet yhec
	echo CHtml::encode(${0:text});

#Yii CHtml::metaTag
snippet yhmtag
	echo CHtml::metaTag('${1:content}', '${2:name}', '${3:httpEquiv}',array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::dropDownList
snippet yhddl
	echo CHtml::dropDownList('${1:name}', '${2:select}', array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::listBox
snippet yhlb
	echo CHtml::listBox('${1:name}', '${2:select}',array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::script
snippet yhjs
	echo CHtml::script('${0:test}');

#Yii CHtml::ajax
snippet yhaj
	echo CHtml::ajax(array(${0}));

#Yii CHtml::textField
snippet yhtf
	echo CHtml::textField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activePasswordField
snippet yhapf
	echo CHtml::activePasswordField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::listData
snippet yhld
	echo CHtml::listData(array(${1}),'${2:valueField}', '${3:textField}','${0:groupField}');

#Yii CHtml::mailto
snippet yhmt
	echo CHtml::mailto('${1:text}', '${2:email}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::image
snippet yhimg
	echo CHtml::image('${1:src}', '${2:alt}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeListBox
snippet yhalb
	echo CHtml::activeListBox(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::activeFileField
snippet yhaff
	echo CHtml::activeFileField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::closeTag
snippet yhct
	echo CHtml::closeTag('${0:tag}');

#Yii CHtml::activeInputField
snippet yhaif
	echo CHtml::activeInputField('${1:type}', ${2:model}, '${3:attribute}',array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::scriptFile
snippet yhjsf
	echo CHtml::scriptFile('${0:url}');

#Yii CHtml::radioButtonList
snippet yhrbl
	echo CHtml::radioButtonList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::cssFile
snippet yhcssf
	echo CHtml::cssFile('${1:url}','${0:media}');

#Yii CHtml::error
snippet yherr
	echo CHtml::error(${1:model}, '${0:attribute}');

#Yii CHtml::passwordField
snippet yhpf
	echo CHtml::passwordField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::hiddenField
snippet yhhf
	echo CHtml::hiddenField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::cdata
snippet yhc
	echo CHtml::cdata(${0:text});

#Yii CHtml::link
snippet yhlink
	echo CHtml::link('${1:text}',array(${2}),array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::errorSummary
snippet yherrs
	echo CHtml::errorSummary(${1:model},'${2:headerHtml}','${0:footerHtml}');

#Yii CHtml::tag
snippet yht
	echo CHtml::tag('${1:tag}',array('${2:optionName}'=>${3:optionValue}),${4:false},${0:true});

#Yii CHtml::ajaxLink
snippet yhajl
	echo CHtml::ajaxLink('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));

#Yii CHtml::label
snippet yhlabel
	echo CHtml::label('${1:label}', '${2:for}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeName
snippet yhan
	echo CHtml::activeName(${1:model}, '${0:attribute}');

#Yii CHtml::statefulForm
snippet yhsform
	echo CHtml::statefulForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::fileField
snippet yhff
	echo CHtml::fileField('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeTextField
snippet yhatf
	echo CHtml::activeTextField(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::css
snippet yhcss
	echo CHtml::css('${1:test}','${0:media}');

#Yii CHtml::imageButton
snippet yhimgb
	echo CHtml::imageButton('${1:src}',array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::ajaxSubmitButton
snippet yhajsb
	echo CHtml::ajaxSubmitButton('${1:label}', '${2:url}',array('${3:ajaxOptionName}'=>${4:ajaxOptionValue}),array('${5:optionName}'=>${0:optionValue}));

#Yii CHtml::button
snippet yhb
	echo CHtml::button('${1:label}',array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::listOptions
snippet yhlo
	echo CHtml::listOptions('${1:selection}', array(${2}), array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeCheckBoxList
snippet yhacbl
	echo CHtml::activeCheckBoxList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::openTag
snippet yhot
	echo CHtml::openTag('${1:tag}', array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::checkBox
snippet yhcb
	echo CHtml::checkBox('${1:name}', ${2:false}, array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::textArea
snippet yhta
	echo CHtml::textArea('${1:name}', '${2:value}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::linkTag
snippet yhlinkt
	echo CHtml::linkTag('${1:relation}', '${2:type}', '${3:href}', '${4:media}',array('${5:optionName}'=>${0:optionValue}));

#Yii CHtml::resetButton
snippet yhrsb
	echo CHtml::resetButton('${1:label}',array('${2:optionName}'=>${0:optionValue}));

#Yii CHtml::activeRadioButtonList
snippet yharbl
	echo CHtml::activeRadioButtonList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::checkBoxList
snippet yhcbl
	echo CHtml::checkBoxList('${1:name}', ${2:select}, array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::form
snippet yhform
	echo CHtml::form(array('${1}'), '${2:post}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::beginForm
snippet yhbeform
	echo CHtml::beginForm(array('${1}'), '${2:post}',array('${3:optionName}'=>${4:optionValue}));
	${0}
	echo CHtml::endForm();

#Yii CHtml::activeDropDownList
snippet yhaddl
	echo CHtml::activeDropDownList(${1:model}, '${2:attribute}', array(${3}),array('${4:optionName}'=>${0:optionValue}));

#Yii CHtml::activeRadioButton
snippet yharb
	echo CHtml::activeRadioButton(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));

#Yii CHtml::activeLabel
snippet yhal
	echo CHtml::activeLabel(${1:model}, '${2:attribute}',array('${3:optionName}'=>${0:optionValue}));


./snippets/yii.snippets	[[[1
300
#Yii session offset
snippet yse
	Yii::app()->session['${0}'];

#Yii renderDynamic
snippet yrd
	$this->renderDynamic('${0:callback}');

#Yii set cache
snippet ycas
	Yii::app()->cache->set('${1:key}', ${2:value}, ${3:expire}, new C${4:}CacheDependency(${0}));

#Yii Add cache
snippet ycad
	Yii::app()->cache->add('${1:key}', ${2:value}, ${3:expire}, new C${4}CacheDependency(${0}));

#Yii register CSS file
snippet yregcf
	Yii::app()->clientScript->registerCssFile('${0:file}');

#Yii requestType
snippet yreqtype
	Yii::app()->request->requestType

#Yii isAjaxRequest
snippet yisajax
	Yii::app()->request->isAjaxRequest

#Yii translate
snippet yt
	Yii::t('${1:category}', '${2:message}',array(${0}));

#Yii register CSS
snippet yregc
	Yii::app()->clientScript->registerCss('${1:id}', '${0}');

#Yii log
snippet ylog
	Yii::log('${1:msg}', '${0:info}');

#Yii userHostAddress
snippet yuserip
	YYii::app()->request->userHostAddress

#Yii register script file
snippet yregsf
	Yii::app()->clientScript->registerScriptFile('${1:scriptUrl}', CClientScript::POS_${0:END});

#Yii CLinkPager
snippet ylinkpager
	$this->widget('CLinkPager', array('pages'=>$pages,'header'=>'${0}'}))

#Yii CJSON::encode
snippet yjec
	CJSON::encode(${0:text});

#CActiveDataProvider
snippet yadp
	$dataProvider = new CActiveDataProvider('${1}', array(
	  'criteria' => array(
			'condition' => '${2}',
			'order' => '${3}',
			'with' => array('${4}')
		),
	//'pagination' => false,
		'pagination' => array(
			'pageSize'=>${5},
		),
	));
	${0}
	// $dataProvider->getData() will return a list of Post objects

#Yii renderDynamic internal
snippet yrdi
	$this->renderDynamic('${1:callback}', array('${2:key}'=>${0:value}));

#Yii register script
snippet yregs
	Yii::app()->clientScript->registerScript('${1:id}', '${2}', CClientScript::POS_${0:READY});

#Yii Flush cache
snippet ycaf
	Yii::app()->cache->flush();

#Yii Yii::app()->request->cookies
snippet yco
	Yii::app()->request->cookies['${0}']

#Yii user->
snippet yuser
	Yii::app()->user->

#Yii refresh
snippet yrf
	$this->refresh();

#Yii import
snippet yimp
	Yii::import('${0}');

#Yii trace
snippet ytrace
	Yii::trace('${0:msg}');

#Yii params
snippet ypar
	Yii::app()->params['${0}']

#Yii isPostRequest
snippet yispost
	Yii::app()->request->isPostRequest

#Yii IF isAjaxRequest
snippet yifisajax
	if(Yii::app()->request->isAjaxRequest == TRUE)
	{
		${0}
	}

#Yii Yii::app()->cache->delete
snippet ydelcache
	Yii::app()->cache->delete('${0:key}');

#Yii render view
snippet yr
	$this->render('${1:view}',array('${2:key}'=>${0:value}));

#Yii redirect
snippet yre
	$this->redirect(array('${1:controller}/${0:action}'));

#Yii Get cache
snippet ycag
	Yii::app()->cache->get('${0:key}');

#Yii render text
snippet yrt
	$this->renderText('${0}');

#Yii render partial
snippet yrp
	$this->renderPartial('${1:view}',array('${2:key}'=>${0:value}));

#----------------Yii Model-----------------------------
#Yii Model count
snippet ycountm
	${1:ModelName}::model()->count($2, array('${3:key}'=>${0:value}));

#Yii Model countBySql
snippet ycountbs
	${1:ModelName}::model()->countBySql(${2:sql},array('${3:key}'=>${0:value}));

#Yii Model updateAll
snippet yupdatea
	${1:ModelName}::model()->updateAll(${2:array('attributes')}, $3,array('${4:key}'=>${0:value}));

#Yii Model updateByPk
snippet yupdatebp
	${1:ModelName}::model()->updateByPk(${2:pk}, ${3:array('attributes')}, $4,array('${5:key}'=>${0:value}));

#Yii Model deleteAll
snippet ydela
	${1:ModelName}::model()->deleteAll($2,array('${3:key}'=>${0:value}));

#Yii Model deleteByPk
snippet ydelbp
	${1:ModelName}::model()->deleteByPk(${2:pk}, $3, array('${4:key}'=>${0:value}));

#Yii Model find
snippet yfind
	${1:ModelName}::model()->find($2,array('${3:key}'=>${0:value}));

#Yii Model findAll
snippet yfinda
	${1:ModelName}::model()->findAll($2,array('${3:key}'=>${0:value}));

#Yii Model findByPk
snippet yfindbp
	${1:ModelName}::model()->findByPk(${2:pk}, $3, array('${4:key}'=>${0:value}));

#Yii Model findAllByPk
snippet yfindabp
	${1:ModelName}::model()->findAllByPk(${2:pk}, $3,array('${4:key}'=>${0:value}));

#Yii Model findBySql
snippet yfindbs
	${1:ModelName}::model()->findBySql(${2:sql}, array('${3:key}'=>${0:value}));

#Yii Model findAllByAttributes
snippet yfindaba
	${1:ModelName}::model()->findAllByAttributes(array('${2:attributeName}'=>${3:attributeValue}), $4, array('${5:key}'=>${0:value}));

#Yii Model exists
snippet yexists
	${1:ModelName}::model()->exists($2, array('${3:key}'=>${0:value}));

#Yii Create model class
snippet ymodel
	<?php

	class ${1:ModelName} extends ${2:CActiveRecord}
	{
		/**
		 * Returns the static model of the specified AR class.
		 * @return CActiveRecord the static model class
		 */
		public static function model($className=__CLASS__)
		{
			return parent::model($className);
		}

		/**
		 * @return string the associated database table name
		 */
		public function tableName()
		{
			return '${0:table_name}';
		}

		/**
		 * @return array validation rules for model attributes.
		 */
		public function rules()
		{
			return array(
			);
		}

		/**
		 * @return array relational rules.
		 */
		public function relations()
		{
			return array(
			);
		}

		/**
		 * @return array customized attribute labels (name=&gt;label)
		 */
		public function attributeLabels()
		{
			return array(
			);
		}
	}

#------------Yii Controller------------------------------------

#Yii Create controller class
snippet ycontroller
	<?php

	/**
	 * ${1:}
	 */
	class ${2:Site}Controller extends ${3:CController}
	{
		  public function action${4:Index}()
		  {
		      ${0}
		  }

		// -----------------------------------------------------------
		// Uncomment the following methods and override them if needed
		/*
		public function filters()
		{
			// return the filter configuration for this controller, e.g.:
			return array(
				'inlineFilterName',
				array(
					'class'=>'path.to.FilterClass',
					'propertyName'=>'propertyValue',
				),
			);
		}

		public function actions()
		{
			// return external action classes, e.g.:
			return array(
				'action1'=>'path.to.ActionClass',
				'action2'=>array(
					'class'=>'path.to.AnotherActionClass',
					'propertyName'=>'propertyValue',
				),
			);
		}
		*/
	}

#Yii Create controller action method
snippet yact
	public function action${1:Index}(${2:params})
	{
		${0}
	}


./snippets/zsh.snippets	[[[1
68
# #!/bin/zsh
extends bash

snippet #!
	#!/usr/bin/env zsh

snippet if
	if $1; then
		${0:${VISUAL}}
	fi
snippet ife
	if $1; then
		${2:${VISUAL}}
	else
		${0:# statements}
	fi
snippet eif
	elif $1; then
		${0:${VISUAL}}
snippet for
	for (( ${2:i} = 0; $2 < ${1:count}; $2++ )); do
		${0:${VISUAL}}
	done
snippet fori
	for ${1:needle} in ${2:haystack}; do
		${0:${VISUAL}}
	done
snippet fore
	for ${1:item} in ${2:list}; do
		${0:${VISUAL}}
	done
snippet wh
	while $1; do
		${0:${VISUAL}}
	done
snippet until
	until $1; do
		${0:${VISUAL}}
	done
snippet repeat
	repeat ${1:integer}; do
		${0:${VISUAL}}
	done
snippet case
	case ${1:word} in
		${2:pattern})
			${0};;
	esac
snippet select
	select ${1:answer} in ${2:choices}; do
		${0:${VISUAL}}
	done
snippet (
	( ${0:#statements} )
snippet {
	{ ${0:#statements} }
snippet [
	[[ ${0:test} ]]
snippet always
	{ ${1:try} } always { ${0:always} }
snippet fun
	${1:function_name}() {
		${0:# function_body}
	}
snippet ffun
	function ${1:function_name}() {
		${0:# function_body}
	}
./tests.sh	[[[1
37
#!/usr/bin/env bash

check=0

function test_space_indented {
  local spaced
  spaced=$(grep -REn '^ ' --include '*.snippets' snippets)

  if [[ $? -ne 1 ]]; then
    echo "These snippet lines are indented with spaces:"
    echo "$spaced"
    echo
    (( check++ ))
  fi
}

function test_snipmate_format {
  local ultisnips_in_snipmate
  ultisnips_in_snipmate=$(grep -REn 'endsnippet' --include '*.snippets' snippets)
  if [[ $? -ne 1 ]]; then
    echo "These snippet definitions are probably in UltiSnips format but stored in the snipmate directory"
    echo "$ultisnips_in_snipmate"
    echo
    (( check++ ))
  fi
}

test_space_indented
test_snipmate_format

if [ $check -eq 0 ]; then
  echo "Tests passed!"
  exit 0
else
  echo "$check test(s) failed out of 2!"
  exit 1
fi
